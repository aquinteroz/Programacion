<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>

    <meta charset="utf-8">
    <meta name="generator" content="quarto-1.3.450">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <meta name="author" content="Andrés Quintero-Zea">
    <meta name="dcterms.date" content="2024-08-28">

    <title>Manipulación de datos con Pandas</title>
    <style>
        code {
            white-space: pre-wrap;
        }

        span.smallcaps {
            font-variant: small-caps;
        }

        div.columns {
            display: flex;
            gap: min(4vw, 1.5em);
        }

        div.column {
            flex: auto;
            overflow-x: auto;
        }

        div.hanging-indent {
            margin-left: 1.5em;
            text-indent: -1.5em;
        }

        ul.task-list {
            list-style: none;
        }

        ul.task-list li input[type="checkbox"] {
            width: 0.8em;
            margin: 0 0.8em 0.2em -1em;
            /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */
            vertical-align: middle;
        }

        /* CSS for syntax highlighting */
        pre>code.sourceCode {
            white-space: pre;
            position: relative;
        }

        pre>code.sourceCode>span {
            display: inline-block;
            line-height: 1.25;
        }

        pre>code.sourceCode>span:empty {
            height: 1.2em;
        }

        .sourceCode {
            overflow: visible;
        }

        code.sourceCode>span {
            color: inherit;
            text-decoration: inherit;
        }

        div.sourceCode {
            margin: 1em 0;
        }

        pre.sourceCode {
            margin: 0;
        }

        @media screen {
            div.sourceCode {
                overflow: auto;
            }
        }

        @media print {
            pre>code.sourceCode {
                white-space: pre-wrap;
            }

            pre>code.sourceCode>span {
                text-indent: -5em;
                padding-left: 5em;
            }
        }

        pre.numberSource code {
            counter-reset: source-line 0;
        }

        pre.numberSource code>span {
            position: relative;
            left: -4em;
            counter-increment: source-line;
        }

        pre.numberSource code>span>a:first-child::before {
            content: counter(source-line);
            position: relative;
            left: -1em;
            text-align: right;
            vertical-align: baseline;
            border: none;
            display: inline-block;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            padding: 0 4px;
            width: 4em;
        }

        pre.numberSource {
            margin-left: 3em;
            padding-left: 4px;
        }


        @media screen {
            pre>code.sourceCode>span>a:first-child::before {
                text-decoration: underline;
            }
        }
    </style>

    <script src="assets/quarto-nav/quarto-nav.js"></script>
    <script src="assets/quarto-nav/headroom.min.js"></script>
    <script src="assets/clipboard/clipboard.min.js"></script>
    <script src="assets/quarto-search/autocomplete.umd.js"></script>
    <script src="assets/quarto-search/fuse.min.js"></script>
    <script src="assets/quarto-search/quarto-search.js"></script>
    <meta name="quarto:offset" content="./">
    <link href="./08_EDA.html" rel="next">
    <link href="./06_Numpy.html" rel="prev">
    <script src="assets/quarto-html/quarto.js"></script>
    <script src="assets/quarto-html/popper.min.js"></script>
    <script src="assets/quarto-html/tippy.umd.min.js"></script>
    <script src="assets/quarto-html/anchor.min.js"></script>
    <link href="assets/quarto-html/tippy.css" rel="stylesheet">
    <link href="assets/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet"
        id="quarto-text-highlighting-styles">
    <script src="assets/bootstrap/bootstrap.min.js"></script>
    <link href="assets/bootstrap/bootstrap-icons.css" rel="stylesheet">
    <link href="assets/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
    <script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"
        integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg=="
        crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js"
        integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg=="
        crossorigin="anonymous"></script>
    <script type="application/javascript">define('jquery', [], function () { return window.jQuery; })</script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>

</head>

<body class="nav-sidebar floating">

    <!-- content -->
    <div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
        <!-- sidebar -->
        <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation floating overflow-auto">
            <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
                <img src="./LogoNuevo.png" alt="" class="sidebar-logo py-0 d-lg-inline d-none">
                <div class="sidebar-title mb-0 py-0">
                    <a href="./index.html">Programación PRE2013A45</a>
                </div>
            </div>
            <div class="sidebar-menu-container">
                <ul class="list-unstyled mt-1">
                    <li class="sidebar-item sidebar-item-section">
                        <div class="sidebar-item-container">
                            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse"
                                data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
                                <span class="menu-text">Python</span></a>
                            <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse"
                                data-bs-target="#quarto-sidebar-section-1" aria-expanded="true"
                                aria-label="Toggle section">
                                <i class="bi bi-chevron-right ms-2"></i>
                            </a>
                        </div>
                        <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">
                            <li class="sidebar-item">
                                <div class="sidebar-item-container">
                                    <a href="./01_Intro_Python.html" class="sidebar-item-text sidebar-link">
                                        <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span
                                                class="chapter-title">Introducción a Python</span></span></a>
                                </div>
                            </li>
                            <li class="sidebar-item">
                                <div class="sidebar-item-container">
                                    <a href="./02_Estructuras_control.html" class="sidebar-item-text sidebar-link">
                                        <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span
                                                class="chapter-title">Estructuras de Control</span></span></a>
                                </div>
                            </li>
                            <li class="sidebar-item">
                                <div class="sidebar-item-container">
                                    <a href="./03_Funciones.html" class="sidebar-item-text sidebar-link">
                                        <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span
                                                class="chapter-title">Funciones</span></span></a>
                                </div>
                            </li>
                            <li class="sidebar-item">
                                <div class="sidebar-item-container">
                                    <a href="./04_Estructura_datos.html" class="sidebar-item-text sidebar-link">
                                        <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span
                                                class="chapter-title">Estructuras de Datos Avanzadas</span></span></a>
                                </div>
                            </li>
                            <li class="sidebar-item">
                                <div class="sidebar-item-container">
                                    <a href="./05_Archivos_excepciones.html" class="sidebar-item-text sidebar-link">
                                        <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span
                                                class="chapter-title">Manejo de Archivos y Excepciones</span></span></a>
                                </div>
                            </li>
                        </ul>
                    </li>
                    <li class="sidebar-item sidebar-item-section">
                        <div class="sidebar-item-container">
                            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse"
                                data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
                                <span class="menu-text">Análisis de Datos</span></a>
                            <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse"
                                data-bs-target="#quarto-sidebar-section-2" aria-expanded="true"
                                aria-label="Toggle section">
                                <i class="bi bi-chevron-right ms-2"></i>
                            </a>
                        </div>
                        <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">
                            <li class="sidebar-item">
                                <div class="sidebar-item-container">
                                    <a href="./06_Numpy.html" class="sidebar-item-text sidebar-link">
                                        <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span
                                                class="chapter-title">Introducción a Numpy</span></span></a>
                                </div>
                            </li>
                            <li class="sidebar-item">
                                <div class="sidebar-item-container">
                                    <a href="./07_Pandas.html" class="sidebar-item-text sidebar-link active">
                                        <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span
                                                class="chapter-title">Manipulación de Datos con Pandas</span></span></a>
                                </div>
                            </li>
                            <li class="sidebar-item">
                                <div class="sidebar-item-container">
                                    <a href="./08_EDA.html" class="sidebar-item-text sidebar-link">
                                        <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span
                                                class="chapter-title">Análisis Exploratorio de Datos
                                                (EDA)</span></span></a>
                                </div>
                            </li>
                            <li class="sidebar-item">
                                <div class="sidebar-item-container">
                                    <a href="./09_Matplotlib.html" class="sidebar-item-text sidebar-link">
                                        <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span
                                                class="chapter-title">Visualización de Datos con
                                                Matplotlib</span></span></a>
                                </div>
                            </li>
                            <li class="sidebar-item">
                                <div class="sidebar-item-container">
                                    <a href="./10_Seaborn.html" class="sidebar-item-text sidebar-link">
                                        <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span
                                                class="chapter-title">Visualización de Datos con
                                                Seaborn</span></span></a>
                                </div>
                            </li>
                        </ul>
                    </li>
                    <li class="sidebar-item sidebar-item-section">
                        <div class="sidebar-item-container">
                            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse"
                                data-bs-target="#quarto-sidebar-section-3" aria-expanded="true">
                                <span class="menu-text">Ciencia de Datos</span></a>
                            <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse"
                                data-bs-target="#quarto-sidebar-section-3" aria-expanded="true"
                                aria-label="Toggle section">
                                <i class="bi bi-chevron-right ms-2"></i>
                            </a>
                        </div>
                        <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">
                            <li class="sidebar-item">
                                <div class="sidebar-item-container">
                                    <a href="./11_Intro_DS.html" class="sidebar-item-text sidebar-link">
                                        <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span
                                                class="chapter-title">Introducción a la Ciencia de
                                                Datos</span></span></a>
                                </div>
                            </li>
                            <li class="sidebar-item">
                                <div class="sidebar-item-container">
                                    <a href="./12_Estadistica.html" class="sidebar-item-text sidebar-link">
                                        <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span
                                                class="chapter-title">Fundamentos de Estadística para Ciencia de
                                                Datos</span></span></a>
                                </div>
                            </li>
                            <li class="sidebar-item">
                                <div class="sidebar-item-container">
                                    <a href="./13_Preparacion_modelos.html" class="sidebar-item-text sidebar-link">
                                        <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span
                                                class="chapter-title">Preparación de Datos para
                                                Modelado</span></span></a>
                                </div>
                            </li>
                            <li class="sidebar-item">
                                <div class="sidebar-item-container">
                                    <a href="./14_Scikit_learn.html" class="sidebar-item-text sidebar-link">
                                        <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span
                                                class="chapter-title">Introducción al Machine Learning con
                                                Scikit-Learn</span></span></a>
                                </div>
                            </li>
                            <li class="sidebar-item">
                                <div class="sidebar-item-container">
                                    <a href="./15_Clasificacion.html" class="sidebar-item-text sidebar-link">
                                        <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span
                                                class="chapter-title">Modelos de Clasificación</span></span></a>
                                </div>
                            </li>
                            <li class="sidebar-item">
                                <div class="sidebar-item-container">
                                    <a href="./16_Regresion.html" class="sidebar-item-text sidebar-link">
                                        <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span
                                                class="chapter-title">Modelos de Regresión</span></span></a>
                                </div>
                            </li>
                        </ul>
                    </li>
                </ul>
            </div>
        </nav>
        <div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass">
        </div>
        <!-- margin-sidebar -->
                <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
            <nav id="TOC" role="doc-toc" class="toc-active">
                <h2 id="toc-title">Tabla de contenidos</h2>

                <ul>
                    <li><a href="#objetivo" id="toc-objetivo" class="nav-link active"
                            data-scroll-target="#objetivo">Objetivo</a></li>
                    <li><a href="#py-pandas-series" id="toc-py-pandas-series" class="nav-link"
                            data-scroll-target="#py-pandas-series"><span class="header-section-number"> 7.1 </span> Objeto <code>Series</code> de Pandas </a>
                        <ul class="collapse">
                            <li><a href="#py-pandas-sarray" id="toc-py-pandas-sarray" class="nav-link"
                                    data-scroll-target="#py-pandas-sarray"><span class="header-section-number"> 7.1.1 </span> <code>Series</code> como matriz NumPy generalizada </a></li>
							<li><a href="#py-pandas-sdict" id="toc-py-pandas-sdict" class="nav-link"
                                    data-scroll-target="#py-pandas-sdict"><span class="header-section-number"> 7.1.2 </span> <code>Series</code> como diccionario especializado </a></li>
							<li><a href="#py-pandas-sconst" id="toc-py-pandas-sconst" class="nav-link"
                                    data-scroll-target="#py-pandas-sconst"><span class="header-section-number"> 7.1.3 </span> Construcción de objetos <code>Series</code> </a></li>
                        </ul>
                    </li>
					
					<li><a href="#py-pandas-df" id="toc-py-pandas-df" class="nav-link"
                            data-scroll-target="#py-pandas-df"><span class="header-section-number"> 7.2 </span> El objeto <code>DataFrame</code> de Pandas </a>
							<ul class="collapse">
                            <li><a href="#py-pandas-dfarray" id="toc-py-pandas-dfarray" class="nav-link"
                                    data-scroll-target="#py-pandas-dfarray"><span class="header-section-number"> 7.2.1 </span> <code>DataFrame</code> como una matriz NumPy generalizada </a></li>
							<li><a href="#py-pandas-dfdict" id="toc-py-pandas-dfdict" class="nav-link"
                                    data-scroll-target="#py-pandas-dfdict"><span class="header-section-number"> 7.2.2 </span> <code>DataFrame</code> como diccionario especializado </a></li>
							<li><a href="#py-pandas-dfconst" id="toc-py-pandas-dfconst" class="nav-link"
                                    data-scroll-target="#py-pandas-dfconst"><span class="header-section-number"> 7.2.3 </span> Construcción de objetos <code>DataFrame</code> </a></li>
                        </ul>
                    </li>
					
					<li><a href="#py-pandas-idx" id="toc-py-pandas-idx" class="nav-link"
                            data-scroll-target="#py-pandas-idx"><span class="header-section-number"> 7.3 </span> Indexación y selección de datos </a>
							<ul class="collapse">
                            <li><a href="#py-pandas-sselect" id="toc-py-pandas-sselect" class="nav-link"
                                    data-scroll-target="#py-pandas-sselect"><span class="header-section-number"> 7.3.1 </span> Selección de datos en objetos <code>Series</code> </a></li>
							<li><a href="#py-pandas-dfselect" id="toc-py-pandas-dfselect" class="nav-link"
                                    data-scroll-target="#py-pandas-dfselect"><span class="header-section-number"> 7.3.2 </span> Selección de datos en <code>DataFrame</code> </a></li>
							<li><a href="#py-pandas-idxconv" id="toc-py-pandas-idxconv" class="nav-link"
                                    data-scroll-target="#py-pandas-idxconv"><span class="header-section-number"> 7.3.3 </span> Convenciones de indexación adicionales </a></li>
                        </ul>
                    </li>
					
					<li><a href="#py-pandas-oper" id="toc-py-pandas-oper" class="nav-link"
                            data-scroll-target="#py-pandas-oper"><span class="header-section-number"> 7.4 </span> Operando con datos en Pandas </a>
							<ul class="collapse">
                            <li><a href="#py-pandas-ufpre" id="toc-py-pandas-ufpre" class="nav-link"
                                    data-scroll-target="#py-pandas-ufpre"><span class="header-section-number"> 7.4.1 </span> Ufuncs: Preservación de índice </a></li>
							<li><a href="#py-pandas-ufalg" id="toc-py-pandas-ufalg" class="nav-link"
                                    data-scroll-target="#py-pandas-ufalg"><span class="header-section-number"> 7.4.2 </span> UFuncs: Alineación de índice </a></li>
							<li><a href="#py-pandas-ufoper" id="toc-py-pandas-ufoper" class="nav-link"
                                    data-scroll-target="#py-pandas-ufoper"><span class="header-section-number"> 7.4.3 </span> Ufuncs: Operaciones entre DataFrame y Series </a></li>
                        </ul>
                    </li>
					
					<li><a href="#py-pandas-nodata" id="toc-py-pandas-nodata" class="nav-link"
                            data-scroll-target="#py-pandas-nodata"><span class="header-section-number"> 7.5 </span> Manejo de datos faltantes </a>
							<ul class="collapse">
                            <li><a href="#py-pandas-conv" id="toc-py-pandas-conv" class="nav-link"
                                    data-scroll-target="#py-pandas-conv"><span class="header-section-number"> 7.5.1 </span> Convenciones de datos faltantes </a></li>
							<li><a href="#py-pandas-ndpandas" id="toc-py-pandas-ndpandas" class="nav-link"
                                    data-scroll-target="#py-pandas-ndpandas"><span class="header-section-number"> 7.5.2 </span> Datos faltantes en Pandas </a></li>
							<li><a href="#py-pandas-ndoper" id="toc-py-pandas-ndoper" class="nav-link"
                                    data-scroll-target="#py-pandas-ndoper"><span class="header-section-number"> 7.5.3 </span> Operando con valores nulos </a></li>
                        </ul>
                    </li>
					
					<li><a href="#py-pandas-conanex" id="toc-py-pandas-conanex" class="nav-link"
                            data-scroll-target="#py-pandas-conanex"><span class="header-section-number"> 7.6 </span> Combinación de conjuntos de datos </a>
							<ul class="collapse">
                            <li><a href="#py-pandas-concat" id="toc-py-pandas-concat" class="nav-link"
                                    data-scroll-target="#py-pandas-concat"><span class="header-section-number"> 7.6.1 </span> Concatenación simple con <code>pd.concat</code> </a></li>
							<li><a href="#py-pandas-join" id="toc-py-pandas-join" class="nav-link"
                                    data-scroll-target="#py-pandas-join"><span class="header-section-number"> 7.6.2 </span> Concatenación con uniones </a></li>
                        </ul>
                    </li>
					
                    <li><a href="#py-pandas-fusun" id="toc-py-pandas-fusun" class="nav-link"
                            data-scroll-target="#py-pandas-fusun"><span class="header-section-number"> 7.7 </span> Combinación de conjuntos de datos: fusionar y unir </a>
                        <ul class="collapse">
                            <li><a href="#py-pandas-algrel" id="toc-py-pandas-algrel" class="nav-link"
                                    data-scroll-target="#py-pandas-algrel"><span class="header-section-number"> 7.7.1 </span> Algebra relacional </a></li>
							<li><a href="#py-pandas-uncat" id="toc-py-pandas-uncat" class="nav-link"
                                    data-scroll-target="#py-pandas-uncat"><span class="header-section-number"> 7.7.2 </span> Categorías de uniones </a></li>
							<li><a href="#py-pandas-fuskey" id="toc-py-pandas-fuskey" class="nav-link"
                                    data-scroll-target="#py-pandas-fuskey"><span class="header-section-number"> 7.7.3 </span> Especificación de la clave de fusión </a></li>
							<li><a href="#py-pandas-arit" id="toc-py-pandas-arit" class="nav-link"
                                    data-scroll-target="#py-pandas-arit"><span class="header-section-number"> 7.7.4 </span> Especificación de la aritmética de conjuntos para uniones </a></li>
							<li><a href="#py-pandas-suffixes" id="toc-py-pandas-suffixes" class="nav-link"
                                    data-scroll-target="#py-pandas-suffixes"><span class="header-section-number"> 7.7.5 </span> Nombres de columnas superpuestos: la palabra clave <code>suffixes</code> </a></li>
							<li><a href="#py-pandas-exfus" id="toc-py-pandas-exfus" class="nav-link"
                                    data-scroll-target="#py-pandas-exfus"><span class="header-section-number"> 7.7.6 </span> Ejemplo </a></li>
                        </ul>
                    </li>
					
                    <li><a href="#py-pandas-agg" id="toc-py-pandas-agg" class="nav-link"
                            data-scroll-target="#py-pandas-agg"><span class="header-section-number"> 7.8 </span> Agregación y agrupación </a>
                        <ul class="collapse">
                            <li><a href="#py-pandas-planets" id="toc-py-pandas-planets" class="nav-link"
                                    data-scroll-target="#py-pandas-planets"><span class="header-section-number"> 7.8.1 </span> Datos de los planetas </a></li>
							<li><a href="#py-pandas-aggsimple" id="toc-py-pandas-aggsimple" class="nav-link"
                                    data-scroll-target="#py-pandas-aggsimple"><span class="header-section-number"> 7.8.2 </span> Agregación simple en Pandas </a></li>
							<li><a href="#py-pandas-gruopby" id="toc-py-pandas-gruopby" class="nav-link"
                                    data-scroll-target="#py-pandas-gruopby"><span class="header-section-number"> 7.8.3 </span> GroupBy </a></li>
                        </ul>
                    </li>
										
                    <li><a href="#practice-exercises" id="toc-practice-exercises" class="nav-link"
                            data-scroll-target="#practice-exercises"><span class="header-section-number">7.9</span>
                            Ejercicios prácticos</a></li>
                </ul>
            </nav>
        </div>
        <!-- main -->
        <main class="content" id="quarto-document-content">

            <header id="title-block-header" class="quarto-title-block default">
                <div class="quarto-title">
                    <h1 class="title"><span class="chapter-number">7</span>&nbsp; <span
                            class="chapter-title">Manipulación de datos con Pandas</span></h1>
                </div>
                <div class="quarto-title-meta"> </div>
            </header>

            <section id="objetivo" class="level1">
                <h1 class="anchored" data-anchor-id="objetivo">Objetivo</h1>
                <p>El objetivo de esta clase es desarrollar habilidades en el manejo y análisis de datos utilizando pandas en Python, permitiendo a los estudiantes realizar operaciones de filtrado, agrupación y manipulación de datos para obtener información valiosa de conjuntos de datos reales.</p>
            </section>
<!-- 7.1 -->
<section id="py-pandas-series" class="level2" data-number="7.1">
                <h2 data-number="7.1" class="anchored" data-anchor-id="py-pandas-series"><span
                        class="header-section-number">7.1</span> Objeto <code>Series</code> de Pandas</h2>
<p>Una <em>Serie</em> de Pandas es una matriz unidimensional de datos indexados. Se puede crear a partir de una lista o matriz de la siguiente manera:</p>
<div id="464f2664" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> pd.Series([<span class="fl">0.25</span>, <span class="fl">0.5</span>, <span class="fl">0.75</span>, <span class="fl">1.0</span>])</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>data</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Como vemos en la salida, la <em>Serie</em> envuelve una secuencia de valores y una secuencia de Índices, a los que podemos acceder con los atributos <code>values</code> e <code>Index</code>. Los <code>values</code> son simplemente una matriz NumPy:</p>
<div id="2d9bacde" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>data.values</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>El <code>Index</code> es un objeto tipo matriz de tipo <code>pd.Index</code>, que analizaremos con más detalle en breve.</p>
<div id="fbb20d9d" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>data.index</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Al igual que con una matriz NumPy, se puede acceder a los datos mediante el Index asociado a través de la conocida notación de corchetes de Python:</p>
<div id="a681260f" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>data[<span class="dv">1</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="2b0901fb" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>data[<span class="dv">1</span>:<span class="dv">3</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Sin embargo, como veremos, la <em>Serie</em> de Pandas es mucho más general y flexible que la matriz unidimensional NumPy que emula.</p>
<section id="py-pandas-sarray" class="level3" data-number="7.1.1">
                    <h3 data-number="7.1.1" class="anchored" data-anchor-id="py-pandas-sarray"><span
                            class="header-section-number">7.1.1 </span> <code>Series</code> como matriz NumPy generalizada</h3>
<p>De lo que hemos visto hasta ahora, puede parecer que el objeto <code>Series</code> es básicamente intercambiable con una matriz NumPy unidimensional. La diferencia esencial es la presencia del <code>Index</code>: mientras que la matriz Numpy tiene un <code>Index</code> entero <em>implícitamente definido</em> utilizado para acceder a los valores, el objeto <code>Series</code> de Pandas tiene un <code>Index</code> <em>explícitamente definido</em> asociado con los valores.</p>
<p>Esta definición explícita de <code>Index</code> le otorga al objeto <code>Series</code> capacidades adicionales. Por ejemplo, el <code>Index</code> no necesita ser un entero, sino que puede constar de valores de cualquier tipo deseado. Por ejemplo, si lo deseamos, podemos utilizar cadenas como <code>Index</code>:</p>
<div id="d17332cb" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> pd.Series([<span class="fl">0.25</span>, <span class="fl">0.5</span>, <span class="fl">0.75</span>, <span class="fl">1.0</span>],</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>                 index<span class="op">=</span>[<span class="st">'a'</span>, <span class="st">'b'</span>, <span class="st">'c'</span>, <span class="st">'d'</span>])</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>data</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Y el acceso al elemento funciona como se esperaba:</p>
<div id="834a77bb" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>data[<span class="st">'b'</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Incluso podemos utilizar <code>Index</code> no contiguos o no secuenciales:</p>
<div id="a6f18e71" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> pd.Series([<span class="fl">0.25</span>, <span class="fl">0.5</span>, <span class="fl">0.75</span>, <span class="fl">1.0</span>],</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>                 index<span class="op">=</span>[<span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">3</span>, <span class="dv">7</span>])</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>data</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="37fbbc45" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>data[<span class="dv">5</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="py-pandas-sdict" class="level3" data-number="7.1.2">
                    <h3 data-number="7.1.2" class="anchored" data-anchor-id="py-pandas-sdict"><span
                            class="header-section-number">7.1.2 </span> <code>Series</code> como diccionario especializado</h3>
<p>De esta manera, puedes pensar en una <code>Series</code> de Pandas como si fuera una especialización de un diccionario de Python. Un diccionario es una estructura que asigna claves arbitrarias a un conjunto de valores arbitrarios y una <code>Series</code> es una estructura que asigna claves tipificadas a un conjunto de valores tipificados. Esta tipificación es importante: así como el código compilado específico de tipo detrás de una matriz NumPy la hace más eficiente que una lista de Python para ciertas operaciones, la información de tipo de una <code>Series</code> de Pandas la hace mucho más eficiente que los diccionarios de Python para ciertas operaciones.</p>
<p>La analogía de <code>Series</code> como diccionario se puede hacer aún más clara al construir un objeto <code>Series</code> directamente desde un diccionario de Python:</p>
<div id="752c58ae" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>population_dict <span class="op">=</span> {<span class="st">'California'</span>: <span class="dv">38332521</span>,</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>                   <span class="st">'Texas'</span>: <span class="dv">26448193</span>,</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>                   <span class="st">'New York'</span>: <span class="dv">19651127</span>,</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>                   <span class="st">'Florida'</span>: <span class="dv">19552860</span>,</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>                   <span class="st">'Illinois'</span>: <span class="dv">12882135</span>}</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>population <span class="op">=</span> pd.Series(population_dict)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>population</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>De forma predeterminada, se creará una <code>Series</code> donde el <code>Index</code> se extrae de las claves ordenadas. Desde aquí se puede realizar el acceso a elementos de estilo diccionario típico:</p>
<div id="a8cface6" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>population[<span class="st">'California'</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Sin embargo, a diferencia de un diccionario, la <code>Series</code> también admite operaciones de estilo matriz, como la segmentación:</p>
<div id="27110069" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>population[<span class="st">'California'</span>:<span class="st">'Texas'</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="py-pandas-sconst" class="level3" data-number="7.1.3">
                    <h3 data-number="7.1.3" class="anchored" data-anchor-id="py-pandas-sconst"><span
                            class="header-section-number">7.1.3 </span> Construcción de objetos <code>Series</code></h3>
<p>Ya hemos visto algunas formas de construir una <code>Series</code> de Pandas desde cero; todas ellas son alguna versión de lo siguiente:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>    pd.Series(data, index<span class="op">=</span>index)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>donde <code>index</code> es un argumento opcional y <code>data</code> puede ser una de muchas entidades.</p>
<p>Por ejemplo, <code>data</code> puede ser una lista o una matriz NumPy, en cuyo caso <code>index</code> tiene como valor predeterminado una secuencia de números enteros:</p>
<div id="3bd4a43a" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>pd.Series([<span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">6</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><code>data</code> puede ser un escalar, que se repite para llenar el <code>index</code> especificado:</p>
<div id="9d8cfb30" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>pd.Series(<span class="dv">5</span>, index<span class="op">=</span>[<span class="dv">100</span>, <span class="dv">200</span>, <span class="dv">300</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><code>data</code> puede ser un diccionario, en el que <code>index</code> tiene como valor predeterminado las claves ordenadas del diccionario:</p>
<div id="214eb531" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>pd.Series({<span class="dv">2</span>:<span class="st">'a'</span>, <span class="dv">1</span>:<span class="st">'b'</span>, <span class="dv">3</span>:<span class="st">'c'</span>})</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>En cada caso, el <code>index</code> se puede establecer explícitamente si se prefiere un resultado diferente:</p>
<div id="fd8d9c09" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>pd.Series({<span class="dv">2</span>:<span class="st">'a'</span>, <span class="dv">1</span>:<span class="st">'b'</span>, <span class="dv">3</span>:<span class="st">'c'</span>}, index<span class="op">=</span>[<span class="dv">3</span>, <span class="dv">2</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Tenga en cuenta que, en este caso, la <code>Series</code> se completa únicamente con las claves identificadas explícitamente.</p>
</section>
</section>

<!-- 7.2 -->
<section id="py-pandas-df" class="level2" data-number="7.2">
                <h2 data-number="7.2" class="anchored" data-anchor-id="py-pandas-df"><span
                        class="header-section-number">7.2</span> El objeto <code>DataFrame</code> de Pandas</h2>
<p>La siguiente estructura fundamental en Pandas es el DataFrame. Al igual que el objeto Series analizado en la sección anterior, el DataFrame puede considerarse como una generalización de una matriz NumPy o como una especialización de un diccionario de Python. Ahora analizaremos cada una de estas perspectivas.</p>
<section id="py-pandas-dfarray" class="level3" data-number="7.2.1">
                    <h3 data-number="7.2.1" class="anchored" data-anchor-id="py-pandas-dfarray"><span
                            class="header-section-number">7.2.1 </span>  <code>DataFrame</code> como una matriz NumPy generalizada</h3>
<p>Si una serie es un análogo de una matriz unidimensional con índices flexibles, un <code>DataFrame</code> es un análogo de una matriz bidimensional con índices de fila flexibles y nombres de columna flexibles. Así como puedes pensar en una matriz bidimensional como una secuencia ordenada de columnas unidimensionales alineadas, puedes pensar en un <code>DataFrame</code> como una secuencia de objetos <code>Series</code> alineados. Aquí, por <strong>alineados</strong> queremos decir que comparten el mismo <code>Index</code>.</p>
<p>Para demostrar esto, construyamos primero una nueva <code>Serie</code> que enumere el área de cada uno de los cinco estados analizados en la sección anterior:</p>
<div id="6e0a1a6d" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>area_dict <span class="op">=</span> {<span class="st">'California'</span>: <span class="dv">423967</span>, <span class="st">'Texas'</span>: <span class="dv">695662</span>, <span class="st">'New York'</span>: <span class="dv">141297</span>,</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>             <span class="st">'Florida'</span>: <span class="dv">170312</span>, <span class="st">'Illinois'</span>: <span class="dv">149995</span>}</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>area <span class="op">=</span> pd.Series(area_dict)</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>area</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Ahora que tenemos esto junto con la serie <em>population</em> de antes, podemos usar un diccionario para construir un solo objeto bidimensional que contenga esta información:</p>
<div id="36a99cc6" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>states <span class="op">=</span> pd.DataFrame({<span class="st">'population'</span>: population,</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>                       <span class="st">'area'</span>: area})</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>states</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Al igual que el objeto <code>Series</code>, el <code>DataFrame</code> tiene un atributo <code>index</code> que da acceso a las etiquetas de índice:</p>
<div id="3cec7119" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>states.index</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Además, el <code>DataFrame</code> tiene un atributo <code>columns</code>, que es un objeto <code>Index</code> que contiene las etiquetas de las columnas:</p>
<div id="18435609" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>states.columns</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Por lo tanto, el DataFrame puede considerarse como una generalización de una matriz NumPy bidimensional, donde tanto las filas como las columnas tienen un Index generalizado para acceder a los datos.</p>
</section>
<section id="py-pandas-dfdict" class="level3" data-number="7.2.2">
                    <h3 data-number="7.2.2" class="anchored" data-anchor-id="py-pandas-dfdict"><span
                            class="header-section-number">7.2.2 </span> <code>DataFrame</code> como diccionario especializado</h3>
<p>De manera similar, también podemos pensar en un <code>DataFrame</code> como una especialización de un diccionario. Donde un diccionario asigna una clave a un valor, un <code>DataFrame</code> asigna un nombre de columna a una <code>Serie</code> de datos de columna. Por ejemplo, al solicitar el atributo <code>'area'</code> se devuelve el objeto <code>Serie</code> que contiene las áreas que vimos anteriormente:</p>
<div id="cc980cd5" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>states[<span class="st">'area'</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Observe el posible punto de confusión aquí: en una matriz NumPy bidimensional, <code>data[0]</code> devolverá la primera <em>fila</em>. Para un <code>DataFrame</code>, <code>data['col0']</code> devolverá la primera <em>columna</em>. Debido a esto, probablemente sea mejor pensar en los DataFrame como diccionarios generalizados en lugar de matrices generalizadas, aunque ambas formas de ver la situación pueden ser útiles.</p>
</section>
<section id="py-pandas-dfconst" class="level3" data-number="7.2.3">
                    <h3 data-number="7.2.3" class="anchored" data-anchor-id="py-pandas-dfconst"><span
                            class="header-section-number">7.2.3 </span> Construcción de objetos <code>DataFrame</code></h3>
<p>Un <code>DataFrame</code> de Pandas se puede construir de distintas maneras. Aquí daremos varios ejemplos.</p>
<section id="de-un-único-objeto-series" class="level4">
<h4 class="anchored" data-anchor-id="de-un-único-objeto-series">De un único objeto <code>Series</code></h4>
<p>Un <code>DataFrame</code> es una colección de objetos <code>Series</code> y un <code>DataFrame</code> de una sola columna se puede construir a partir de una sola <code>Series</code>:</p>
<div id="ee148fe1" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>pd.DataFrame(population, columns<span class="op">=</span>[<span class="st">'population'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="de-una-lista-de-diccionarios" class="level4">
<h4 class="anchored" data-anchor-id="de-una-lista-de-diccionarios">De una lista de diccionarios</h4>
<p>Cualquier lista de diccionarios se puede convertir en un <code>DataFrame</code>. Utilizaremos una lista de comprensión simple para crear algunos datos:</p>
<div id="c3f8ebd0" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> [{<span class="st">'x'</span>: i, <span class="st">'2*x'</span>: <span class="dv">2</span> <span class="op">*</span> i, <span class="st">'2**x'</span>: <span class="dv">2</span><span class="op">**</span>i}</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">5</span>)]</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>pd.DataFrame(data)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Incluso si faltan algunas claves en el diccionario, Pandas las completará con valores <code>NaN</code> (es decir, <code>no es un número</code>):</p>
<div id="a6889d64" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>pd.DataFrame([{<span class="st">'a'</span>: <span class="dv">1</span>, <span class="st">'b'</span>: <span class="dv">2</span>}, {<span class="st">'b'</span>: <span class="dv">3</span>, <span class="st">'c'</span>: <span class="dv">4</span>}])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="de-un-diccionario-de-objetos-serie" class="level4">
<h4 class="anchored" data-anchor-id="de-un-diccionario-de-objetos-serie">De un diccionario de objetos serie</h4>
<p>Como vimos antes, un <code>DataFrame</code> también se puede construir a partir de un diccionario de objetos <code>Series</code>:</p>
<div id="223fd4c0" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>pd.DataFrame({<span class="st">'population'</span>: population,</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>              <span class="st">'area'</span>: area})</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="desde-una-matriz-numpy-bidimensional" class="level4">
<h4 class="anchored" data-anchor-id="desde-una-matriz-numpy-bidimensional">Desde una matriz NumPy bidimensional</h4>
<p>Dada una matriz bidimensional de datos, podemos crear un <code>DataFrame</code> con cualquier nombre de columna e índice especificados. Si se omite, se utilizará un índice entero para cada uno:</p>
<div id="85a610e4" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>pd.DataFrame(np.random.rand(<span class="dv">3</span>, <span class="dv">2</span>),</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>             columns<span class="op">=</span>[<span class="st">'foo'</span>, <span class="st">'bar'</span>],</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>             index<span class="op">=</span>[<span class="st">'a'</span>, <span class="st">'b'</span>, <span class="st">'c'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
</section>

<!-- 7.3 -->
<section id="py-pandas-idx" class="level2" data-number="7.3">
                <h2 data-number="7.3" class="anchored" data-anchor-id="py-pandas-idx"><span
                        class="header-section-number">7.3</span>   Indexación y selección de datos</h2>
<p>Ya concoemos los métodos y herramientas para acceder, establecer y modificar valores en matrices NumPy. Aquí veremos medios similares para acceder y modificar valores en los objetos <code>Series</code> y <code>DataFrame</code> de Pandas. Si ha utilizado los patrones NumPy, los patrones correspondientes en Pandas le resultarán muy familiares, aunque hay algunas peculiaridades que debe tener en cuenta.</p>
<p>Comenzaremos con el caso simple del objeto unidimensional <code>Series</code> y luego pasaremos al objeto bidimensional más complicado <code>DataFrame</code>.</p>
<section id="py-pandas-sselect" class="level3" data-number="7.3.1">
                    <h3 data-number="7.3.1" class="anchored" data-anchor-id="py-pandas-sselect"><span
                            class="header-section-number">7.3.1 </span> Selección de datos en objetos <code>Series</code></h3>
<p>Como vimos en la sección anterior, un objeto <code>Series</code> actúa en un sentido como una matriz NumPy unidimensional y, en otro sentido, como un diccionario Python estándar. Si tenemos en cuenta estas dos analogías superpuestas, nos ayudará a comprender los patrones de indexación y selección de datos en estas matrices.</p>
<section id="serie-como-diccionario" class="level4">
<h4 class="anchored" data-anchor-id="serie-como-diccionario">Serie como diccionario</h4>
<p>Al igual que un diccionario, el objeto <code>Series</code> proporciona una asignación de una colección de claves a una colección de valores:</p>
<div id="943d9358" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> pd.Series([<span class="fl">0.25</span>, <span class="fl">0.5</span>, <span class="fl">0.75</span>, <span class="fl">1.0</span>],</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>                 index<span class="op">=</span>[<span class="st">'a'</span>, <span class="st">'b'</span>, <span class="st">'c'</span>, <span class="st">'d'</span>])</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>data</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="ee575b7a" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>data[<span class="st">'b'</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>También podemos utilizar expresiones y métodos de Python similares a diccionarios para examinar las claves/índices y valores:</p>
<div id="cbac95a6" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="co">'a'</span> <span class="kw">in</span> data</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="fe2bbea8" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>data.keys()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="db16c80c" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="bu">list</span>(data.items())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Los objetos <code>Series</code> pueden incluso modificarse con una sintaxis similar a la de un diccionario. Así como puedes ampliar un diccionario asignándolo a una nueva clave, puedes ampliar una <code>Series</code> asignándola a un nuevo valor de índice:</p>
<div id="436ce263" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>data[<span class="st">'e'</span>] <span class="op">=</span> <span class="fl">1.25</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>data</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Esta fácil mutabilidad de los objetos es una característica conveniente: en segundo plano, Pandas toma decisiones sobre el diseño de la memoria y la copia de datos que podría ser necesaria; el usuario generalmente no necesita preocuparse por estos problemas.</p>
</section>
<section id="serie-como-matriz-unidimensional" class="level4">
<h4 class="anchored" data-anchor-id="serie-como-matriz-unidimensional">Serie como matriz unidimensional</h4>
<p>Una <code>Series</code> se basa en esta interfaz tipo diccionario y proporciona una selección de elementos de estilo matriz a través de los mismos mecanismos básicos que las matrices NumPy, es decir, <em>secciones</em>, <em>enmascaramiento</em> e <em>indexación elegante</em>. Algunos ejemplos de estos son los siguientes:</p>
<div id="62711959" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="co"># segmentación por índice explícito</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>data[<span class="st">'a'</span>:<span class="st">'c'</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="54f52bcc" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="co"># corte por índice entero implícito</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>data[<span class="dv">0</span>:<span class="dv">2</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="5036ded8" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="co"># enmascaramiento</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>data[(data <span class="op">&gt;</span> <span class="fl">0.3</span>) <span class="op">&amp;</span> (data <span class="op">&lt;</span> <span class="fl">0.8</span>)]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="2b8d2cc6" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="co"># indexación elegante</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>data[[<span class="st">'a'</span>, <span class="st">'e'</span>]]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Entre ellos, el corte puede ser la fuente de mayor confusión. Tenga en cuenta que al cortar con un índice explícito (es decir, <code>data['a':'c']</code>), el índice final se <em>incluye</em> en la porción, mientras que al cortar con un índice implícito (es decir, <code>data[0:2]</code>), el índice final se <em>excluye</em> de la porción.</p>
</section>
<section id="indexadores-loc-e-iloc" class="level4">
<h4 class="anchored" data-anchor-id="indexadores-loc-e-iloc">Indexadores: <code>loc</code> e <code>iloc</code></h4>
<p>Estas convenciones de segmentación e indexación pueden ser una fuente de confusión. Por ejemplo, si su <code>Series</code> tiene un índice entero explícito, una operación de indexación como <code>data[1]</code> utilizará los índices explícitos, mientras que una operación de segmentación como <code>data[1:3]</code> utilizará el índice implícito de estilo Python.</p>
<div id="8eed4f80" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> pd.Series([<span class="st">'a'</span>, <span class="st">'b'</span>, <span class="st">'c'</span>], index<span class="op">=</span>[<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">5</span>])</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>data</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="a77894b6" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="co"># índice explícito al indexar</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>data[<span class="dv">1</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="3b41edf6" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="co"># índice implícito al cortar</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>data[<span class="dv">1</span>:<span class="dv">3</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Debido a esta posible confusión en el caso de índices enteros, Pandas proporciona algunos atributos <em>indexer</em> especiales que exponen explícitamente ciertos esquemas de indexación. Estos no son métodos funcionales, sino atributos que exponen una interfaz de corte particular a los datos de la <code>Series</code>.</p>
<p>En primer lugar, el atributo <code>loc</code> permite la indexación y el corte que siempre hace referencia al índice explícito:</p>
<div id="421215fc" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>data.loc[<span class="dv">1</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="d75eafd9" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>data.loc[<span class="dv">1</span>:<span class="dv">3</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>El atributo <code>iloc</code> permite la indexación y el corte que siempre hace referencia al índice implícito de estilo Python:</p>
<div id="5e94f7b8" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>data.iloc[<span class="dv">1</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="77aefdb5" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>data.iloc[<span class="dv">1</span>:<span class="dv">3</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Un principio rector del código Python es que &gt; <strong>Lo explícito es mejor que lo implícito</strong></p>
<p>La naturaleza explícita de <code>loc</code> e <code>iloc</code> los hace muy útiles para mantener un código limpio y legible; especialmente en el caso de índices enteros, recomiendo utilizar ambos para hacer que el código sea más fácil de leer y entender y para evitar errores sutiles debido a la convención mixta de indexación/segmentación.</p>
</section>
</section>
<section id="py-pandas-dfselect" class="level3" data-number="7.3.2">
                    <h3 data-number="7.3.2" class="anchored" data-anchor-id="py-pandas-dfselect"><span
                            class="header-section-number">7.3.2 </span> Selección de datos en DataFrame</h3>
<p>Recuerde que un <code>DataFrame</code> actúa en muchos sentidos como una matriz bidimensional o estructurada, y en otros sentidos como un diccionario de estructuras <code>Series</code> que comparten el mismo índice. Puede resultar útil tener en cuenta estas analogías a medida que exploramos la selección de datos dentro de esta estructura.</p>
<section id="dataframe-como-diccionario" class="level4">
<h4 class="anchored" data-anchor-id="dataframe-como-diccionario"><code>DataFrame</code> como diccionario</h4>
<p>La primera analogía que consideraremos es el <code>DataFrame</code> como un diccionario de objetos <code>Series</code> relacionados. Volvamos a nuestro ejemplo de áreas y poblaciones de estados:</p>
<div id="5b752571" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>area <span class="op">=</span> pd.Series({<span class="st">'California'</span>: <span class="dv">423967</span>, <span class="st">'Texas'</span>: <span class="dv">695662</span>,</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>                  <span class="st">'New York'</span>: <span class="dv">141297</span>, <span class="st">'Florida'</span>: <span class="dv">170312</span>,</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>                  <span class="st">'Illinois'</span>: <span class="dv">149995</span>})</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>pop <span class="op">=</span> pd.Series({<span class="st">'California'</span>: <span class="dv">38332521</span>, <span class="st">'Texas'</span>: <span class="dv">26448193</span>,</span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>                 <span class="st">'New York'</span>: <span class="dv">19651127</span>, <span class="st">'Florida'</span>: <span class="dv">19552860</span>,</span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>                 <span class="st">'Illinois'</span>: <span class="dv">12882135</span>})</span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> pd.DataFrame({<span class="st">'area'</span>:area, <span class="st">'pop'</span>:pop})</span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a>data</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Se puede acceder a las <code>Series</code> individuales que componen las columnas del <code>DataFrame</code> a través de la indexación de estilo diccionario del nombre de la columna:</p>
<div id="7e5bb767" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>data[<span class="st">'area'</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>De manera equivalente, podemos utilizar el acceso de estilo de atributo con nombres de columnas que son cadenas:</p>
<div id="7f76ae1d" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>data.area</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Este acceso a la columna de estilo de atributo en realidad accede exactamente al mismo objeto que el acceso de estilo de diccionario:</p>
<div id="1c2b8011" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>data.area <span class="kw">is</span> data[<span class="st">'area'</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Si bien esta es una abreviatura útil, tenga en cuenta que no funciona en todos los casos. Por ejemplo, si los nombres de las columnas no son cadenas o si los nombres de las columnas entran en conflicto con los métodos del <code>DataFrame</code>, este acceso de estilo de atributo no es posible. Por ejemplo, el <code>DataFrame</code> tiene un método <code>pop()</code>, por lo que <code>data.pop</code> apuntará a esto en lugar de a la columna <code>"pop"</code>:</p>
<div id="939c9493" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>data.pop <span class="kw">is</span> data[<span class="st">'pop'</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>En particular, debe evitar la tentación de intentar la asignación de columnas a través de atributos (es decir, utilizar <code>data['pop'] = z</code> en lugar de <code>data.pop = z</code>).</p>
<p>Al igual que con los objetos <code>Series</code> analizados anteriormente, esta sintaxis de estilo diccionario también se puede utilizar para modificar el objeto, en este caso agregando una nueva columna:</p>
<div id="e1728ccd" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>data[<span class="st">'density'</span>] <span class="op">=</span> data[<span class="st">'pop'</span>] <span class="op">/</span> data[<span class="st">'area'</span>]</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>data</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="dataframe-como-matriz-bidimensional" class="level4">
<h4 class="anchored" data-anchor-id="dataframe-como-matriz-bidimensional"><code>DataFrame</code> como matriz bidimensional</h4>
<p>Como se mencionó anteriormente, también podemos ver el <code>DataFrame</code> como una matriz bidimensional mejorada. Podemos examinar la matriz de datos subyacente sin procesar utilizando el atributo <code>values</code>:</p>
<div id="1d13881c" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>data.values</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Con esta imagen en mente, se pueden realizar muchas observaciones familiares de tipo matriz en el propio <code>DataFrame</code>. Por ejemplo, podemos transponer el <code>DataFrame</code> completo para intercambiar filas y columnas:</p>
<div id="5deb6b6b" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>data.T</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Sin embargo, cuando se trata de la indexación de objetos <code>DataFrame</code>, está claro que la indexación de columnas en estilo diccionario impide nuestra capacidad de tratarlo simplemente como una matriz NumPy. En particular, al pasar un único índice a una matriz se accede a una fila:</p>
<div id="36cef4fe" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>data.values[<span class="dv">0</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>y al pasar un único <code>Index</code> a un <code>DataFrame</code> se accede a una columna:</p>
<div id="a2369d48" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>data[<span class="st">'area'</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Por lo tanto, para la indexación de estilo matriz, necesitamos otra convención. Aquí Pandas vuelve a utilizar los indexadores <code>loc</code> e <code>iloc</code>mencionados anteriormente. Usando el indexador <code>iloc</code>, podemos indexar la matriz subyacente como si fuera una matriz NumPy simple (usando el índice implícito de estilo Python), pero el índice <code>DataFrame</code> y las etiquetas de columna se mantienen en el resultado:</p>
<div id="fc2e645c" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb55"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>data.iloc[:<span class="dv">3</span>, :<span class="dv">2</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>De manera similar, utilizando el indexador <code>loc</code> podemos indexar los datos subyacentes en un estilo similar a una matriz pero utilizando los nombres de índice y columna explícitos:</p>
<div id="40e1ca00" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>data.loc[:<span class="st">'Illinois'</span>, :<span class="st">'pop'</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Se puede utilizar cualquiera de los patrones familiares de acceso a datos de estilo NumPy dentro de estos indexadores. Por ejemplo, en el indexador <code>loc</code> podemos combinar enmascaramiento e indexación elegante como en lo siguiente:</p>
<div id="3babfc17" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb57"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>data.loc[data.density <span class="op">&gt;</span> <span class="dv">100</span>, [<span class="st">'pop'</span>, <span class="st">'density'</span>]]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Cualquiera de estas convenciones de indexación también se puede utilizar para establecer o modificar valores; esto se hace de la manera estándar a la que probablemente esté acostumbrado al trabajar con NumPy:</p>
<div id="3ff0bf1e" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb58"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>data.iloc[<span class="dv">0</span>, <span class="dv">2</span>] <span class="op">=</span> <span class="dv">90</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>data</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="py-pandas-idxconv" class="level3" data-number="7.3.3">
                    <h3 data-number="7.3.3" class="anchored" data-anchor-id="py-pandas-idxconv"><span
                            class="header-section-number">7.3.3 </span> Convenciones de indexación adicionales</h3>
<p>Hay un par de convenciones de indexación adicionales que pueden parecer contrarias a la discusión anterior, pero sin embargo pueden resultar muy útiles en la práctica. En primer lugar, mientras que <em>indexación</em> se refiere a columnas, <em>segmentación</em> se refiere a filas:</p>
<div id="8936cb0b" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>data[<span class="st">'Florida'</span>:<span class="st">'Illinois'</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Estas porciones también pueden hacer referencia a filas por número en lugar de por índice:</p>
<div id="dc199cad" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>data[<span class="dv">1</span>:<span class="dv">3</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>De manera similar, las operaciones de enmascaramiento directo también se interpretan por filas en lugar de por columnas:</p>
<div id="9f92c212" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>data[data.density <span class="op">&gt;</span> <span class="dv">100</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Estas dos convenciones son sintácticamente similares a aquellas de una matriz NumPy. Y si bien pueden no ajustarse exactamente al molde de las convenciones de Pandas, son bastante útiles en la práctica.</p>
</section>
</section>

<!-- 7.4 -->
<section id="py-pandas-oper" class="level2" data-number="7.4">
                <h2 data-number="7.4" class="anchored" data-anchor-id="py-pandas-oper"><span
                        class="header-section-number">7.4</span> Operando con datos en Pandas</h2>
<p>Una de las piezas esenciales de NumPy es la capacidad de realizar operaciones rápidas elemento por elemento, tanto con aritmética básica (suma, resta, multiplicación, etc.) como con operaciones más sofisticadas (funciones trigonométricas, funciones exponenciales y logarítmicas, etc.). Pandas hereda gran parte de esta funcionalidad de NumPy, y las ufuncs que presentamos en <a href="02.03-Computation-on-arrays-ufuncs.ipynb">Computation on NumPy Arrays: Universal Functions</a> son clave para esto.</p>
<p>Sin embargo, Pandas incluye un par de cambios útiles: para operaciones unarias como la negación y las funciones trigonométricas, estas ufuncs <em>preservarán las etiquetas de índice y columna</em> en la salida, y para operaciones binarias como la suma y la multiplicación, Pandas <em>alineará automáticamente los índices</em> al pasar los objetos a la ufunc. Esto significa que mantener el contexto de los datos y combinar datos de diferentes fuentes (ambas tareas potencialmente propensas a errores con matrices NumPy sin procesar) se vuelven esencialmente tareas infalibles con Pandas. Además, veremos que existen operaciones bien definidas entre estructuras unidimensionales tipo «Series» y estructuras bidimensionales tipo «DataFrame».</p>
<section id="py-pandas-ufpre" class="level3" data-number="7.4.1">
                    <h3 data-number="7.4.1" class="anchored" data-anchor-id="py-pandas-ufpre"><span
                            class="header-section-number">7.4.1 </span>  Ufuncs: Preservación de índice</h3>
<p>Debido a que Pandas está diseñado para trabajar con NumPy, cualquier ufunc de NumPy funcionará en objetos <code>Series</code> y <code>DataFrame</code> de Pandas. Comencemos por definir una <code>Serie</code> y un <code>DataFrame</code> simples sobre los cuales demostrar esto:</p>
<div id="84281604" class="cell">
<div class="sourceCode cell-code" id="cb62"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="8ef06080" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb63"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>rng <span class="op">=</span> np.random.RandomState(<span class="dv">42</span>)</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>ser <span class="op">=</span> pd.Series(rng.randint(<span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">4</span>))</span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>ser</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="b173c015" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb64"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame(rng.randint(<span class="dv">0</span>, <span class="dv">10</span>, (<span class="dv">3</span>, <span class="dv">4</span>)),</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>                  columns<span class="op">=</span>[<span class="st">'A'</span>, <span class="st">'B'</span>, <span class="st">'C'</span>, <span class="st">'D'</span>])</span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Si aplicamos una ufunc NumPy en cualquiera de estos objetos, el resultado será otro objeto Pandas <em>con los índices conservados</em>:</p>
<div id="c28b79e7" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb65"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>np.exp(ser)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>O, para un cálculo un poco más complejo:</p>
<div id="3dd640f7" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb66"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>np.sin(df <span class="op">*</span> np.pi <span class="op">/</span> <span class="dv">4</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Cualquiera de las ufuncs discutidas en <a href="02.03-Computation-on-arrays-ufuncs.ipynb">Computation on NumPy Arrays: Universal Functions</a> se puede utilizar de manera similar.</p>
</section>
<section id="py-pandas-ufalg" class="level3" data-number="7.4.2">
                    <h3 data-number="7.4.2" class="anchored" data-anchor-id="py-pandas-ufalg"><span
                            class="header-section-number">7.4.2 </span> UFuncs: Alineación de índice</h3>
<p>Para operaciones binarias en dos objetos <code>Series</code> o <code>DataFrame</code>, Pandas alineará los índices en el proceso de realización de la operación. Esto es muy conveniente cuando trabajamos con datos incompletos, como veremos en algunos de los ejemplos que siguen.</p>
<section id="alineación-de-índices-en-la-serie" class="level4">
<h4 class="anchored" data-anchor-id="alineación-de-índices-en-la-serie">Alineación de índices en la serie</h4>
<p>A modo de ejemplo, supongamos que combinamos dos fuentes de datos diferentes y encontramos solo los tres principales estados de EE. UU. por <em>área</em> y los tres principales estados de EE. UU. por <em>población</em>:</p>
<div id="29c93383" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb67"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>area <span class="op">=</span> pd.Series({<span class="st">'Alaska'</span>: <span class="dv">1723337</span>, <span class="st">'Texas'</span>: <span class="dv">695662</span>,</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>                  <span class="st">'California'</span>: <span class="dv">423967</span>}, name<span class="op">=</span><span class="st">'area'</span>)</span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>population <span class="op">=</span> pd.Series({<span class="st">'California'</span>: <span class="dv">38332521</span>, <span class="st">'Texas'</span>: <span class="dv">26448193</span>,</span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>                        <span class="st">'New York'</span>: <span class="dv">19651127</span>}, name<span class="op">=</span><span class="st">'population'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Veamos qué sucede cuando dividimos estos para calcular la densidad de población:</p>
<div id="94fbaeaa" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb68"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a>population <span class="op">/</span> area</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>La matriz resultante contiene la <em>unión</em> de los índices de las dos matrices de entrada.</p>
<p>Cualquier elemento para el cual uno u otro no tiene una entrada se marca con “NaN” o “No es un número”, que es la forma en que Pandas marca los datos faltantes. Esta coincidencia de índice se implementa de esta manera para cualquiera de las expresiones aritméticas integradas de Python; cualquier valor faltante se completa con NaN de manera predeterminada:</p>
<div id="64471eef" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb69"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> pd.Series([<span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">6</span>], index<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>])</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> pd.Series([<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">5</span>], index<span class="op">=</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>])</span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>A <span class="op">+</span> B</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Si el uso de valores NaN no es el comportamiento deseado, el valor de relleno se puede modificar utilizando métodos de objeto apropiados en lugar de los operadores. Por ejemplo, llamar a <code>A.add(B)</code> es equivalente a llamar a <code>A + B</code>, pero permite la especificación explícita opcional del valor de relleno para cualquier elemento en <code>A</code> o <code>B</code> que pueda faltar:</p>
<div id="22b10da7" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb70"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>A.add(B, fill_value<span class="op">=</span><span class="dv">0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="alineación-de-índices-en-dataframe" class="level4">
<h4 class="anchored" data-anchor-id="alineación-de-índices-en-dataframe">Alineación de índices en DataFrame</h4>
<p>Un tipo de alineación similar tiene lugar <em>tanto</em> para las columnas como para los índices cuando se realizan operaciones en <code>DataFrame</code>:</p>
<div id="df09a5b0" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb71"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> pd.DataFrame(rng.randint(<span class="dv">0</span>, <span class="dv">20</span>, (<span class="dv">2</span>, <span class="dv">2</span>)),</span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>                 columns<span class="op">=</span><span class="bu">list</span>(<span class="st">'AB'</span>))</span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a>A</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="420b5e4d" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb72"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> pd.DataFrame(rng.randint(<span class="dv">0</span>, <span class="dv">10</span>, (<span class="dv">3</span>, <span class="dv">3</span>)),</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>                 columns<span class="op">=</span><span class="bu">list</span>(<span class="st">'BAC'</span>))</span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a>B</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="f7165541" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb73"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a>A <span class="op">+</span> B</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Tenga en cuenta que los índices están alineados correctamente independientemente de su orden en los dos objetos, y los índices en el resultado están ordenados. Como fue el caso con <code>Series</code>, podemos usar el método aritmético del objeto asociado y pasar cualquier <code>fill_value</code> deseado para usar en lugar de las entradas faltantes. Aquí completaremos con la media de todos los valores en <code>A</code> (calculada apilando primero las filas de <code>A</code>):</p>
<div id="b70663a4" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb74"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a>fill <span class="op">=</span> A.stack().mean()</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>A.add(B, fill_value<span class="op">=</span>fill)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="py-pandas-ufoper" class="level3" data-number="7.4.3">
                    <h3 data-number="7.4.3" class="anchored" data-anchor-id="py-pandas-ufoper"><span
                            class="header-section-number">7.4.3 </span>Ufuncs: Operaciones entre DataFrame y Series</h3>
<p>Al realizar operaciones entre un <code>DataFrame</code> y una <code>Serie</code>, la alineación del índice y de la columna se mantiene de manera similar. Las operaciones entre un <code>DataFrame</code> y una <code>Serie</code> son similares a las operaciones entre una matriz NumPy bidimensional y unidimensional. Consideremos una operación común, donde encontramos la diferencia de una matriz bidimensional y una de sus filas:</p>
<div id="8dc3feb6" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb75"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> rng.randint(<span class="dv">10</span>, size<span class="op">=</span>(<span class="dv">3</span>, <span class="dv">4</span>))</span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a>A</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="d5eaa762" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb76"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a>A <span class="op">-</span> A[<span class="dv">0</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>De acuerdo con las reglas de transmisión de NumPy (ver <a href="02.05-Computation-on-arrays-broadcasting.ipynb">Computation on Arrays: Broadcasting</a>), la resta entre una matriz bidimensional y una de sus filas se aplica fila por fila.</p>
<p>En Pandas, la convención funciona de manera similar por fila de manera predeterminada:</p>
<div id="68defba3" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb77"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame(A, columns<span class="op">=</span><span class="bu">list</span>(<span class="st">'QRST'</span>))</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>df <span class="op">-</span> df.iloc[<span class="dv">0</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Si, en cambio, desea operar por columnas, puede utilizar los métodos de objeto mencionados anteriormente, mientras especifica la palabra clave <code>axis</code>:</p>
<div id="96a5afc1" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb78"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a>df.subtract(df[<span class="st">'R'</span>], axis<span class="op">=</span><span class="dv">0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Tenga en cuenta que estas operaciones <code>DataFrame</code>/<code>Series</code>, al igual que las operaciones analizadas anteriormente, alinearán automáticamente los índices entre los dos elementos:</p>
<div id="9ba872bc" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb79"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a>halfrow <span class="op">=</span> df.iloc[<span class="dv">0</span>, ::<span class="dv">2</span>]</span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>halfrow</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="476b4cd4" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb80"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">-</span> halfrow</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Esta preservación y alineación de índices y columnas significa que las operaciones sobre datos en Pandas siempre mantendrán el contexto de los datos, lo que evita los tipos de errores tontos que pueden surgir al trabajar con datos heterogéneos y/o desalineados en matrices NumPy sin procesar.</p>
</section>
</section>

<!-- 7.5 -->
<section id="py-pandas-nodata" class="level2" data-number="7.5">
                <h2 data-number="7.5" class="anchored" data-anchor-id="py-pandas-nodata"><span
                        class="header-section-number">7.5</span> Manejo de datos faltantes</h2>
<p>La diferencia entre los datos que se encuentran en muchos tutoriales y los datos del mundo real es que los datos del mundo real rara vez son limpios y homogéneos. En particular, en muchos conjuntos de datos interesantes faltará cierta cantidad de datos. Para complicar aún más las cosas, diferentes fuentes de datos pueden indicar datos faltantes de diferentes maneras.</p>
<p>En esta sección, analizaremos algunas consideraciones generales sobre los datos faltantes, analizaremos cómo Pandas elige representarlos y demostraremos algunas herramientas integradas de Pandas para manejar datos faltantes en Python. Aquí y a lo largo del libro, nos referiremos a los datos faltantes en general como valores <em>nulos</em>, <em>NaN</em> o <em>NA</em>.</p>
<section id="py-pandas-conv" class="level3" data-number="7.5.1">
                    <h3 data-number="7.5.1" class="anchored" data-anchor-id="py-pandas-conv"><span 
                            class="header-section-number">7.5.1 </span> Convenciones de datos faltantes</h3>
<p>Hay una serie de esquemas que se han desarrollado para indicar la presencia de datos faltantes en una tabla o DataFrame. Generalmente, giran en torno a una de dos estrategias: utilizar una <em>máscara</em> que indica globalmente los valores faltantes o elegir un <em>valor centinela</em> que indica una entrada faltante.</p>
<p>En el enfoque de enmascaramiento, la máscara puede ser una matriz booleana completamente separada o puede implicar la apropiación de un bit en la representación de datos para indicar localmente el estado nulo de un valor.</p>
<p>En el enfoque centinela, el valor centinela podría ser alguna convención específica de los datos, como indicar un valor entero faltante con -9999 o algún patrón de bits raro, o podría ser una convención más global, como indicar un valor de punto flotante faltante con NaN (No es un número), un valor especial que es parte de la especificación de punto flotante IEEE.</p>
<p>Ninguno de estos enfoques está exento de desventajas: el uso de una matriz de máscaras independiente requiere la asignación de una matriz booleana adicional, lo que agrega sobrecarga tanto en almacenamiento como en computación. Un valor centinela reduce el rango de valores válidos que se pueden representar y puede requerir lógica adicional (a menudo no optimizada) en la aritmética de CPU y GPU. Los valores especiales comunes como NaN no están disponibles para todos los tipos de datos.</p>
<p>Como en la mayoría de los casos en los que no existe una opción universalmente óptima, los distintos idiomas y sistemas utilizan convenciones diferentes. Por ejemplo, el lenguaje R utiliza patrones de bits reservados dentro de cada tipo de datos como valores centinela que indican datos faltantes, mientras que el sistema SciDB utiliza un byte adicional adjunto a cada celda que indica un estado NA.</p>
</section>
<section id="py-pandas-ndpandas" class="level3" data-number="7.5.2">
                    <h3 data-number="7.5.2" class="anchored" data-anchor-id="py-pandas-ndpandas"><span 
                            class="header-section-number">7.5.2 </span> Datos faltantes en Pandas</h3>
<p>La forma en que Pandas maneja los valores faltantes está limitada por su dependencia del paquete NumPy, que no tiene una noción incorporada de valores NA para tipos de datos que no sean de punto flotante.</p>
<p>Pandas podría haber seguido el ejemplo de R y especificar patrones de bits para cada tipo de datos individual para indicar la nulidad, pero este enfoque resulta bastante complicado de manejar. Si bien R contiene cuatro tipos de datos básicos, NumPy admite <em>mucho</em> más que esto: por ejemplo, mientras que R tiene un solo tipo de entero, NumPy admite <em>catorce</em> tipos de enteros básicos una vez que se tienen en cuenta las precisiones disponibles, el signo y el endianismo de la codificación. Reservar un patrón de bits específico en todos los tipos NumPy disponibles generaría una cantidad de sobrecarga inmanejable en la conversión especial de varias operaciones en casos especiales para varios tipos, lo que probablemente requeriría incluso una nueva bifurcación del paquete NumPy. Además, para los tipos de datos más pequeños (como los números enteros de 8 bits), sacrificar un bit para usarlo como máscara reducirá significativamente el rango de valores que puede representar.</p>
<p>NumPy tiene soporte para matrices enmascaradas, es decir, matrices que tienen una matriz de máscara booleana separada adjunta para marcar datos como “buenos” o “malos”. Pandas podría haber derivado de esto, pero la sobrecarga en almacenamiento, computación y mantenimiento del código hace que sea una opción poco atractiva.</p>
<p>Con estas restricciones en mente, Pandas eligió usar centinelas para los datos faltantes y además eligió usar dos valores nulos de Python ya existentes: el valor especial de punto flotante <code>NaN</code> y el objeto <code>None</code> de Python. Esta elección tiene algunos efectos secundarios, como veremos, pero en la práctica acaba siendo un buen compromiso en la mayoría de los casos de interés.</p>
<section id="ninguno-datos-faltantes-en-python" class="level4">
<h4 class="anchored" data-anchor-id="ninguno-datos-faltantes-en-python"><code>Ninguno</code>: datos faltantes en Python</h4>
<p>El primer valor centinela utilizado por Pandas es “Ninguno”, un objeto singleton de Python que a menudo se utiliza para datos faltantes en el código Python. Debido a que es un objeto Python, <code>None</code> no se puede usar en ninguna matriz NumPy/Pandas arbitraria, sino solo en matrices con tipo de datos <code>'object'</code> (es decir, matrices de objetos Python):</p>
<div id="d5b08b58" class="cell">
<div class="sourceCode cell-code" id="cb81"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="43a0820d" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb82"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a>vals1 <span class="op">=</span> np.array([<span class="dv">1</span>, <span class="va">None</span>, <span class="dv">3</span>, <span class="dv">4</span>])</span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>vals1</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Este <code>dtype=object</code> significa que la mejor representación de tipo común que NumPy podría inferir para el contenido de la matriz es que son objetos de Python. Si bien este tipo de matriz de objetos es útil para algunos propósitos, cualquier operación sobre los datos se realizará a nivel de Python, con mucha más sobrecarga que las operaciones típicamente rápidas que se ven para matrices con tipos nativos:</p>
<div id="872afb49" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb83"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> dtype <span class="kw">in</span> [<span class="st">'object'</span>, <span class="st">'int'</span>]:</span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"dtype ="</span>, dtype)</span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">%</span>timeit np.arange(<span class="fl">1E6</span>, dtype<span class="op">=</span>dtype).<span class="bu">sum</span>()</span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>El uso de objetos Python en una matriz también significa que si realiza agregaciones como <code>sum()</code> o <code>min()</code> en una matriz con un valor <code>None</code>, generalmente obtendrá un error:</p>
<div id="8a001b46" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}" data-scrolled="true">
<div class="sourceCode cell-code" id="cb84"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="co">#vals1.sum()</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Esto refleja el hecho de que la suma entre un entero y “Ninguno” no está definida.</p>
</section>
<section id="nan-faltan-datos-numéricos" class="level4">
<h4 class="anchored" data-anchor-id="nan-faltan-datos-numéricos"><code>NaN</code>: Faltan datos numéricos</h4>
<p>La otra representación de datos faltantes, «NaN» (acrónimo de <em>Not a Number</em>), es diferente; es un valor de punto flotante especial reconocido por todos los sistemas que utilizan la representación de punto flotante IEEE estándar:</p>
<div id="a24d3966" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb85"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a>vals2 <span class="op">=</span> np.array([<span class="dv">1</span>, np.nan, <span class="dv">3</span>, <span class="dv">4</span>]) </span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a>vals2.dtype</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Tenga en cuenta que NumPy eligió un tipo de punto flotante nativo para esta matriz: esto significa que, a diferencia de la matriz de objetos anterior, esta matriz admite operaciones rápidas introducidas en el código compilado. Debes tener en cuenta que «NaN» es un poco como un virus de datos: infecta cualquier otro objeto que toque. Independientemente de la operación, el resultado de la aritmética con <code>NaN</code> será otro <code>NaN</code>:</p>
<div id="b24fb1b1" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb86"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> <span class="op">+</span> np.nan</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="2349295f" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb87"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="dv">0</span> <span class="op">*</span>  np.nan</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Tenga en cuenta que esto significa que los agregados sobre los valores están bien definidos (es decir, no generan un error), pero no siempre son útiles:</p>
<div id="ebaa567b" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb88"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a>vals2.<span class="bu">sum</span>(), vals2.<span class="bu">min</span>(), vals2.<span class="bu">max</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>NumPy proporciona algunas agregaciones especiales que ignorarán estos valores faltantes:</p>
<div id="0de9ceba" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb89"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a>np.nansum(vals2), np.nanmin(vals2), np.nanmax(vals2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Tenga en cuenta que “NaN” es específicamente un valor de punto flotante; no existe un valor NaN equivalente para números enteros, cadenas u otros tipos.</p>
</section>
<section id="nan-y-none-en-pandas" class="level4">
<h4 class="anchored" data-anchor-id="nan-y-none-en-pandas">NaN y None en Pandas</h4>
<p>Tanto “NaN” como “None” tienen su lugar, y Pandas está diseñado para manejar ambos de manera casi intercambiable, convirtiendo entre ellos cuando es apropiado:</p>
<div id="efcd25f7" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb90"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a>pd.Series([<span class="dv">1</span>, np.nan, <span class="dv">2</span>, <span class="va">None</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Para los tipos que no tienen un valor centinela disponible, Pandas realiza una conversión de tipo automática cuando hay valores NA presentes. Por ejemplo, si establecemos un valor en una matriz de enteros en <code>np.nan</code>, se convertirá automáticamente a un tipo de punto flotante para acomodar el NA:</p>
<div id="a6fedfdf" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb91"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> pd.Series(<span class="bu">range</span>(<span class="dv">2</span>), dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a>x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="031f485f" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb92"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a>x[<span class="dv">0</span>] <span class="op">=</span> <span class="va">None</span></span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a>x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Tenga en cuenta que, además de convertir la matriz de enteros a punto flotante, Pandas convierte automáticamente “Ninguno” en un valor “NaN”. (Tenga en cuenta que existe una propuesta para agregar un entero nativo NA a Pandas en el futuro; al momento de escribir este artículo, no se ha incluido).</p>
<p>Si bien este tipo de magia puede parecer un poco chapucera en comparación con el enfoque más unificado de los valores de NA en lenguajes de dominio específico como R, el enfoque de centinela/conversión de Pandas funciona bastante bien en la práctica y, en mi experiencia, rara vez causa problemas.</p>
<p>La siguiente tabla enumera las convenciones de conversión ascendente en Pandas cuando se introducen valores NA:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Clase de tipo</th>
<th>Conversión al almacenar NA</th>
<th>Valor centinela de NA</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>float</code></td>
<td>Sin cambios</td>
<td><code>np.nan</code></td>
</tr>
<tr class="even">
<td><code>object</code></td>
<td>Sin cambios</td>
<td><code>None</code> o <code>np.nan</code></td>
</tr>
<tr class="odd">
<td><code>integer</code></td>
<td>Convertir a <code>float64</code></td>
<td><code>np.nan</code></td>
</tr>
<tr class="even">
<td><code>boolean</code></td>
<td>Convertir a <code>object</code></td>
<td><code>None</code> o <code>np.nan</code></td>
</tr>
</tbody>
</table>
<p>Tenga en cuenta que en Pandas, los datos de cadena siempre se almacenan con un tipo de datos “objeto”.</p>
</section>
</section>
<section id="py-pandas-ndoper" class="level3" data-number="7.5.3">
                    <h3 data-number="7.5.3" class="anchored" data-anchor-id="py-pandas-ndoper"><span 
                            class="header-section-number">7.5.3 </span> Operando con valores nulos</h3>
<p>Como hemos visto, Pandas trata a <code>None</code> y <code>NaN</code> como esencialmente intercambiables para indicar valores faltantes o nulos. Para facilitar esta convención, existen varios métodos útiles para detectar, eliminar y reemplazar valores nulos en las estructuras de datos de Pandas. Ellos son:</p>
<ul>
<li><code>isnull()</code>: Genera una máscara booleana que indica los valores faltantes</li>
<li><code>notnull()</code>: Opuesto de <code>isnull()</code></li>
<li><code>dropna()</code>: Devuelve una versión filtrada de los datos</li>
<li><code>fillna()</code>: Devuelve una copia de los datos con los valores faltantes completados o imputados</li>
</ul>
<p>Concluiremos esta sección con una breve exploración y demostración de estas rutinas.</p>
<section id="detección-de-valores-nulos" class="level4">
<h4 class="anchored" data-anchor-id="detección-de-valores-nulos">Detección de valores nulos</h4>
<p>Las estructuras de datos de Pandas tienen dos métodos útiles para detectar datos nulos: <code>isnull()</code> y <code>notnull()</code>. Cualquiera de ellos devolverá una máscara booleana sobre los datos. Por ejemplo:</p>
<div id="4016aec3" class="cell">
<div class="sourceCode cell-code" id="cb93"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> pd.Series([<span class="dv">1</span>, np.nan, <span class="st">'hello'</span>, <span class="va">None</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="2e519587" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb94"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a>data.isnull()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Como se menciona en <a href="03.02-Data-Indexing-and-Selection.ipynb">Data Indexing and Selection</a>, las máscaras booleanas se pueden usar directamente como un índice <code>Series</code> o <code>DataFrame</code>:</p>
<div id="7573a76a" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb95"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a>data[data.notnull()]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Los métodos <code>isnull()</code> y <code>notnull()</code> producen resultados booleanos similares para <code>DataFrame</code>.</p>
</section>
<section id="eliminación-de-valores-nulos" class="level4">
<h4 class="anchored" data-anchor-id="eliminación-de-valores-nulos">Eliminación de valores nulos</h4>
<p>Además del enmascaramiento utilizado anteriormente, existen los métodos de conveniencia, <code>dropna()</code> (que elimina los valores NA) y <code>fillna()</code> (que completa los valores NA). Para una <code>Serie</code>, El resultado es sencillo:</p>
<div id="5da5171b" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb96"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a>data.dropna()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Para un “DataFrame”, hay más opciones. Considere el siguiente «DataFrame»:</p>
<div id="ab319c87" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb97"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame([[<span class="dv">1</span>,      np.nan, <span class="dv">2</span>],</span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a>                   [<span class="dv">2</span>,      <span class="dv">3</span>,      <span class="dv">5</span>],</span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a>                   [np.nan, <span class="dv">4</span>,      <span class="dv">6</span>]])</span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a>df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>No podemos eliminar valores individuales de un <code>DataFrame</code>; solo podemos eliminar filas o columnas completas. Dependiendo de la aplicación, es posible que desees uno u otro, por lo que <code>dropna()</code> ofrece varias opciones para un <code>DataFrame</code>.</p>
<p>De forma predeterminada, <code>dropna()</code> eliminará todas las filas en las que <em>cualquier</em> valor nulo esté presente:</p>
<div id="13f831ed" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb98"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a>df.dropna()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Como alternativa, puede eliminar valores NA a lo largo de un eje diferente; <code>axis=1</code> elimina todas las columnas que contienen un valor nulo:</p>
<div id="7aedf653" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb99"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a>df.dropna(axis<span class="op">=</span><span class="st">'columns'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Pero esto también deja caer algunos datos útiles; es posible que prefieras dejar caer filas o columnas con <em>todos</em> los valores NA, o una mayoría de los valores NA. Esto se puede especificar a través de los parámetros <code>how</code> o <code>thresh</code>, que permiten un control preciso de la cantidad de nulos que se permiten.</p>
<p>El valor predeterminado es <code>how='any'</code>, de modo que cualquier fila o columna (dependiendo de la palabra clave <code>axis</code>) que contenga un valor nulo será descartada. También puede especificar <code>how='all'</code>, que solo eliminará filas/columnas que sean <em>todos</em> valores nulos:</p>
<div id="788582a7" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb100"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a>df[<span class="dv">3</span>] <span class="op">=</span> np.nan</span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a>df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="d888fa85" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb101"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a>df.dropna(axis<span class="op">=</span><span class="st">'columns'</span>, how<span class="op">=</span><span class="st">'all'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Para un control más detallado, el parámetro <code>thresh</code> le permite especificar un número mínimo de valores no nulos que se conservarán en la fila/columna:</p>
<div id="5d9d9edf" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb102"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a>df.dropna(axis<span class="op">=</span><span class="st">'rows'</span>, thresh<span class="op">=</span><span class="dv">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Aquí se han eliminado la primera y la última fila porque solo contienen dos valores no nulos.</p>
</section>
<section id="rellenar-valores-nulos" class="level4">
<h4 class="anchored" data-anchor-id="rellenar-valores-nulos">Rellenar valores nulos</h4>
<p>A veces, en lugar de eliminar los valores NA, es mejor reemplazarlos con un valor válido. Este valor podría ser un solo número como cero, o podría ser algún tipo de imputación o interpolación de los valores buenos. Puede hacer esto en el lugar usando el método <code>isnull()</code> como máscara, pero como es una operación tan común, Pandas proporciona el método <code>fillna()</code>, que devuelve una copia de la matriz con los valores nulos reemplazados.</p>
<p>Consideremos la siguiente «Serie»:</p>
<div id="9554a99e" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb103"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> pd.Series([<span class="dv">1</span>, np.nan, <span class="dv">2</span>, <span class="va">None</span>, <span class="dv">3</span>], index<span class="op">=</span><span class="bu">list</span>(<span class="st">'abcde'</span>))</span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a>data</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Podemos llenar las entradas de NA con un solo valor, como cero:</p>
<div id="d88a0e59" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb104"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a>data.fillna(<span class="dv">0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Podemos especificar un relleno hacia adelante para propagar el valor anterior hacia adelante:</p>
<div id="9f0ee2e7" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb105"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a><span class="co"># relleno hacia adelante</span></span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a>data.ffill()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>O podemos especificar un relleno para propagar los siguientes valores hacia atrás:</p>
<div id="44e9cd61" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb106"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a><span class="co"># relleno</span></span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a>data.bfill()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Para los “DataFrame”, las opciones son similares, pero también podemos especificar un “eje” a lo largo del cual se realizan los rellenos:</p>
<div id="077073aa" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb107"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a>df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="b5aefdba" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb108"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a>df.ffill(axis<span class="op">=</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Tenga en cuenta que si un valor anterior no está disponible durante un relleno hacia adelante, el valor NA permanece.</p>
</section>
</section>
</section>

<!-- 7.6 -->
<section id="py-pandas-conanex" class="level2" data-number="7.6">
                <h2 data-number="7.6" class="anchored" data-anchor-id="py-pandas-conanex"><span
                        class="header-section-number">7.6</span> Combinación de conjuntos de datos: concatenación y anexión</h2>
<p>Algunos de los estudios de datos más interesantes surgen de la combinación de diferentes fuentes de datos. Estas operaciones pueden implicar cualquier cosa, desde una concatenación muy sencilla de dos conjuntos de datos diferentes hasta uniones y fusiones de estilo de base de datos más complicadas que manejan correctamente cualquier superposición entre los conjuntos de datos. Las «Series» y «DataFrame» se construyen con este tipo de operación en mente, y Pandas incluye funciones y métodos que hacen que este tipo de manejo de datos sea rápido y sencillo.</p>
<p>Aquí veremos la concatenación simple de <code>Series</code> y <code>DataFrame</code> con la función <code>pd.concat</code>; más adelante profundizaremos en fusiones y uniones en memoria más sofisticadas implementadas en Pandas.</p>
<p>Comenzamos con las importaciones estándar:</p>
<div id="b0d31bdd" class="cell">
<div class="sourceCode cell-code" id="cb109"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Para mayor comodidad, definiremos esta función que crea un <code>DataFrame</code> de un formato particular que será útil a continuación:</p>
<div id="b7397877" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb110"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> make_df(cols, ind):</span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Quickly make a DataFrame"""</span></span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> {c: [<span class="bu">str</span>(c) <span class="op">+</span> <span class="bu">str</span>(i) <span class="cf">for</span> i <span class="kw">in</span> ind]</span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> c <span class="kw">in</span> cols}</span>
<span id="cb110-5"><a href="#cb110-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pd.DataFrame(data, ind)</span>
<span id="cb110-6"><a href="#cb110-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-7"><a href="#cb110-7" aria-hidden="true" tabindex="-1"></a><span class="co"># ejemplo DataFrame</span></span>
<span id="cb110-8"><a href="#cb110-8" aria-hidden="true" tabindex="-1"></a>make_df(<span class="st">'ABC'</span>, <span class="bu">range</span>(<span class="dv">3</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Además, crearemos una clase rápida que nos permita mostrar varios <code>DataFrame</code> uno al lado del otro. El código hace uso del método especial <code>_repr_html_</code>, que IPython utiliza para implementar su visualización de objetos enriquecidos:</p>
<div id="56ce7350" class="cell">
<div class="sourceCode cell-code" id="cb111"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> display(<span class="bu">object</span>):</span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Display HTML representation of multiple objects"""</span></span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a>    template <span class="op">=</span> <span class="st">"""&lt;div style="float: left; padding: 10px;"&gt;</span></span>
<span id="cb111-4"><a href="#cb111-4" aria-hidden="true" tabindex="-1"></a><span class="st">    &lt;p style='font-family:"Courier New", Courier, monospace'&gt;</span><span class="sc">{0}</span><span class="st">&lt;/p&gt;</span><span class="sc">{1}</span></span>
<span id="cb111-5"><a href="#cb111-5" aria-hidden="true" tabindex="-1"></a><span class="st">    &lt;/div&gt;"""</span></span>
<span id="cb111-6"><a href="#cb111-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, <span class="op">*</span>args):</span>
<span id="cb111-7"><a href="#cb111-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.args <span class="op">=</span> args</span>
<span id="cb111-8"><a href="#cb111-8" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb111-9"><a href="#cb111-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _repr_html_(<span class="va">self</span>):</span>
<span id="cb111-10"><a href="#cb111-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">'</span><span class="ch">\n</span><span class="st">'</span>.join(<span class="va">self</span>.template.<span class="bu">format</span>(a, <span class="bu">eval</span>(a)._repr_html_())</span>
<span id="cb111-11"><a href="#cb111-11" aria-hidden="true" tabindex="-1"></a>                         <span class="cf">for</span> a <span class="kw">in</span> <span class="va">self</span>.args)</span>
<span id="cb111-12"><a href="#cb111-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb111-13"><a href="#cb111-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__repr__</span>(<span class="va">self</span>):</span>
<span id="cb111-14"><a href="#cb111-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">'</span><span class="ch">\n\n</span><span class="st">'</span>.join(a <span class="op">+</span> <span class="st">'</span><span class="ch">\n</span><span class="st">'</span> <span class="op">+</span> <span class="bu">repr</span>(<span class="bu">eval</span>(a))</span>
<span id="cb111-15"><a href="#cb111-15" aria-hidden="true" tabindex="-1"></a>                           <span class="cf">for</span> a <span class="kw">in</span> <span class="va">self</span>.args)</span>
<span id="cb111-16"><a href="#cb111-16" aria-hidden="true" tabindex="-1"></a>    </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>El uso de esto quedará más claro a medida que continuemos nuestra discusión en la siguiente sección.</p>
<section id="py-pandas-concat" class="level3" data-number="7.6.1">
                    <h3 data-number="7.6.1" class="anchored" data-anchor-id="py-pandas-concat"><span 
                            class="header-section-number">7.6.1 </span> Concatenación simple con <code>pd.concat</code></h3>
<p>Pandas tiene una función, <code>pd.concat()</code>, que tiene una sintaxis similar a <code>np.concatenate</code> pero contiene una serie de opciones que discutiremos en breve:</p>
<div class="sourceCode" id="cb112"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Signature in Pandas v0.18</span></span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a>pd.concat(objs, axis<span class="op">=</span><span class="dv">0</span>, join<span class="op">=</span><span class="st">'outer'</span>, join_axes<span class="op">=</span><span class="va">None</span>, ignore_index<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true" tabindex="-1"></a>          keys<span class="op">=</span><span class="va">None</span>, levels<span class="op">=</span><span class="va">None</span>, names<span class="op">=</span><span class="va">None</span>, verify_integrity<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb112-4"><a href="#cb112-4" aria-hidden="true" tabindex="-1"></a>          copy<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><code>pd.concat()</code> se puede utilizar para una concatenación simple de objetos <code>Series</code> o <code>DataFrame</code>, al igual que <code>np.concatenate()</code> se puede utilizar para concatenaciones simples de matrices:</p>
<div id="8d42f851" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb113"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a>ser1 <span class="op">=</span> pd.Series([<span class="st">'A'</span>, <span class="st">'B'</span>, <span class="st">'C'</span>], index<span class="op">=</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>])</span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a>ser2 <span class="op">=</span> pd.Series([<span class="st">'D'</span>, <span class="st">'E'</span>, <span class="st">'F'</span>], index<span class="op">=</span>[<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>])</span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a>pd.concat([ser1, ser2])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>También funciona para concatenar objetos de dimensiones superiores, como “DataFrame”:</p>
<div id="05ea7be2" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb114"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a>df1 <span class="op">=</span> make_df(<span class="st">'AB'</span>, [<span class="dv">1</span>, <span class="dv">2</span>])</span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a>df2 <span class="op">=</span> make_df(<span class="st">'AB'</span>, [<span class="dv">3</span>, <span class="dv">4</span>])</span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a>display(<span class="st">'df1'</span>, <span class="st">'df2'</span>, <span class="st">'pd.concat([df1, df2])'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>De forma predeterminada, la concatenación se realiza fila por fila dentro del «DataFrame» (es decir, «axis=0»). Al igual que <code>np.concatenate</code>, <code>pd.concat</code> permite la especificación de un eje a lo largo del cual se llevará a cabo la concatenación. Consideremos el siguiente ejemplo:</p>
<div id="17337637" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb115"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a>df3 <span class="op">=</span> make_df(<span class="st">'AB'</span>, [<span class="dv">0</span>, <span class="dv">1</span>])</span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a>df4 <span class="op">=</span> make_df(<span class="st">'CD'</span>, [<span class="dv">0</span>, <span class="dv">1</span>])</span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a>display(<span class="st">'df3'</span>, <span class="st">'df4'</span>, <span class="st">"pd.concat([df3, df4], axis=1)"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Podríamos haber especificado de manera equivalente <code>axis=1</code>; aquí hemos utilizado el más intuitivo <code>axis='col'</code>.</p>
<section id="indices-duplicados" class="level4">
<h4 class="anchored" data-anchor-id="indices-duplicados">Indices duplicados</h4>
<p>Una diferencia importante entre <code>np.concatenate</code> y <code>pd.concat</code> es que la concatenación de Pandas <em>preserva los Indices</em>, ¡incluso si el resultado tendrá Indices duplicados! Consideremos este sencillo ejemplo:</p>
<div id="abf6aea1" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb116"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> make_df(<span class="st">'AB'</span>, [<span class="dv">0</span>, <span class="dv">1</span>])</span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> make_df(<span class="st">'AB'</span>, [<span class="dv">2</span>, <span class="dv">3</span>])</span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a>y.index <span class="op">=</span> x.index  <span class="co"># ¡Crea Indices duplicados!</span></span>
<span id="cb116-4"><a href="#cb116-4" aria-hidden="true" tabindex="-1"></a>display(<span class="st">'x'</span>, <span class="st">'y'</span>, <span class="st">'pd.concat([x, y])'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Observe los Indices repetidos en el resultado. Si bien esto es válido dentro de los “DataFrame”, el resultado suele ser indeseable. <code>pd.concat()</code> nos da algunas formas de manejarlo.</p>
</section>
<section id="detectar-las-repeticiones-como-un-error" class="level4">
<h4 class="anchored" data-anchor-id="detectar-las-repeticiones-como-un-error">Detectar las repeticiones como un error</h4>
<p>Si desea simplemente verificar que los Indices en el resultado de <code>pd.concat()</code> no se superpongan, puede especificar el indicador <code>verify_integrity</code>. Si se establece en Verdadero, la concatenación generará una excepción si hay Indices duplicados. A continuación se muestra un ejemplo en el que, para mayor claridad, capturaremos e imprimiremos el mensaje de error:</p>
<div id="39dacc7a" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb117"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a>    pd.concat([x, y], verify_integrity<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb117-3"><a href="#cb117-3" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> <span class="pp">ValueError</span> <span class="im">as</span> e:</span>
<span id="cb117-4"><a href="#cb117-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"ValueError:"</span>, e)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="ignorando-el-índice" class="level4">
<h4 class="anchored" data-anchor-id="ignorando-el-índice">Ignorando el índice</h4>
<p>A veces, el índice en sí no importa y preferirías simplemente ignorarlo. Esta opción se puede especificar utilizando el indicador <code>ignore_index</code>. Si se establece como verdadero, la concatenación creará un nuevo índice entero para la «Serie» resultante:</p>
<div id="d1ae7d77" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb118"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a>display(<span class="st">'x'</span>, <span class="st">'y'</span>, <span class="st">'pd.concat([x, y], ignore_index=True)'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="py-pandas-join" class="level3" data-number="7.6.2">
                    <h3 data-number="7.6.2" class="anchored" data-anchor-id="py-pandas-join"><span 
                            class="header-section-number">7.6.2 </span> Concatenación con uniones</h3>
<p>En los ejemplos simples que acabamos de ver, estábamos principalmente concatenando <code>DataFrame</code> con nombres de columnas compartidos. En la práctica, los datos de diferentes fuentes pueden tener diferentes conjuntos de nombres de columnas, y <code>pd.concat</code> ofrece varias opciones en este caso. Considere la concatenación de los siguientes dos “DataFrame”, que tienen algunas (¡pero no todas!) columnas en común:</p>
<div id="7354d975" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb119"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a>df5 <span class="op">=</span> make_df(<span class="st">'ABC'</span>, [<span class="dv">1</span>, <span class="dv">2</span>])</span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a>df6 <span class="op">=</span> make_df(<span class="st">'BCD'</span>, [<span class="dv">3</span>, <span class="dv">4</span>])</span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true" tabindex="-1"></a>display(<span class="st">'df5'</span>, <span class="st">'df6'</span>, <span class="st">'pd.concat([df5, df6])'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>De forma predeterminada, las entradas para las que no hay datos disponibles se rellenan con valores NA. Para cambiar esto, podemos especificar una de varias opciones para los parámetros <code>join</code> y <code>join_axes</code> de la función concatenar. De forma predeterminada, la unión es una unión de las columnas de entrada (<code>join='outer'</code>), pero podemos cambiar esto a una intersección de las columnas usando <code>join='inner'</code>:</p>
<div id="eeb30230" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb120"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a>display(<span class="st">'df5'</span>, <span class="st">'df6'</span>,</span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a>        <span class="st">"pd.concat([df5, df6], join='inner')"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="6bca9bbf" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb121"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a>display(<span class="st">'df1'</span>, <span class="st">'df2'</span>, <span class="st">'df1.append(df2)'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Tenga en cuenta que, a diferencia de los métodos <code>append()</code> y <code>extend()</code> de las listas de Python, el método <code>append()</code> en Pandas no modifica el objeto original; en cambio, crea un nuevo objeto con los datos combinados. Tampoco es un método muy eficiente, porque implica la creación de un nuevo índice <em>y</em> un buffer de datos. Por lo tanto, si planea realizar múltiples operaciones de <code>append</code>, generalmente es mejor construir una lista de <code>DataFrame</code> y pasarlos todos a la vez a la función <code>concat()</code>.</p>
<p>En la siguiente sección, veremos otro enfoque más poderoso para combinar datos de múltiples fuentes, las fusiones/uniones de estilo base de datos implementadas en <code>pd.merge</code>. Para obtener más información sobre <code>concat()</code>, <code>append()</code> y funcionalidades relacionadas, consulte <a href="http://pandas.pydata.org/pandas-docs/stable/merging.html">“Merge, Join, and Concatenate” section</a> de la documentación de Pandas.</p>
</section>
</section>

<!-- 7.7 -->
<section id="py-pandas-fusun" class="level2" data-number="7.7">
                <h2 data-number="7.7" class="anchored" data-anchor-id="py-pandas-fusun"><span
                        class="header-section-number">7.7</span> Combinación de conjuntos de datos: fusionar y unir</h2>
<p>Una característica esencial que ofrece Pandas son sus operaciones de unión y fusión en memoria de alto rendimiento. Si alguna vez ha trabajado con bases de datos, debería estar familiarizado con este tipo de interacción de datos. La interfaz principal para esto es la función <code>pd.merge</code>, y veremos algunos ejemplos de cómo puede funcionar en la práctica.</p>
<p>Para mayor comodidad, comenzaremos redefiniendo la funcionalidad <code>display()</code> de la sección anterior:</p>
<div id="9c3f779a" class="cell">
<div class="sourceCode cell-code" id="cb122"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-4"><a href="#cb122-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> display(<span class="bu">object</span>):</span>
<span id="cb122-5"><a href="#cb122-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Display HTML representation of multiple objects"""</span></span>
<span id="cb122-6"><a href="#cb122-6" aria-hidden="true" tabindex="-1"></a>    template <span class="op">=</span> <span class="st">"""&lt;div style="float: left; padding: 10px;"&gt;</span></span>
<span id="cb122-7"><a href="#cb122-7" aria-hidden="true" tabindex="-1"></a><span class="st">    &lt;p style='font-family:"Courier New", Courier, monospace'&gt;</span><span class="sc">{0}</span><span class="st">&lt;/p&gt;</span><span class="sc">{1}</span></span>
<span id="cb122-8"><a href="#cb122-8" aria-hidden="true" tabindex="-1"></a><span class="st">    &lt;/div&gt;"""</span></span>
<span id="cb122-9"><a href="#cb122-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, <span class="op">*</span>args):</span>
<span id="cb122-10"><a href="#cb122-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.args <span class="op">=</span> args</span>
<span id="cb122-11"><a href="#cb122-11" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb122-12"><a href="#cb122-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _repr_html_(<span class="va">self</span>):</span>
<span id="cb122-13"><a href="#cb122-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">'</span><span class="ch">\n</span><span class="st">'</span>.join(<span class="va">self</span>.template.<span class="bu">format</span>(a, <span class="bu">eval</span>(a)._repr_html_())</span>
<span id="cb122-14"><a href="#cb122-14" aria-hidden="true" tabindex="-1"></a>                         <span class="cf">for</span> a <span class="kw">in</span> <span class="va">self</span>.args)</span>
<span id="cb122-15"><a href="#cb122-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb122-16"><a href="#cb122-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__repr__</span>(<span class="va">self</span>):</span>
<span id="cb122-17"><a href="#cb122-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">'</span><span class="ch">\n\n</span><span class="st">'</span>.join(a <span class="op">+</span> <span class="st">'</span><span class="ch">\n</span><span class="st">'</span> <span class="op">+</span> <span class="bu">repr</span>(<span class="bu">eval</span>(a))</span>
<span id="cb122-18"><a href="#cb122-18" aria-hidden="true" tabindex="-1"></a>                           <span class="cf">for</span> a <span class="kw">in</span> <span class="va">self</span>.args)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="py-pandas-algrel" class="level3" data-number="7.7.1">
                    <h3 data-number="7.7.1" class="anchored" data-anchor-id="py-pandas-algrel"><span 
                            class="header-section-number">7.7.1 </span> Algebra relacional</h3>
<p>El comportamiento implementado en <code>pd.merge()</code> es un subconjunto de lo que se conoce como <em>álgebra relacional</em>, que es un conjunto formal de reglas para manipular datos relacionales y forma la base conceptual de las operaciones disponibles en la mayoría de las bases de datos. La fortaleza del enfoque del álgebra relacional es que propone varias operaciones primitivas, que se convierten en los componentes básicos de operaciones más complicadas en cualquier conjunto de datos. Con este léxico de operaciones fundamentales implementado eficientemente en una base de datos u otro programa, se pueden realizar una amplia gama de operaciones compuestas bastante complicadas.</p>
<p>Pandas implementa varios de estos bloques de construcción fundamentales en la función <code>pd.merge()</code> y el método <code>join()</code> relacionado de <code>Series</code> y <code>Dataframe</code>. Como veremos, estos le permiten vincular de manera eficiente datos de diferentes fuentes.</p>
</section>
<section id="py-pandas-uncat" class="level3" data-number="7.7.2">
                    <h3 data-number="7.7.2" class="anchored" data-anchor-id="py-pandas-uncat"><span 
                            class="header-section-number">7.7.2 </span> Categorías de uniones</h3>
<p>La función <code>pd.merge()</code> implementa varios tipos de uniones: uniones <em>uno a uno</em>, <em>muchos a uno</em> y <em>muchos a muchos</em>. Se accede a los tres tipos de uniones mediante una llamada idéntica a la interfaz <code>pd.merge()</code>; el tipo de unión realizada depende de la forma de los datos de entrada. Aquí mostraremos ejemplos simples de los tres tipos de fusiones y analizaremos opciones detalladas más adelante.</p>
<section id="uniones-uno-a-uno" class="level4">
<h4 class="anchored" data-anchor-id="uniones-uno-a-uno">Uniones uno a uno</h4>
<p>Quizás el tipo más simple de expresión de fusión es la unión uno a uno, que en muchos sentidos es muy similar a la concatenación por columnas. Como ejemplo concreto, considere los siguientes dos «DataFrames» que contienen información sobre varios empleados de una empresa:</p>
<div id="4ef5c599" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb123"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a>df1 <span class="op">=</span> pd.DataFrame({<span class="st">'employee'</span>: [<span class="st">'Bob'</span>, <span class="st">'Jake'</span>, <span class="st">'Lisa'</span>, <span class="st">'Sue'</span>],</span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a>                    <span class="st">'group'</span>: [<span class="st">'Accounting'</span>, <span class="st">'Engineering'</span>, <span class="st">'Engineering'</span>, <span class="st">'HR'</span>]})</span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a>df2 <span class="op">=</span> pd.DataFrame({<span class="st">'employee'</span>: [<span class="st">'Lisa'</span>, <span class="st">'Bob'</span>, <span class="st">'Jake'</span>, <span class="st">'Sue'</span>],</span>
<span id="cb123-4"><a href="#cb123-4" aria-hidden="true" tabindex="-1"></a>                    <span class="st">'hire_date'</span>: [<span class="dv">2004</span>, <span class="dv">2008</span>, <span class="dv">2012</span>, <span class="dv">2014</span>]})</span>
<span id="cb123-5"><a href="#cb123-5" aria-hidden="true" tabindex="-1"></a>display(<span class="st">'df1'</span>, <span class="st">'df2'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Para combinar esta información en un único <code>DataFrame</code>, podemos utilizar la función <code>pd.merge()</code>:</p>
<div id="b0b101a5" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb124"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a>df3 <span class="op">=</span> pd.merge(df1, df2)</span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true" tabindex="-1"></a>df3</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>La función <code>pd.merge()</code> reconoce que cada <code>DataFrame</code> tiene una columna “empleado” y se une automáticamente utilizando esta columna como clave. El resultado de la fusión es un nuevo «DataFrame» que combina la información de las dos entradas. Tenga en cuenta que el orden de las entradas en cada columna no se mantiene necesariamente: en este caso, el orden de la columna “empleado” difiere entre <code>df1</code> y <code>df2</code>, y la función <code>pd.merge()</code> lo tiene en cuenta correctamente. Además, tenga en cuenta que la fusión en general descarta el índice, excepto en el caso especial de fusiones por índice (consulte las palabras clave <code>left_index</code> y <code>right_index</code>, que se analizan en breve).</p>
</section>
<section id="uniones-de-varios-a-uno" class="level4">
<h4 class="anchored" data-anchor-id="uniones-de-varios-a-uno">Uniones de varios a uno</h4>
<p>Las uniones de varios a uno son uniones en las que una de las dos columnas clave contiene entradas duplicadas. En el caso de muchos a uno, el <code>DataFrame</code> resultante conservará esas entradas duplicadas según corresponda. Considere el siguiente ejemplo de una unión de varios a uno:</p>
<div id="a541b50f" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb125"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a>df4 <span class="op">=</span> pd.DataFrame({<span class="st">'group'</span>: [<span class="st">'Accounting'</span>, <span class="st">'Engineering'</span>, <span class="st">'HR'</span>],</span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true" tabindex="-1"></a>                    <span class="st">'supervisor'</span>: [<span class="st">'Carly'</span>, <span class="st">'Guido'</span>, <span class="st">'Steve'</span>]})</span>
<span id="cb125-3"><a href="#cb125-3" aria-hidden="true" tabindex="-1"></a>display(<span class="st">'df3'</span>, <span class="st">'df4'</span>, <span class="st">'pd.merge(df3, df4)'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>El <code>DataFrame</code> resultante tiene una columna adicional con la información del “supervisor”, donde la información se repite en una o más ubicaciones según lo requieran las entradas.</p>
</section>
<section id="uniones-de-muchos-a-muchos" class="level4">
<h4 class="anchored" data-anchor-id="uniones-de-muchos-a-muchos">Uniones de muchos a muchos</h4>
<p>Las uniones de muchos a muchos son un poco confusas conceptualmente, pero sin embargo están bien definidas. Si la columna clave tanto en la matriz izquierda como en la derecha contiene duplicados, el resultado es una fusión de muchos a muchos. Quizás esto quede más claro con un ejemplo concreto. Consideremos lo siguiente, donde tenemos un “DataFrame” que muestra una o más habilidades asociadas con un grupo en particular. Al realizar una unión de varios a varios, podemos recuperar las habilidades asociadas con cualquier persona individual:</p>
<div id="e72a7334" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb126"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a>df5 <span class="op">=</span> pd.DataFrame({<span class="st">'group'</span>: [<span class="st">'Accounting'</span>, <span class="st">'Accounting'</span>,</span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true" tabindex="-1"></a>                              <span class="st">'Engineering'</span>, <span class="st">'Engineering'</span>, <span class="st">'HR'</span>, <span class="st">'HR'</span>],</span>
<span id="cb126-3"><a href="#cb126-3" aria-hidden="true" tabindex="-1"></a>                    <span class="st">'skills'</span>: [<span class="st">'math'</span>, <span class="st">'spreadsheets'</span>, <span class="st">'coding'</span>, <span class="st">'linux'</span>,</span>
<span id="cb126-4"><a href="#cb126-4" aria-hidden="true" tabindex="-1"></a>                               <span class="st">'spreadsheets'</span>, <span class="st">'organization'</span>]})</span>
<span id="cb126-5"><a href="#cb126-5" aria-hidden="true" tabindex="-1"></a>display(<span class="st">'df1'</span>, <span class="st">'df5'</span>, <span class="st">"pd.merge(df1, df5)"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Estos tres tipos de uniones se pueden utilizar con otras herramientas Pandas para implementar una amplia gama de funcionalidades. Pero en la práctica, los conjuntos de datos rara vez son tan limpios como aquel con el que estamos trabajando aquí. En la siguiente sección, consideraremos algunas de las opciones proporcionadas por <code>pd.merge()</code> que le permiten ajustar el funcionamiento de las operaciones de unión.</p>
</section>
</section>
<section id="py-pandas-fuskey" class="level3" data-number="7.7.3">
                    <h3 data-number="7.7.3" class="anchored" data-anchor-id="py-pandas-fuskey"><span 
                            class="header-section-number">7.7.3 </span> Especificación de la clave de fusión</h3>
<p>Ya hemos visto el comportamiento predeterminado de <code>pd.merge()</code>: busca uno o más nombres de columna coincidentes entre las dos entradas y los usa como clave. Sin embargo, a menudo los nombres de las columnas no coinciden tan bien y <code>pd.merge()</code> proporciona una variedad de opciones para manejar esto.</p>
<section id="la-palabra-clave-on" class="level4">
<h4 class="anchored" data-anchor-id="la-palabra-clave-on">La palabra clave <code>on</code></h4>
<p>De forma más sencilla, puede especificar explícitamente el nombre de la columna clave utilizando la palabra clave <code>on</code>, que toma un nombre de columna o una lista de nombres de columnas:</p>
<div id="4b615899" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb127"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a>display(<span class="st">'df1'</span>, <span class="st">'df2'</span>, <span class="st">"pd.merge(df1, df2, on='employee')"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Esta opción solo funciona si tanto el DataFrame izquierdo como el derecho tienen el nombre de columna especificado.</p>
</section>
<section id="las-palabras-clave-left_on-y-right_on" class="level4">
<h4 class="anchored" data-anchor-id="las-palabras-clave-left_on-y-right_on">Las palabras clave <code>left_on</code> y <code>right_on</code></h4>
<p>A veces, es posible que desees fusionar dos conjuntos de datos con diferentes nombres de columna; por ejemplo, podemos tener un conjunto de datos en el que el nombre del empleado esté etiquetado como “nombre” en lugar de “empleado”. En este caso, podemos usar las palabras clave <code>left_on</code> y <code>right_on</code> para especificar los dos nombres de columna:</p>
<div id="a8f6d401" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb128"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a>df3 <span class="op">=</span> pd.DataFrame({<span class="st">'name'</span>: [<span class="st">'Bob'</span>, <span class="st">'Jake'</span>, <span class="st">'Lisa'</span>, <span class="st">'Sue'</span>],</span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true" tabindex="-1"></a>                    <span class="st">'salary'</span>: [<span class="dv">70000</span>, <span class="dv">80000</span>, <span class="dv">120000</span>, <span class="dv">90000</span>]})</span>
<span id="cb128-3"><a href="#cb128-3" aria-hidden="true" tabindex="-1"></a>display(<span class="st">'df1'</span>, <span class="st">'df3'</span>, <span class="st">'pd.merge(df1, df3, left_on="employee", right_on="name")'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>El resultado tiene una columna redundante que podemos eliminar si lo deseamos, por ejemplo, utilizando el método <code>drop()</code> de <code>DataFrame</code>:</p>
<div id="fadfc1c6" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb129"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a>pd.merge(df1, df3, left_on<span class="op">=</span><span class="st">"employee"</span>, right_on<span class="op">=</span><span class="st">"name"</span>).drop(<span class="st">'name'</span>, axis<span class="op">=</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="las-palabras-clave-left_index-y-right_index" class="level4">
<h4 class="anchored" data-anchor-id="las-palabras-clave-left_index-y-right_index">Las palabras clave <code>left_index</code> y <code>right_index</code></h4>
<p>A veces, en lugar de fusionar una columna, preferiría fusionar un índice. Por ejemplo, sus datos podrían verse así:</p>
<div id="3e1fbecd" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb130"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a>df1a <span class="op">=</span> df1.set_index(<span class="st">'employee'</span>)</span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a>df2a <span class="op">=</span> df2.set_index(<span class="st">'employee'</span>)</span>
<span id="cb130-3"><a href="#cb130-3" aria-hidden="true" tabindex="-1"></a>display(<span class="st">'df1a'</span>, <span class="st">'df2a'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Puede utilizar el índice como clave para la fusión especificando los indicadores <code>left_index</code> y/o <code>right_index</code> en <code>pd.merge()</code>:</p>
<div id="2d79d200" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb131"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a>display(<span class="st">'df1a'</span>, <span class="st">'df2a'</span>,</span>
<span id="cb131-2"><a href="#cb131-2" aria-hidden="true" tabindex="-1"></a>        <span class="st">"pd.merge(df1a, df2a, left_index=True, right_index=True)"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Para mayor comodidad, los <code>DataFrame</code> implementan el método <code>join()</code>, que realiza una fusión que, por defecto, une los Indices:</p>
<div id="0552086e" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb132"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a>display(<span class="st">'df1a'</span>, <span class="st">'df2a'</span>, <span class="st">'df1a.join(df2a)'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Si desea mezclar Indices y columnas, puede combinar <code>left_index</code> con <code>right_on</code> o <code>left_on</code> con <code>right_index</code> para obtener el comportamiento deseado:</p>
<div id="e7419358" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb133"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a>display(<span class="st">'df1a'</span>, <span class="st">'df3'</span>, <span class="st">"pd.merge(df1a, df3, left_index=True, right_on='name')"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Todas estas opciones también funcionan con múltiples Indices y/o múltiples columnas; la interfaz para este comportamiento es muy intuitiva. Para obtener más información sobre esto, consulte <a href="http://pandas.pydata.org/pandas-docs/stable/merging.html">“Merge, Join, and Concatenate” section</a> de la documentación de Pandas.</p>
</section>
</section>
<section id="py-pandas-arit" class="level3" data-number="7.7.4">
                    <h3 data-number="7.7.4" class="anchored" data-anchor-id="py-pandas-arit"><span 
                            class="header-section-number">7.7.4 </span>  Especificación de la aritmética de conjuntos para uniones</h3>
<p>En todos los ejemplos anteriores hemos pasado por alto una consideración importante a la hora de realizar una unión: el tipo de aritmética de conjuntos utilizada en la unión. Esto ocurre cuando un valor aparece en una columna clave pero no en la otra. Considere este ejemplo:</p>
<div id="447e7302" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb134"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a>df6 <span class="op">=</span> pd.DataFrame({<span class="st">'name'</span>: [<span class="st">'Peter'</span>, <span class="st">'Paul'</span>, <span class="st">'Mary'</span>],</span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true" tabindex="-1"></a>                    <span class="st">'food'</span>: [<span class="st">'fish'</span>, <span class="st">'beans'</span>, <span class="st">'bread'</span>]},</span>
<span id="cb134-3"><a href="#cb134-3" aria-hidden="true" tabindex="-1"></a>                   columns<span class="op">=</span>[<span class="st">'name'</span>, <span class="st">'food'</span>])</span>
<span id="cb134-4"><a href="#cb134-4" aria-hidden="true" tabindex="-1"></a>df7 <span class="op">=</span> pd.DataFrame({<span class="st">'name'</span>: [<span class="st">'Mary'</span>, <span class="st">'Joseph'</span>],</span>
<span id="cb134-5"><a href="#cb134-5" aria-hidden="true" tabindex="-1"></a>                    <span class="st">'drink'</span>: [<span class="st">'wine'</span>, <span class="st">'beer'</span>]},</span>
<span id="cb134-6"><a href="#cb134-6" aria-hidden="true" tabindex="-1"></a>                   columns<span class="op">=</span>[<span class="st">'name'</span>, <span class="st">'drink'</span>])</span>
<span id="cb134-7"><a href="#cb134-7" aria-hidden="true" tabindex="-1"></a>display(<span class="st">'df6'</span>, <span class="st">'df7'</span>, <span class="st">'pd.merge(df6, df7)'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Aquí hemos fusionado dos conjuntos de datos que sólo tienen una única entrada de “nombre” en común: Mary. De forma predeterminada, el resultado contiene la <em>intersección</em> de los dos conjuntos de entradas; esto es lo que se conoce como <em>unión interna</em>. Podemos especificar esto explícitamente usando la palabra clave <code>how</code>, cuyo valor predeterminado es <code>"inner"</code>:</p>
<div id="c3284a90" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb135"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a>pd.merge(df6, df7, how<span class="op">=</span><span class="st">'inner'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Otras opciones para la palabra clave <code>cómo</code> son <code>'exterior'</code>, <code>'izquierda'</code> y <code>'derecha'</code>. Una <em>unión externa</em> devuelve una unión sobre la unión de las columnas de entrada y completa todos los valores faltantes con NA:</p>
<div id="93ab1d7a" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb136"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a>display(<span class="st">'df6'</span>, <span class="st">'df7'</span>, <span class="st">"pd.merge(df6, df7, how='outer')"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Las uniones <em>izquierda</em> y <em>derecha</em> devuelven uniones sobre las entradas izquierdas y derechas, respectivamente. Por ejemplo:</p>
<div id="e1b40430" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb137"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a>display(<span class="st">'df6'</span>, <span class="st">'df7'</span>, <span class="st">"pd.merge(df6, df7, how='left')"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Las filas de salida ahora corresponden a las entradas en la entrada izquierda. <code>how='right'</code> funciona de manera similar.</p>
<p>Todas estas opciones se pueden aplicar directamente a cualquiera de los tipos de unión anteriores.</p>
</section>
<section id="py-pandas-suffixes" class="level3" data-number="7.7.5">
                    <h3 data-number="7.7.5" class="anchored" data-anchor-id="py-pandas-suffixes"><span 
                            class="header-section-number">7.7.5 </span> Nombres de columnas superpuestos: la palabra clave <code>suffixes</code></h3>
<p>Finalmente, puede terminar en un caso donde sus dos “DataFrame” de entrada tengan nombres de columna en conflicto. Considere este ejemplo:</p>
<div id="63b7a725" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb138"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true" tabindex="-1"></a>df8 <span class="op">=</span> pd.DataFrame({<span class="st">'name'</span>: [<span class="st">'Bob'</span>, <span class="st">'Jake'</span>, <span class="st">'Lisa'</span>, <span class="st">'Sue'</span>],</span>
<span id="cb138-2"><a href="#cb138-2" aria-hidden="true" tabindex="-1"></a>                    <span class="st">'rank'</span>: [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]})</span>
<span id="cb138-3"><a href="#cb138-3" aria-hidden="true" tabindex="-1"></a>df9 <span class="op">=</span> pd.DataFrame({<span class="st">'name'</span>: [<span class="st">'Bob'</span>, <span class="st">'Jake'</span>, <span class="st">'Lisa'</span>, <span class="st">'Sue'</span>],</span>
<span id="cb138-4"><a href="#cb138-4" aria-hidden="true" tabindex="-1"></a>                    <span class="st">'rank'</span>: [<span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">2</span>]})</span>
<span id="cb138-5"><a href="#cb138-5" aria-hidden="true" tabindex="-1"></a>display(<span class="st">'df8'</span>, <span class="st">'df9'</span>, <span class="st">'pd.merge(df8, df9, on="name")'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Debido a que la salida tendría dos nombres de columnas en conflicto, la función de combinación agrega automáticamente un sufijo <code>_x</code> o <code>_y</code> para que las columnas de salida sean únicas. Si estos valores predeterminados no son apropiados, es posible especificar un sufijo personalizado utilizando la palabra clave <code>suffixes</code>:</p>
<div id="aa83f2e6" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb139"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true" tabindex="-1"></a>display(<span class="st">'df8'</span>, <span class="st">'df9'</span>, <span class="st">'pd.merge(df8, df9, on="name", suffixes=["_L", "_R"])'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Estos sufijos funcionan en cualquiera de los patrones de unión posibles y también funcionan si hay varias columnas superpuestas.</p>
<p>Para obtener más información sobre estos patrones, consulte <a href="03.08-Aggregation-and-Grouping.ipynb">Aggregation and Grouping</a>, donde profundizamos un poco más en el álgebra relacional. Consulte también <a href="http://pandas.pydata.org/pandas-docs/stable/merging.html">Pandas “Merge, Join and Concatenate” documentation</a> para obtener más información sobre estos temas.</p>
</section>
<section id="py-pandas-exfus" class="level3" data-number="7.7.6">
                    <h3 data-number="7.7.6" class="anchored" data-anchor-id="py-pandas-exfus"><span 
                            class="header-section-number">7.7.6 </span> Ejemplo</h3>
<p>Las operaciones de fusión y unión surgen con mayor frecuencia cuando se combinan datos de diferentes fuentes. Aquí consideraremos un ejemplo de algunos datos sobre los estados de EE. UU. y sus poblaciones. Los archivos de datos se pueden encontrar en http://github.com/jakevdp/data-USstates/:</p>
<div id="89c426d5" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb140"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb140-1"><a href="#cb140-1" aria-hidden="true" tabindex="-1"></a><span class="co"># A continuación se muestran los comandos de shell para descargar los datos.</span></span>
<span id="cb140-2"><a href="#cb140-2" aria-hidden="true" tabindex="-1"></a><span class="op">!</span>curl <span class="op">-</span>O https:<span class="op">//</span>raw.githubusercontent.com<span class="op">/</span>jakevdp<span class="op">/</span>data<span class="op">-</span>USstates<span class="op">/</span>master<span class="op">/</span>state<span class="op">-</span>population.csv</span>
<span id="cb140-3"><a href="#cb140-3" aria-hidden="true" tabindex="-1"></a><span class="op">!</span>curl <span class="op">-</span>O https:<span class="op">//</span>raw.githubusercontent.com<span class="op">/</span>jakevdp<span class="op">/</span>data<span class="op">-</span>USstates<span class="op">/</span>master<span class="op">/</span>state<span class="op">-</span>areas.csv</span>
<span id="cb140-4"><a href="#cb140-4" aria-hidden="true" tabindex="-1"></a><span class="op">!</span>curl <span class="op">-</span>O https:<span class="op">//</span>raw.githubusercontent.com<span class="op">/</span>jakevdp<span class="op">/</span>data<span class="op">-</span>USstates<span class="op">/</span>master<span class="op">/</span>state<span class="op">-</span>abbrevs.csv</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Echemos un vistazo a los tres conjuntos de datos, utilizando la función <code>read_csv()</code> de Pandas:</p>
<div id="bcbed8ac" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb141"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a>pop <span class="op">=</span> pd.read_csv(<span class="st">'state-population.csv'</span>)</span>
<span id="cb141-2"><a href="#cb141-2" aria-hidden="true" tabindex="-1"></a>areas <span class="op">=</span> pd.read_csv(<span class="st">'state-areas.csv'</span>)</span>
<span id="cb141-3"><a href="#cb141-3" aria-hidden="true" tabindex="-1"></a>abbrevs <span class="op">=</span> pd.read_csv(<span class="st">'state-abbrevs.csv'</span>)</span>
<span id="cb141-4"><a href="#cb141-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-5"><a href="#cb141-5" aria-hidden="true" tabindex="-1"></a>display(<span class="st">'pop.head()'</span>, <span class="st">'areas.head()'</span>, <span class="st">'abbrevs.head()'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Dada esta información, digamos que queremos calcular un resultado relativamente sencillo: clasificar los estados y territorios de EE. UU. según su densidad de población en 2010. Claramente tenemos los datos aquí para encontrar este resultado, pero tendremos que combinar los conjuntos de datos para encontrar el resultado.</p>
<p>Comenzaremos con una fusión de muchos a uno que nos dará el nombre del estado completo dentro de la población “DataFrame”. Queremos fusionar en función de la columna “estado/región” de “pop” y la columna “abreviatura” de “abbrevs”. Usaremos <code>how='outer'</code> para asegurarnos de que no se desperdicien datos debido a etiquetas no coincidentes.</p>
<div id="91c0f159" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb142"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true" tabindex="-1"></a>merged <span class="op">=</span> pd.merge(pop, abbrevs, how<span class="op">=</span><span class="st">'outer'</span>,</span>
<span id="cb142-2"><a href="#cb142-2" aria-hidden="true" tabindex="-1"></a>                  left_on<span class="op">=</span><span class="st">'state/region'</span>, right_on<span class="op">=</span><span class="st">'abbreviation'</span>)</span>
<span id="cb142-3"><a href="#cb142-3" aria-hidden="true" tabindex="-1"></a>merged <span class="op">=</span> merged.drop(labels<span class="op">=</span><span class="st">'abbreviation'</span>, axis<span class="op">=</span><span class="dv">1</span>) <span class="co"># eliminar información duplicada</span></span>
<span id="cb142-4"><a href="#cb142-4" aria-hidden="true" tabindex="-1"></a>merged.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Verifiquemos nuevamente si hubo alguna discrepancia aquí, lo que podemos hacer buscando filas con valores nulos:</p>
<div id="b8210721" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb143"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true" tabindex="-1"></a>merged.isnull().<span class="bu">any</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Parte de la información de “población” es nula; ¡averigüemos cuáles son!</p>
<div id="2766e011" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb144"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a>merged[merged[<span class="st">'population'</span>].isnull()].head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Parece que todos los valores de población nula son de Puerto Rico antes del año 2000; esto probablemente se debe a que estos datos no están disponibles en la fuente original.</p>
<p>Más importante aún, vemos también que algunas de las nuevas entradas de <code>estado</code> también son nulas, lo que significa que no había una entrada correspondiente en la clave <code>abbrevs</code>. Veamos qué regiones carecen de esta coincidencia:</p>
<div id="8701fa13" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb145"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true" tabindex="-1"></a>merged.loc[merged[<span class="st">'state'</span>].isnull(), <span class="st">'state/region'</span>].unique()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Podemos inferir rápidamente el problema: nuestros datos de población incluyen entradas para Puerto Rico (PR) y Estados Unidos en su conjunto (USA), mientras que estas entradas no aparecen en la clave de abreviaturas de estados. Podemos solucionarlos rápidamente completando las entradas correspondientes:</p>
<div id="169013b4" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb146"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true" tabindex="-1"></a>merged.loc[merged[<span class="st">'state/region'</span>] <span class="op">==</span> <span class="st">'PR'</span>, <span class="st">'state'</span>] <span class="op">=</span> <span class="st">'Puerto Rico'</span></span>
<span id="cb146-2"><a href="#cb146-2" aria-hidden="true" tabindex="-1"></a>merged.loc[merged[<span class="st">'state/region'</span>] <span class="op">==</span> <span class="st">'USA'</span>, <span class="st">'state'</span>] <span class="op">=</span> <span class="st">'United States'</span></span>
<span id="cb146-3"><a href="#cb146-3" aria-hidden="true" tabindex="-1"></a>merged.isnull().<span class="bu">any</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>No más valores nulos en la columna <code>estado</code>: ¡estamos listos!</p>
<p>Ahora podemos fusionar el resultado con los datos del área utilizando un procedimiento similar. Al examinar nuestros resultados, querremos unirnos en la columna “estado” en ambos:</p>
<div id="2cf54805" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb147"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true" tabindex="-1"></a>final <span class="op">=</span> pd.merge(merged, areas, on<span class="op">=</span><span class="st">'state'</span>, how<span class="op">=</span><span class="st">'left'</span>)</span>
<span id="cb147-2"><a href="#cb147-2" aria-hidden="true" tabindex="-1"></a>final.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Nuevamente, verifiquemos si hay valores nulos para ver si hubo alguna discrepancia:</p>
<div id="aaf225a1" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb148"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb148-1"><a href="#cb148-1" aria-hidden="true" tabindex="-1"></a>final.isnull().<span class="bu">any</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Hay valores nulos en la columna <code>área</code>; podemos echar un vistazo para ver qué regiones se ignoraron aquí:</p>
<div id="c6a417c1" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb149"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb149-1"><a href="#cb149-1" aria-hidden="true" tabindex="-1"></a>final[<span class="st">'state'</span>][final[<span class="st">'area (sq. mi)'</span>].isnull()].unique()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Vemos que nuestro <code>DataFrame</code> de <code>áreas</code> no contiene el área de los Estados Unidos en su totalidad. Podríamos insertar el valor apropiado (usando la suma de todas las áreas estatales, por ejemplo), pero en este caso simplemente eliminaremos los valores nulos porque la densidad de población de todos los Estados Unidos no es relevante para nuestra discusión actual:</p>
<div id="c6f48d58" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb150"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb150-1"><a href="#cb150-1" aria-hidden="true" tabindex="-1"></a>final.dropna(inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb150-2"><a href="#cb150-2" aria-hidden="true" tabindex="-1"></a>final.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Ahora tenemos todos los datos que necesitamos. Para responder a la pregunta de interés, primero seleccionemos la parte de los datos correspondiente al año 2000 y a la población total. Usaremos la función <code>query()</code> para hacer esto rápidamente (esto requiere que el paquete <code>numexpr</code> esté instalado; vea <a href="03.12-Performance-Eval-and-Query.ipynb">High-Performance Pandas: <code>eval()</code> y <code>query()</code></a>):</p>
<div id="47911a22" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb151"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb151-1"><a href="#cb151-1" aria-hidden="true" tabindex="-1"></a>data2010 <span class="op">=</span> final.query(<span class="st">"year == 2010 &amp; ages == 'total'"</span>)</span>
<span id="cb151-2"><a href="#cb151-2" aria-hidden="true" tabindex="-1"></a>data2010.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Ahora calculemos la densidad de población y mostrémosla en orden. Comenzaremos reindexando nuestros datos sobre el estado y luego calcularemos el resultado:</p>
<div id="43c6cffe" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb152"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb152-1"><a href="#cb152-1" aria-hidden="true" tabindex="-1"></a>data2010.set_index(<span class="st">'state'</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb152-2"><a href="#cb152-2" aria-hidden="true" tabindex="-1"></a>density <span class="op">=</span> data2010[<span class="st">'population'</span>] <span class="op">/</span> data2010[<span class="st">'area (sq. mi)'</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="ba525158" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb153"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true" tabindex="-1"></a>density.sort_values(ascending<span class="op">=</span><span class="va">False</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb153-2"><a href="#cb153-2" aria-hidden="true" tabindex="-1"></a>density.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>El resultado es una clasificación de los estados de EE. UU. más Washington, DC y Puerto Rico en orden de su densidad de población en 2010, en residentes por milla cuadrada. Podemos ver que, con diferencia, la región más densa en este conjunto de datos es Washington, DC (es decir, el Distrito de Columbia); entre los estados, el más denso es Nueva Jersey.</p>
<p>También podemos consultar el final de la lista:</p>
<div id="8cebb7cd" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb154"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb154-1"><a href="#cb154-1" aria-hidden="true" tabindex="-1"></a>density.tail()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Vemos que el estado menos denso, con diferencia, es Alaska, con un promedio de poco más de un residente por milla cuadrada.</p>
<p>Este tipo de fusión desordenada de datos es una tarea común cuando se intenta responder preguntas utilizando fuentes de datos del mundo real. ¡Espero que este ejemplo te haya dado una idea de las formas en que puedes combinar las herramientas que hemos cubierto para obtener información de tus datos!</p>
</section>
</section>

<!-- 7.8 -->
<section id="py-pandas-agg" class="level2" data-number="7.8">
                <h2 data-number="7.8" class="anchored" data-anchor-id="py-pandas-agg"><span
                        class="header-section-number">7.8</span> Agregación y agrupación</h2>
<p>Una parte esencial del análisis de datos grandes es el resumen eficiente: calcular agregaciones como <code>sum()</code>, <code>mean()</code>, <code>median()</code>, <code>min()</code> y <code>max()</code>, en las que un solo número brinda información sobre la naturaleza de un conjunto de datos potencialmente grande. En esta sección, exploraremos las agregaciones en Pandas, desde operaciones simples similares a las que hemos visto en las matrices NumPy, hasta operaciones más sofisticadas basadas en el concepto de “groupby”.</p>
<p>Para mayor comodidad, utilizaremos la misma función mágica <code>display</code> que hemos visto en secciones anteriores:</p>
<div id="2a2b8a7d" class="cell">
<div class="sourceCode cell-code" id="cb155"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb155-1"><a href="#cb155-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb155-2"><a href="#cb155-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb155-3"><a href="#cb155-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb155-4"><a href="#cb155-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> display(<span class="bu">object</span>):</span>
<span id="cb155-5"><a href="#cb155-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Display HTML representation of multiple objects"""</span></span>
<span id="cb155-6"><a href="#cb155-6" aria-hidden="true" tabindex="-1"></a>    template <span class="op">=</span> <span class="st">"""&lt;div style="float: left; padding: 10px;"&gt;</span></span>
<span id="cb155-7"><a href="#cb155-7" aria-hidden="true" tabindex="-1"></a><span class="st">    &lt;p style='font-family:"Courier New", Courier, monospace'&gt;</span><span class="sc">{0}</span><span class="st">&lt;/p&gt;</span><span class="sc">{1}</span></span>
<span id="cb155-8"><a href="#cb155-8" aria-hidden="true" tabindex="-1"></a><span class="st">    &lt;/div&gt;"""</span></span>
<span id="cb155-9"><a href="#cb155-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, <span class="op">*</span>args):</span>
<span id="cb155-10"><a href="#cb155-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.args <span class="op">=</span> args</span>
<span id="cb155-11"><a href="#cb155-11" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb155-12"><a href="#cb155-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _repr_html_(<span class="va">self</span>):</span>
<span id="cb155-13"><a href="#cb155-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">'</span><span class="ch">\n</span><span class="st">'</span>.join(<span class="va">self</span>.template.<span class="bu">format</span>(a, <span class="bu">eval</span>(a)._repr_html_())</span>
<span id="cb155-14"><a href="#cb155-14" aria-hidden="true" tabindex="-1"></a>                         <span class="cf">for</span> a <span class="kw">in</span> <span class="va">self</span>.args)</span>
<span id="cb155-15"><a href="#cb155-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb155-16"><a href="#cb155-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__repr__</span>(<span class="va">self</span>):</span>
<span id="cb155-17"><a href="#cb155-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">'</span><span class="ch">\n\n</span><span class="st">'</span>.join(a <span class="op">+</span> <span class="st">'</span><span class="ch">\n</span><span class="st">'</span> <span class="op">+</span> <span class="bu">repr</span>(<span class="bu">eval</span>(a))</span>
<span id="cb155-18"><a href="#cb155-18" aria-hidden="true" tabindex="-1"></a>                           <span class="cf">for</span> a <span class="kw">in</span> <span class="va">self</span>.args)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="py-pandas-planets" class="level3" data-number="7.8.1">
                    <h3 data-number="7.8.1" class="anchored" data-anchor-id="py-pandas-planets"><span
                            class="header-section-number">7.8.1 </span>  Datos de los planetas</h3>
<p>Aquí utilizaremos el conjunto de datos Planetas, disponible a través de <a href="http://seaborn.pydata.org/">Seaborn package</a> (ver <a href="http://seaborn.pydata.org/">Seaborn package</a>). Proporciona información sobre planetas que los astrónomos han descubierto alrededor de otras estrellas (conocidos como <em>planetas extrasolares</em> o <em>exoplanetas</em> para abreviar). Se puede descargar con un simple comando Seaborn:</p>
<div id="c5dd0733" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb156"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb156-1"><a href="#cb156-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb156-2"><a href="#cb156-2" aria-hidden="true" tabindex="-1"></a>planets <span class="op">=</span> sns.load_dataset(<span class="st">'planets'</span>)</span>
<span id="cb156-3"><a href="#cb156-3" aria-hidden="true" tabindex="-1"></a>planets.shape</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="2a69e646" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb157"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb157-1"><a href="#cb157-1" aria-hidden="true" tabindex="-1"></a>planets.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Aquí encontrará algunos detalles sobre los más de 1.000 planetas extrasolares descubiertos hasta 2014.</p>
</section>
<section id="py-pandas-aggsimple" class="level3" data-number="7.8.2">
                    <h3 data-number="7.8.2" class="anchored" data-anchor-id="py-pandas-aggsimple"><span
                            class="header-section-number">7.8.2 </span>  Agregación simple en Pandas</h3>
<p>Anteriormente, exploramos algunas de las agregaciones de datos disponibles para las matrices NumPy (<a href="02.04-Computation-on-arrays-aggregates.ipynb">“Aggregations: Min, Max, and Everything In Between”</a>). Al igual que con una matriz NumPy unidimensional, para una «Serie» de Pandas los agregados devuelven un único valor:</p>
<div id="92f5eb33" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb158"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb158-1"><a href="#cb158-1" aria-hidden="true" tabindex="-1"></a>rng <span class="op">=</span> np.random.RandomState(<span class="dv">42</span>)</span>
<span id="cb158-2"><a href="#cb158-2" aria-hidden="true" tabindex="-1"></a>ser <span class="op">=</span> pd.Series(rng.rand(<span class="dv">5</span>))</span>
<span id="cb158-3"><a href="#cb158-3" aria-hidden="true" tabindex="-1"></a>ser</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="65eae3ec" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb159"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb159-1"><a href="#cb159-1" aria-hidden="true" tabindex="-1"></a>ser.<span class="bu">sum</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="fcc9ff0d" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb160"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb160-1"><a href="#cb160-1" aria-hidden="true" tabindex="-1"></a>ser.mean()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Para un <code>DataFrame</code>, de forma predeterminada los agregados devuelven resultados dentro de cada columna:</p>
<div id="2c645828" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb161"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame({<span class="st">'A'</span>: rng.rand(<span class="dv">5</span>),</span>
<span id="cb161-2"><a href="#cb161-2" aria-hidden="true" tabindex="-1"></a>                   <span class="st">'B'</span>: rng.rand(<span class="dv">5</span>)})</span>
<span id="cb161-3"><a href="#cb161-3" aria-hidden="true" tabindex="-1"></a>df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="22d2d722" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb162"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb162-1"><a href="#cb162-1" aria-hidden="true" tabindex="-1"></a>df.mean()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Al especificar el argumento <code>axis</code>, puedes agregar dentro de cada fila:</p>
<div id="d538e46e" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb163"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb163-1"><a href="#cb163-1" aria-hidden="true" tabindex="-1"></a>df.mean(axis<span class="op">=</span><span class="st">'columns'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Las series y los marcos de datos de Pandas incluyen todos los agregados comunes mencionados en <a href="02.04-Computation-on-arrays-aggregates.ipynb">Aggregations: Min, Max, and Everything In Between</a>; además, hay un método conveniente <code>describe()</code> que calcula varios agregados comunes para cada columna y devuelve el resultado. Usemos esto en los datos de Planetas, por ahora descartando filas con valores faltantes:</p>
<div id="8791bae6" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb164"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb164-1"><a href="#cb164-1" aria-hidden="true" tabindex="-1"></a>planets.dropna().describe()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Esta puede ser una forma útil de comenzar a comprender las propiedades generales de un conjunto de datos. Por ejemplo, vemos en la columna “año” que, si bien los exoplanetas se descubrieron ya en 1989, la mitad de todos los exoplanetas conocidos no se descubrieron hasta 2010 o después. Esto se debe en gran medida a la misión <em>Kepler</em>, que es un telescopio espacial diseñado específicamente para encontrar planetas eclipsantes alrededor de otras estrellas.</p>
<p>La siguiente tabla resume algunas otras agregaciones integradas de Pandas:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: left;">Agregación</th>
<th style="text-align: left;">Descripción</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>count()</code></td>
<td style="text-align: left;">Número total de elementos</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>first()</code>, <code>last()</code></td>
<td style="text-align: left;">Primer y último elemento</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>mean()</code>, <code>median()</code></td>
<td style="text-align: left;">Media y mediana</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>min()</code>, <code>max()</code></td>
<td style="text-align: left;">Mínimo y máximo</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>std()</code>, <code>var()</code></td>
<td style="text-align: left;">Desviación estándar y varianza</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>mad()</code></td>
<td style="text-align: left;">Desviación absoluta media</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>prod()</code></td>
<td style="text-align: left;">Producto de todos los artículos</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>sum()</code></td>
<td style="text-align: left;">Suma de todos los elementos</td>
</tr>
</tbody>
</table>
<p>Todos estos son métodos de objetos <code>DataFrame</code> y <code>Series</code>.</p>
<p>Sin embargo, para profundizar en los datos, a menudo los agregados simples no son suficientes. El siguiente nivel de resumen de datos es la operación “groupby”, que permite calcular de forma rápida y eficiente agregados en subconjuntos de datos.</p>
</section>
<section id="py-pandas-gruopby" class="level3" data-number="7.8.3">
                    <h3 data-number="7.8.3" class="anchored" data-anchor-id="py-pandas-gruopby"><span
                            class="header-section-number">7.8.3 </span> GroupBy</h3>
<p>Las agregaciones simples pueden darle una idea de su conjunto de datos, pero a menudo preferiríamos agregar condicionalmente en alguna etiqueta o índice: esto se implementa en la llamada operación “groupby”. El nombre “agrupar por” proviene de un comando en el lenguaje de base de datos SQL, pero tal vez sea más esclarecedor pensar en él en los términos acuñados por primera vez por Hadley Wickham, de Rstats: <em>dividir, aplicar, combinar</em>.</p>
<section id="dividir-aplicar-combinar" class="level4">
<h4 class="anchored" data-anchor-id="dividir-aplicar-combinar">Dividir, aplicar, combinar</h4>
<p>Un ejemplo canónico de esta operación de dividir-aplicar-combinar, donde <em>Apply</em> es una agregación de suma, se ilustra en esta figura:</p>
<p><img src="Datasets/split-apply-combine.png" class="img-fluid"></p>
<p>Esto deja claro lo que logra el <code>groupby</code>:</p>
<ul>
<li>El paso <em>dividir</em> implica dividir y agrupar un <code>DataFrame</code> dependiendo del valor de la clave especificada.</li>
<li>El paso <em>aplicar</em> implica calcular alguna función, generalmente un agregado, una transformación o un filtrado, dentro de los grupos individuales.</li>
<li>El paso <em>combinar</em> fusiona los resultados de estas operaciones en una matriz de salida.</li>
</ul>
<p>Si bien esto podría hacerse de manera manual utilizando alguna combinación de los comandos de enmascaramiento, agregación y fusión que se mencionaron anteriormente, es importante tener en cuenta que <em>las divisiones intermedias no necesitan instanciarse explícitamente</em>. En cambio, el <code>GroupBy</code> puede (a menudo) hacer esto en una sola pasada sobre los datos, actualizando la suma, la media, el recuento, el mínimo u otro agregado para cada grupo a lo largo del camino. El poder de <code>GroupBy</code> es que abstrae estos pasos: el usuario no necesita pensar en <em>cómo</em> se realiza el cálculo bajo el capó, sino que piensa en la <em>operación como un todo</em>.</p>
<p>Como ejemplo concreto, veamos el uso de Pandas para el cálculo que se muestra en este diagrama. Comenzaremos creando la entrada <code>DataFrame</code>:</p>
<div id="3484ebbd" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb165"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb165-1"><a href="#cb165-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame({<span class="st">'key'</span>: [<span class="st">'A'</span>, <span class="st">'B'</span>, <span class="st">'C'</span>, <span class="st">'A'</span>, <span class="st">'B'</span>, <span class="st">'C'</span>],</span>
<span id="cb165-2"><a href="#cb165-2" aria-hidden="true" tabindex="-1"></a>                   <span class="st">'data'</span>: <span class="bu">range</span>(<span class="dv">6</span>)}, columns<span class="op">=</span>[<span class="st">'key'</span>, <span class="st">'data'</span>])</span>
<span id="cb165-3"><a href="#cb165-3" aria-hidden="true" tabindex="-1"></a>df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>La operación más básica de dividir-aplicar-combinar se puede calcular con el método <code>groupby()</code> de <code>DataFrame</code>, pasando el nombre de la columna clave deseada:</p>
<div id="e11e4b3d" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb166"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb166-1"><a href="#cb166-1" aria-hidden="true" tabindex="-1"></a>df.groupby(<span class="st">'key'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Tenga en cuenta que lo que se devuelve no es un conjunto de <code>DataFrame</code>, sino un objeto <code>DataFrameGroupBy</code>. Este objeto es donde está la magia: puedes pensar en él como una vista especial del «DataFrame», que está preparado para profundizar en los grupos pero no realiza ningún cálculo real hasta que se aplica la agregación. Este enfoque de “evaluación perezosa” significa que los agregados comunes se pueden implementar de manera muy eficiente y de una manera casi transparente para el usuario.</p>
<p>Para producir un resultado, podemos aplicar un agregado a este objeto <code>DataFrameGroupBy</code>, que realizará los pasos de aplicación/combinación adecuados para producir el resultado deseado:</p>
<div id="1dfb1ad0" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb167"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb167-1"><a href="#cb167-1" aria-hidden="true" tabindex="-1"></a>df.groupby(<span class="st">'key'</span>).<span class="bu">sum</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>El método <code>sum()</code> es sólo una posibilidad aquí; puede aplicar virtualmente cualquier función de agregación común de Pandas o NumPy, así como virtualmente cualquier operación <code>DataFrame</code> válida, como veremos en la siguiente discusión.</p>
</section>
<section id="el-objeto-groupby" class="level4">
<h4 class="anchored" data-anchor-id="el-objeto-groupby">El objeto GroupBy</h4>
<p>El objeto <code>GroupBy</code> es una abstracción muy flexible. En muchos sentidos, puedes tratarlo como si fuera una colección de “DataFrame” y hace las cosas difíciles por dentro. Veamos algunos ejemplos con los datos de Planets.</p>
<p>Quizás las operaciones más importantes que permite un <code>GroupBy</code> son <em>agregar</em>, <em>filtrar</em>, <em>transformar</em> y <em>aplicar</em>. Discutiremos cada uno de estos con más detalle en <a href="#Aggregate,-Filter,-Transform,-Apply">“Aggregate, Filter, Transform, Apply”</a>, pero antes de eso, presentemos algunas de las otras funcionalidades que se pueden usar con la operación básica <code>GroupBy</code>.</p>
<section id="indexación-de-columnas" class="level5">
<h5 class="anchored" data-anchor-id="indexación-de-columnas">Indexación de columnas</h5>
<p>El objeto <code>GroupBy</code> admite la indexación de columnas de la misma manera que <code>DataFrame</code> y devuelve un objeto <code>GroupBy</code> modificado. Por ejemplo:</p>
<div id="ca0ade0e" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb168"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb168-1"><a href="#cb168-1" aria-hidden="true" tabindex="-1"></a>planets.groupby(<span class="st">'method'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="9202186b" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb169"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb169-1"><a href="#cb169-1" aria-hidden="true" tabindex="-1"></a>planets.groupby(<span class="st">'method'</span>)[<span class="st">'orbital_period'</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Aquí hemos seleccionado un grupo «Series» particular del grupo «DataFrame» original por referencia a su nombre de columna. Al igual que con el objeto <code>GroupBy</code>, no se realiza ningún cálculo hasta que llamamos a algún agregado en el objeto:</p>
<div id="cb9dfe38" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb170"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb170-1"><a href="#cb170-1" aria-hidden="true" tabindex="-1"></a>planets.groupby(<span class="st">'method'</span>)[<span class="st">'orbital_period'</span>].median()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Esto da una idea de la escala general de períodos orbitales (en días) a los que cada método es sensible.</p>
</section>
<section id="iteración-sobre-grupos" class="level5">
<h5 class="anchored" data-anchor-id="iteración-sobre-grupos">Iteración sobre grupos</h5>
<p>El objeto <code>GroupBy</code> admite la iteración directa sobre los grupos y devuelve cada grupo como una <code>Serie</code> o <code>DataFrame</code>:</p>
<div id="6fd990be" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb171"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb171-1"><a href="#cb171-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (method, group) <span class="kw">in</span> planets.groupby(<span class="st">'method'</span>):</span>
<span id="cb171-2"><a href="#cb171-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"</span><span class="sc">{0:30s}</span><span class="st"> shape=</span><span class="sc">{1}</span><span class="st">"</span>.<span class="bu">format</span>(method, group.shape))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Esto puede ser útil para hacer ciertas cosas manualmente, aunque a menudo es mucho más rápido utilizar la funcionalidad incorporada “aplicar”, que analizaremos en breve.</p>
</section>
<section id="métodos-de-envío" class="level5">
<h5 class="anchored" data-anchor-id="métodos-de-envío">Métodos de envío</h5>
<p>Mediante cierta magia de clase de Python, cualquier método no implementado explícitamente por el objeto <code>GroupBy</code> será pasado y llamado en los grupos, ya sean objetos <code>DataFrame</code> o <code>Series</code>. Por ejemplo, puede utilizar el método <code>describe()</code> de <code>DataFrame</code> para realizar un conjunto de agregaciones que describan cada grupo en los datos:</p>
<div id="7323ca92" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb172"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb172-1"><a href="#cb172-1" aria-hidden="true" tabindex="-1"></a>planets.groupby(<span class="st">'method'</span>)[<span class="st">'year'</span>].describe().unstack()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Mirar esta tabla nos ayuda a comprender mejor los datos: por ejemplo, la gran mayoría de los planetas han sido descubiertos mediante los métodos de velocidad radial y de tránsito, aunque estos últimos solo se volvieron comunes (debido a telescopios nuevos y más precisos) en la última década. Los métodos más nuevos parecen ser la variación del tiempo de tránsito y la modulación del brillo orbital, que no se utilizaron para descubrir un nuevo planeta hasta 2011.</p>
<p>Este es sólo un ejemplo de la utilidad de los métodos de despacho. Tenga en cuenta que se aplican <em>a cada grupo individual</em> y luego los resultados se combinan dentro de <code>GroupBy</code> y se devuelven. Nuevamente, cualquier método <code>DataFrame</code>/<code>Series</code> válido se puede usar en el objeto <code>GroupBy</code> correspondiente, lo que permite algunas operaciones muy flexibles y poderosas.</p>
</section>
</section>
<section id="agregar-filtrar-transformar-aplicar" class="level4">
<h4 class="anchored" data-anchor-id="agregar-filtrar-transformar-aplicar">Agregar, filtrar, transformar, aplicar</h4>
<p>La discusión anterior se centró en la agregación para la operación de combinación, pero hay más opciones disponibles. En particular, los objetos <code>GroupBy</code> tienen métodos <code>agregate()</code>, <code>filter()</code>, <code>transform()</code> y <code>apply()</code> que implementan eficientemente una variedad de operaciones útiles antes de combinar los datos agrupados.</p>
<p>Para los fines de las siguientes subsecciones, utilizaremos este <code>DataFrame</code>:</p>
<div id="3ba1a754" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb173"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb173-1"><a href="#cb173-1" aria-hidden="true" tabindex="-1"></a>rng <span class="op">=</span> np.random.RandomState(<span class="dv">0</span>)</span>
<span id="cb173-2"><a href="#cb173-2" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame({<span class="st">'key'</span>: [<span class="st">'A'</span>, <span class="st">'B'</span>, <span class="st">'C'</span>, <span class="st">'A'</span>, <span class="st">'B'</span>, <span class="st">'C'</span>],</span>
<span id="cb173-3"><a href="#cb173-3" aria-hidden="true" tabindex="-1"></a>                   <span class="st">'data1'</span>: <span class="bu">range</span>(<span class="dv">6</span>),</span>
<span id="cb173-4"><a href="#cb173-4" aria-hidden="true" tabindex="-1"></a>                   <span class="st">'data2'</span>: rng.randint(<span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">6</span>)},</span>
<span id="cb173-5"><a href="#cb173-5" aria-hidden="true" tabindex="-1"></a>                   columns <span class="op">=</span> [<span class="st">'key'</span>, <span class="st">'data1'</span>, <span class="st">'data2'</span>])</span>
<span id="cb173-6"><a href="#cb173-6" aria-hidden="true" tabindex="-1"></a>df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="agregación" class="level5">
<h5 class="anchored" data-anchor-id="agregación">Agregación</h5>
<p>Ahora estamos familiarizados con las agregaciones <code>GroupBy</code> con <code>sum()</code>, <code>median()</code> y similares, pero el método <code>agregate()</code> permite aún más flexibilidad. Puede tomar una cadena, una función o una lista de ellas y calcular todos los agregados a la vez. He aquí un ejemplo rápido que combina todo esto:</p>
<div id="31da7206" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb174"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb174-1"><a href="#cb174-1" aria-hidden="true" tabindex="-1"></a>df.groupby(<span class="st">'key'</span>).aggregate([<span class="st">'min'</span>, <span class="st">'median'</span>, <span class="st">'max'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Otro patrón útil es pasar un diccionario que asigne los nombres de las columnas a las operaciones que se aplicarán en esa columna:</p>
<div id="4252e888" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb175"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb175-1"><a href="#cb175-1" aria-hidden="true" tabindex="-1"></a>df.groupby(<span class="st">'key'</span>).aggregate({<span class="st">'data1'</span>: <span class="st">'min'</span>,</span>
<span id="cb175-2"><a href="#cb175-2" aria-hidden="true" tabindex="-1"></a>                             <span class="st">'data2'</span>: <span class="st">'max'</span>})</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="filtrado" class="level5">
<h5 class="anchored" data-anchor-id="filtrado">Filtrado</h5>
<p>Una operación de filtrado le permite eliminar datos según las propiedades del grupo. Por ejemplo, podríamos querer conservar todos los grupos en los que la desviación estándar sea mayor que algún valor crítico:</p>
<div id="f218089a" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb176"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb176-1"><a href="#cb176-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> filter_func(x):</span>
<span id="cb176-2"><a href="#cb176-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x[<span class="st">'data2'</span>].std() <span class="op">&gt;</span> <span class="dv">4</span></span>
<span id="cb176-3"><a href="#cb176-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb176-4"><a href="#cb176-4" aria-hidden="true" tabindex="-1"></a>display(<span class="st">'df'</span>, <span class="st">"df.groupby('key').std()"</span>, <span class="st">"df.groupby('key').filter(filter_func)"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>La función de filtro debe devolver un valor booleano que especifique si el grupo pasa el filtro. En este caso, como el grupo A no tiene una desviación estándar mayor que 4, se lo excluye del resultado.</p>
</section>
<section id="transformación" class="level5">
<h5 class="anchored" data-anchor-id="transformación">Transformación</h5>
<p>Mientras que la agregación debe devolver una versión reducida de los datos, la transformación puede devolver una versión transformada de los datos completos para recombinarlos. Para tal transformación, la salida tiene la misma forma que la entrada. Un ejemplo común es centrar los datos restando la media del grupo:</p>
<div id="8054f38a" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb177"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb177-1"><a href="#cb177-1" aria-hidden="true" tabindex="-1"></a>df.groupby(<span class="st">'key'</span>).transform(<span class="kw">lambda</span> x: x <span class="op">-</span> x.mean())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="el-método-apply" class="level5">
<h5 class="anchored" data-anchor-id="el-método-apply">El método apply()</h5>
<p>El método <code>apply()</code> le permite aplicar una función arbitraria a los resultados del grupo. La función debe tomar un <code>DataFrame</code> y devolver un objeto Pandas (por ejemplo, <code>DataFrame</code>, <code>Series</code>) o un escalar; la operación de combinación se adaptará al tipo de salida devuelta.</p>
<p>Por ejemplo, aquí hay un <code>apply()</code> que normaliza la primera columna por la suma de la segunda:</p>
<div id="f26db35a" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb178"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb178-1"><a href="#cb178-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> norm_by_data2(x):</span>
<span id="cb178-2"><a href="#cb178-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># x es un DataFrame de valores de grupo</span></span>
<span id="cb178-3"><a href="#cb178-3" aria-hidden="true" tabindex="-1"></a>    x[<span class="st">'data1'</span>] <span class="op">/=</span> x[<span class="st">'data2'</span>].<span class="bu">sum</span>()</span>
<span id="cb178-4"><a href="#cb178-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x</span>
<span id="cb178-5"><a href="#cb178-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb178-6"><a href="#cb178-6" aria-hidden="true" tabindex="-1"></a>display(<span class="st">'df'</span>, <span class="st">"df.groupby('key').apply(norm_by_data2)"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><code>apply()</code> dentro de un <code>GroupBy</code> es bastante flexible: el único criterio es que la función toma un <code>DataFrame</code> y devuelve un objeto Pandas o un escalar; ¡lo que haga en el medio depende de usted!</p>
</section>
</section>
<section id="especificación-de-la-clave-dividida" class="level4">
<h4 class="anchored" data-anchor-id="especificación-de-la-clave-dividida">Especificación de la clave dividida</h4>
<p>En los ejemplos simples presentados anteriormente, dividimos el “DataFrame” en un solo nombre de columna. Esta es sólo una de las muchas opciones mediante las cuales se pueden definir los grupos; aquí repasaremos algunas otras opciones para la especificación de grupos.</p>
<section id="una-lista-matriz-serie-o-índice-que-proporciona-las-claves-de-agrupación" class="level5">
<h5 class="anchored" data-anchor-id="una-lista-matriz-serie-o-índice-que-proporciona-las-claves-de-agrupación">Una lista, matriz, serie o índice que proporciona las claves de agrupación</h5>
<p>La clave puede ser cualquier serie o lista con una longitud que coincida con la del <code>DataFrame</code>. Por ejemplo:</p>
<div id="6f628102" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb179"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb179-1"><a href="#cb179-1" aria-hidden="true" tabindex="-1"></a>L <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">0</span>]</span>
<span id="cb179-2"><a href="#cb179-2" aria-hidden="true" tabindex="-1"></a>display(<span class="st">'df'</span>, <span class="st">'df.groupby(L).sum()'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Por supuesto, esto significa que hay otra forma más detallada de lograr el <code>df.groupby('key')</code> de antes:</p>
<div id="9d26b726" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb180"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb180-1"><a href="#cb180-1" aria-hidden="true" tabindex="-1"></a>display(<span class="st">'df'</span>, <span class="st">"df.groupby(df['key']).sum()"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="un-diccionario-o-serie-que-asigna-el-índice-al-grupo" class="level5">
<h5 class="anchored" data-anchor-id="un-diccionario-o-serie-que-asigna-el-índice-al-grupo">Un diccionario o serie que asigna el índice al grupo</h5>
<p>Otro método es proporcionar un diccionario que asigne valores de índice a las claves del grupo:</p>
<div id="d58d45ac" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb181"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb181-1"><a href="#cb181-1" aria-hidden="true" tabindex="-1"></a>df2 <span class="op">=</span> df.set_index(<span class="st">'key'</span>)</span>
<span id="cb181-2"><a href="#cb181-2" aria-hidden="true" tabindex="-1"></a>mapping <span class="op">=</span> {<span class="st">'A'</span>: <span class="st">'vowel'</span>, <span class="st">'B'</span>: <span class="st">'consonant'</span>, <span class="st">'C'</span>: <span class="st">'consonant'</span>}</span>
<span id="cb181-3"><a href="#cb181-3" aria-hidden="true" tabindex="-1"></a>display(<span class="st">'df2'</span>, <span class="st">'df2.groupby(mapping).sum()'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="cualquier-función-de-python" class="level5">
<h5 class="anchored" data-anchor-id="cualquier-función-de-python">Cualquier función de Python</h5>
<p>De manera similar al mapeo, puedes pasar cualquier función de Python que ingrese el valor del índice y genere el grupo:</p>
<div id="ad748ab9" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb182"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb182-1"><a href="#cb182-1" aria-hidden="true" tabindex="-1"></a>display(<span class="st">'df2'</span>, <span class="st">'df2.groupby(str.lower).mean()'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="una-lista-de-claves-válidas" class="level5">
<h5 class="anchored" data-anchor-id="una-lista-de-claves-válidas">Una lista de claves válidas</h5>
<p>Además, cualquiera de las opciones clave anteriores se pueden combinar para agruparlas en un índice múltiple:</p>
<div id="23c6cf37" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb183"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb183-1"><a href="#cb183-1" aria-hidden="true" tabindex="-1"></a>df2.groupby([<span class="bu">str</span>.lower, mapping]).mean()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="ejemplo-de-agrupación" class="level4">
<h4 class="anchored" data-anchor-id="ejemplo-de-agrupación">Ejemplo de agrupación</h4>
<p>Como ejemplo de esto, en un par de líneas de código Python podemos juntar todo esto y contar los planetas descubiertos por método y por década:</p>
<div id="4a371f98" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb184"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb184-1"><a href="#cb184-1" aria-hidden="true" tabindex="-1"></a>decade <span class="op">=</span> <span class="dv">10</span> <span class="op">*</span> (planets[<span class="st">'year'</span>] <span class="op">//</span> <span class="dv">10</span>)</span>
<span id="cb184-2"><a href="#cb184-2" aria-hidden="true" tabindex="-1"></a>decade <span class="op">=</span> decade.astype(<span class="bu">str</span>) <span class="op">+</span> <span class="st">'s'</span></span>
<span id="cb184-3"><a href="#cb184-3" aria-hidden="true" tabindex="-1"></a>decade.name <span class="op">=</span> <span class="st">'decade'</span></span>
<span id="cb184-4"><a href="#cb184-4" aria-hidden="true" tabindex="-1"></a>planets.groupby([<span class="st">'method'</span>, decade])[<span class="st">'number'</span>].<span class="bu">sum</span>().unstack().fillna(<span class="dv">0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Esto demuestra el poder de combinar muchas de las operaciones que hemos discutido hasta este punto cuando observamos conjuntos de datos realistas. ¡Obtenemos inmediatamente una comprensión aproximada de cuándo y cómo se descubrieron los planetas a lo largo de las últimas décadas!</p>
<p>Aquí sugeriría profundizar en estas pocas líneas de código y evaluar los pasos individuales para asegurarse de comprender exactamente lo que están haciendo con el resultado. Ciertamente es un ejemplo algo complicado, pero comprender estas piezas le brindará los medios para explorar de manera similar sus propios datos.</p>
</section>
</section>
</section>

<!-- 7.9 -->

<section id="practice-exercises" class="level2" data-number="7.9">
                <h2 data-number="7.9" class="anchored" data-anchor-id="practice-exercises"><span
                        class="header-section-number">7.9</span> Ejercicios prácticos </h2>
<ol type="1">
<li>Cree un nuevo Notebook.</li>
<li>Guarde el archivo como <strong>Ejercicios_practicos_clase_7.ipynb</strong>.</li>
<li>Asigne un título <strong>H1</strong> con su nombre.</li>
</ol>
<section id="practice-exercise-1" class="level3" data-number="7.9.1">
                    <h3 data-number="7.9.1" class="anchored" data-anchor-id="practice-exercise-1"><span
                            class="header-section-number">7.9.1 </span> Ejercicio práctico 1 </h3>
<p>Se tiene el archivo <a href="Datasets/ventas.csv">ventas.csv</a> con las ventas de una tienda en los últimos seis meses. El archivo contiene las siguientes columnas: Fecha, Producto, Cantidad, PrecioUnitario, Categoria.</p>
<ol type="1">
<li>Cargar el archivo CSV en un DataFrame.</li>
<li>Mostrar las primeras 5 filas del DataFrame para familiarizarse con los datos.</li>
<li>Calcular el total de ingresos (Cantidad * PrecioUnitario) y añadirlo como una nueva columna.</li>
<li>Filtrar y mostrar las ventas realizadas en el mes de junio.</li>
<li>Agrupar las ventas por Categoria y calcular el ingreso total por cada categoría.</li>
<li>Identificar los productos con mayores ventas en términos de cantidad y de ingresos.</li>
</ol>
</section>
<section id="practice-exercise-2" class="level3" data-number="7.9.2">
                    <h3 data-number="7.9.2" class="anchored" data-anchor-id="practice-exercise-2"><span
                            class="header-section-number">7.9.2 </span> Ejercicio práctico 2 </h3>
<p>Se tiene el archivo Excel <a href="Datasets/empleados.xlsx">empleados.csv</a> con la información de empleados de una empresa. El archivo contiene las siguientes columnas: ID, Nombre, Departamento, Salario, Edad, AñosEnLaEmpresa.</p>
<ol type="1">
<li>Cargar el archivo Excel en un DataFrame.</li>
<li>Mostrar las columnas Nombre, Salario y Departamento de todos los empleados.</li>
<li>Calcular el salario promedio de los empleados por departamento.</li>
<li>Filtrar los empleados que tienen más de 10 años en la empresa y un salario mayor a $3.500.000.</li>
<li>Añadir una columna que calcule el bono de fin de año (10% del salario si tiene más de 5 años en la empresa, 5% en caso contrario).</li>
<li>Ordenar el DataFrame por Salario de mayor a menor y mostrar los 5 empleados con mayor salario.</li>
</ol>
</section>
</section>

        </main> <!-- /main -->
        <script id="quarto-html-after-body" type="application/javascript">
            window.document.addEventListener("DOMContentLoaded", function (event) {
                const toggleBodyColorMode = (bsSheetEl) => {
                    const mode = bsSheetEl.getAttribute("data-mode");
                    const bodyEl = window.document.querySelector("body");
                    if (mode === "dark") {
                        bodyEl.classList.add("quarto-dark");
                        bodyEl.classList.remove("quarto-light");
                    } else {
                        bodyEl.classList.add("quarto-light");
                        bodyEl.classList.remove("quarto-dark");
                    }
                }
                const toggleBodyColorPrimary = () => {
                    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
                    if (bsSheetEl) {
                        toggleBodyColorMode(bsSheetEl);
                    }
                }
                toggleBodyColorPrimary();
                const icon = "";
                const anchorJS = new window.AnchorJS();
                anchorJS.options = {
                    placement: 'right',
                    icon: icon
                };
                anchorJS.add('.anchored');
                const isCodeAnnotation = (el) => {
                    for (const clz of el.classList) {
                        if (clz.startsWith('code-annotation-')) {
                            return true;
                        }
                    }
                    return false;
                }
                const clipboard = new window.ClipboardJS('.code-copy-button', {
                    text: function (trigger) {
                        const codeEl = trigger.previousElementSibling.cloneNode(true);
                        for (const childEl of codeEl.children) {
                            if (isCodeAnnotation(childEl)) {
                                childEl.remove();
                            }
                        }
                        return codeEl.innerText;
                    }
                });
                clipboard.on('success', function (e) {
                    // button target
                    const button = e.trigger;
                    // don't keep focus
                    button.blur();
                    // flash "checked"
                    button.classList.add('code-copy-button-checked');
                    var currentTitle = button.getAttribute("title");
                    button.setAttribute("title", "Copied!");
                    let tooltip;
                    if (window.bootstrap) {
                        button.setAttribute("data-bs-toggle", "tooltip");
                        button.setAttribute("data-bs-placement", "left");
                        button.setAttribute("data-bs-title", "Copied!");
                        tooltip = new bootstrap.Tooltip(button,
                            {
                                trigger: "manual",
                                customClass: "code-copy-button-tooltip",
                                offset: [0, -8]
                            });
                        tooltip.show();
                    }
                    setTimeout(function () {
                        if (tooltip) {
                            tooltip.hide();
                            button.removeAttribute("data-bs-title");
                            button.removeAttribute("data-bs-toggle");
                            button.removeAttribute("data-bs-placement");
                        }
                        button.setAttribute("title", currentTitle);
                        button.classList.remove('code-copy-button-checked');
                    }, 1000);
                    // clear code selection
                    e.clearSelection();
                });
                function tippyHover(el, contentFn) {
                    const config = {
                        allowHTML: true,
                        content: contentFn,
                        maxWidth: 500,
                        delay: 100,
                        arrow: false,
                        appendTo: function (el) {
                            return el.parentElement;
                        },
                        interactive: true,
                        interactiveBorder: 10,
                        theme: 'quarto',
                        placement: 'bottom-start'
                    };
                    window.tippy(el, config);
                }
                const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
                for (var i = 0; i < noterefs.length; i++) {
                    const ref = noterefs[i];
                    tippyHover(ref, function () {
                        // use id or data attribute instead here
                        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
                        try { href = new URL(href).hash; } catch { }
                        const id = href.replace(/^#\/?/, "");
                        const note = window.document.getElementById(id);
                        return note.innerHTML;
                    });
                }
                let selectedAnnoteEl;
                const selectorForAnnotation = (cell, annotation) => {
                    let cellAttr = 'data-code-cell="' + cell + '"';
                    let lineAttr = 'data-code-annotation="' + annotation + '"';
                    const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
                    return selector;
                }
                const selectCodeLines = (annoteEl) => {
                    const doc = window.document;
                    const targetCell = annoteEl.getAttribute("data-target-cell");
                    const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
                    const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
                    const lines = annoteSpan.getAttribute("data-code-lines").split(",");
                    const lineIds = lines.map((line) => {
                        return targetCell + "-" + line;
                    })
                    let top = null;
                    let height = null;
                    let parent = null;
                    if (lineIds.length > 0) {
                        //compute the position of the single el (top and bottom and make a div)
                        const el = window.document.getElementById(lineIds[0]);
                        top = el.offsetTop;
                        height = el.offsetHeight;
                        parent = el.parentElement.parentElement;
                        if (lineIds.length > 1) {
                            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
                            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
                            height = bottom - top;
                        }
                        if (top !== null && height !== null && parent !== null) {
                            // cook up a div (if necessary) and position it 
                            let div = window.document.getElementById("code-annotation-line-highlight");
                            if (div === null) {
                                div = window.document.createElement("div");
                                div.setAttribute("id", "code-annotation-line-highlight");
                                div.style.position = 'absolute';
                                parent.appendChild(div);
                            }
                            div.style.top = top - 2 + "px";
                            div.style.height = height + 4 + "px";
                            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
                            if (gutterDiv === null) {
                                gutterDiv = window.document.createElement("div");
                                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                                gutterDiv.style.position = 'absolute';
                                const codeCell = window.document.getElementById(targetCell);
                                const gutter = codeCell.querySelector('.code-annotation-gutter');
                                gutter.appendChild(gutterDiv);
                            }
                            gutterDiv.style.top = top - 2 + "px";
                            gutterDiv.style.height = height + 4 + "px";
                        }
                        selectedAnnoteEl = annoteEl;
                    }
                };
                const unselectCodeLines = () => {
                    const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
                    elementsIds.forEach((elId) => {
                        const div = window.document.getElementById(elId);
                        if (div) {
                            div.remove();
                        }
                    });
                    selectedAnnoteEl = undefined;
                };
                // Attach click handler to the DT
                const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
                for (const annoteDlNode of annoteDls) {
                    annoteDlNode.addEventListener('click', (event) => {
                        const clickedEl = event.target;
                        if (clickedEl !== selectedAnnoteEl) {
                            unselectCodeLines();
                            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
                            if (activeEl) {
                                activeEl.classList.remove('code-annotation-active');
                            }
                            selectCodeLines(clickedEl);
                            clickedEl.classList.add('code-annotation-active');
                        } else {
                            // Unselect the line
                            unselectCodeLines();
                            clickedEl.classList.remove('code-annotation-active');
                        }
                    });
                }
                const findCites = (el) => {
                    const parentEl = el.parentElement;
                    if (parentEl) {
                        const cites = parentEl.dataset.cites;
                        if (cites) {
                            return {
                                el,
                                cites: cites.split(' ')
                            };
                        } else {
                            return findCites(el.parentElement)
                        }
                    } else {
                        return undefined;
                    }
                };
                var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
                for (var i = 0; i < bibliorefs.length; i++) {
                    const ref = bibliorefs[i];
                    const citeInfo = findCites(ref);
                    if (citeInfo) {
                        tippyHover(citeInfo.el, function () {
                            var popup = window.document.createElement('div');
                            citeInfo.cites.forEach(function (cite) {
                                var citeDiv = window.document.createElement('div');
                                citeDiv.classList.add('hanging-indent');
                                citeDiv.classList.add('csl-entry');
                                var biblioDiv = window.document.getElementById('ref-' + cite);
                                if (biblioDiv) {
                                    citeDiv.innerHTML = biblioDiv.innerHTML;
                                }
                                popup.appendChild(citeDiv);
                            });
                            return popup.innerHTML;
                        });
                    }
                }
            });
        </script>
        <nav class="page-navigation">
            <div class="nav-page nav-page-previous">
                <a href="./06_Numpy.html" class="pagination-link">
                    <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span
                            class="chapter-number">6</span>&nbsp; <span class="chapter-title">Introducción a NumPy
                                </span></span>
                </a>
            </div>
            <div class="nav-page nav-page-next">
                <a href="./08_EDA.html" class="pagination-link">
                    <span class="nav-page-text"><span class="chapter-number">8</span>&nbsp; <span
                            class="chapter-title">Análisis Exploratorio de Datos (EDA)</span></span> <i class="bi bi-arrow-right-short"></i>
                </a>
            </div>
        </nav>
    </div>
    <!-- /content -->



</body>

</html>