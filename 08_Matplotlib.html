<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>

    <meta charset="utf-8">
    <meta name="generator" content="quarto-1.3.450">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <meta name="author" content="Andrés Quintero-Zea">
    <meta name="dcterms.date" content="2024-09-09">

    <title>Visualización de datos con Matplotlib y Seaborn</title>
    <style>
        code {
            white-space: pre-wrap;
        }

        span.smallcaps {
            font-variant: small-caps;
        }

        div.columns {
            display: flex;
            gap: min(4vw, 1.5em);
        }

        div.column {
            flex: auto;
            overflow-x: auto;
        }

        div.hanging-indent {
            margin-left: 1.5em;
            text-indent: -1.5em;
        }

        ul.task-list {
            list-style: none;
        }

        ul.task-list li input[type="checkbox"] {
            width: 0.8em;
            margin: 0 0.8em 0.2em -1em;
            /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */
            vertical-align: middle;
        }

        /* CSS for syntax highlighting */
        pre>code.sourceCode {
            white-space: pre;
            position: relative;
        }

        pre>code.sourceCode>span {
            display: inline-block;
            line-height: 1.25;
        }

        pre>code.sourceCode>span:empty {
            height: 1.2em;
        }

        .sourceCode {
            overflow: visible;
        }

        code.sourceCode>span {
            color: inherit;
            text-decoration: inherit;
        }

        div.sourceCode {
            margin: 1em 0;
        }

        pre.sourceCode {
            margin: 0;
        }

        @media screen {
            div.sourceCode {
                overflow: auto;
            }
        }

        @media print {
            pre>code.sourceCode {
                white-space: pre-wrap;
            }

            pre>code.sourceCode>span {
                text-indent: -5em;
                padding-left: 5em;
            }
        }

        pre.numberSource code {
            counter-reset: source-line 0;
        }

        pre.numberSource code>span {
            position: relative;
            left: -4em;
            counter-increment: source-line;
        }

        pre.numberSource code>span>a:first-child::before {
            content: counter(source-line);
            position: relative;
            left: -1em;
            text-align: right;
            vertical-align: baseline;
            border: none;
            display: inline-block;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            padding: 0 4px;
            width: 4em;
        }

        pre.numberSource {
            margin-left: 3em;
            padding-left: 4px;
        }


        @media screen {
            pre>code.sourceCode>span>a:first-child::before {
                text-decoration: underline;
            }
        }
    </style>

    <script src="assets/quarto-nav/quarto-nav.js"></script>
    <script src="assets/quarto-nav/headroom.min.js"></script>
    <script src="assets/clipboard/clipboard.min.js"></script>
    <script src="assets/quarto-search/autocomplete.umd.js"></script>
    <script src="assets/quarto-search/fuse.min.js"></script>
    <script src="assets/quarto-search/quarto-search.js"></script>
    <meta name="quarto:offset" content="./">
    <link href="./09_EDA.html" rel="next">
    <link href="./07_Pandas.html" rel="prev">
    <script src="assets/quarto-html/quarto.js"></script>
    <script src="assets/quarto-html/popper.min.js"></script>
    <script src="assets/quarto-html/tippy.umd.min.js"></script>
    <script src="assets/quarto-html/anchor.min.js"></script>
    <link href="assets/quarto-html/tippy.css" rel="stylesheet">
    <link href="assets/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet"
        id="quarto-text-highlighting-styles">
    <script src="assets/bootstrap/bootstrap.min.js"></script>
    <link href="assets/bootstrap/bootstrap-icons.css" rel="stylesheet">
    <link href="assets/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
    <script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"
        integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg=="
        crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js"
        integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg=="
        crossorigin="anonymous"></script>
    <script type="application/javascript">define('jquery', [], function () { return window.jQuery; })</script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>

</head>

<body class="nav-sidebar floating">

    <!-- content -->
    <div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
        <!-- sidebar -->
        <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation floating overflow-auto">
            <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
                <img src="./LogoNuevo.png" alt="" class="sidebar-logo py-0 d-lg-inline d-none">
                <div class="sidebar-title mb-0 py-0">
                    <a href="./index.html">Programación PRE2013A45</a>
                </div>
            </div>
            <div class="sidebar-menu-container">
                <ul class="list-unstyled mt-1">
                    <li class="sidebar-item sidebar-item-section">
                        <div class="sidebar-item-container">
                            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse"
                                data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
                                <span class="menu-text">Python</span></a>
                            <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse"
                                data-bs-target="#quarto-sidebar-section-1" aria-expanded="true"
                                aria-label="Toggle section">
                                <i class="bi bi-chevron-right ms-2"></i>
                            </a>
                        </div>
                        <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">
                            <li class="sidebar-item">
                                <div class="sidebar-item-container">
                                    <a href="./01_Intro_Python.html" class="sidebar-item-text sidebar-link">
                                        <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span
                                                class="chapter-title">Introducción a Python</span></span></a>
                                </div>
                            </li>
                            <li class="sidebar-item">
                                <div class="sidebar-item-container">
                                    <a href="./02_Estructuras_control.html" class="sidebar-item-text sidebar-link">
                                        <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span
                                                class="chapter-title">Estructuras de control</span></span></a>
                                </div>
                            </li>
                            <li class="sidebar-item">
                                <div class="sidebar-item-container">
                                    <a href="./03_Funciones.html" class="sidebar-item-text sidebar-link">
                                        <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span
                                                class="chapter-title">Funciones</span></span></a>
                                </div>
                            </li>
                            <li class="sidebar-item">
                                <div class="sidebar-item-container">
                                    <a href="./04_Estructura_datos.html" class="sidebar-item-text sidebar-link">
                                        <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span
                                                class="chapter-title">Estructuras de datos avanzadas</span></span></a>
                                </div>
                            </li>
                            <li class="sidebar-item">
                                <div class="sidebar-item-container">
                                    <a href="./05_Archivos_excepciones.html" class="sidebar-item-text sidebar-link">
                                        <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span
                                                class="chapter-title">Manejo de archivos y excepciones</span></span></a>
                                </div>
                            </li>
                        </ul>
                    </li>
                    <li class="sidebar-item sidebar-item-section">
                        <div class="sidebar-item-container">
                            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse"
                                data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
                                <span class="menu-text">Análisis de Datos</span></a>
                            <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse"
                                data-bs-target="#quarto-sidebar-section-2" aria-expanded="true"
                                aria-label="Toggle section">
                                <i class="bi bi-chevron-right ms-2"></i>
                            </a>
                        </div>
                        <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">
                            <li class="sidebar-item">
                                <div class="sidebar-item-container">
                                    <a href="./06_Numpy.html" class="sidebar-item-text sidebar-link">
                                        <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span
                                                class="chapter-title">Introducción a Numpy</span></span></a>
                                </div>
                            </li>
                            <li class="sidebar-item">
                                <div class="sidebar-item-container">
                                    <a href="./07_Pandas.html" class="sidebar-item-text sidebar-link">
                                        <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span
                                                class="chapter-title">Manipulación de datos con Pandas</span></span></a>
                                </div>
                            </li>
                                                        <li class="sidebar-item">
                                <div class="sidebar-item-container">
                                    <a href="./08_Matplotlib.html" class="sidebar-item-text sidebar-link active">
                                        <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span
                                                class="chapter-title">Visualización de datos con
                                                Matplotlib y Seaborn</span></span></a>
                                </div>
                            </li>
							<li class="sidebar-item">
                                <div class="sidebar-item-container">
                                    <a href="./09_EDA.html" class="sidebar-item-text sidebar-link">
                                        <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span
                                                class="chapter-title">Análisis exploratorio de datos</span></span></a>
                                </div>
                            </li>
                        </ul>
                    </li>
                    <li class="sidebar-item sidebar-item-section">
                        <div class="sidebar-item-container">
                            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse"
                                data-bs-target="#quarto-sidebar-section-3" aria-expanded="true">
                                <span class="menu-text">Ciencia de Datos</span></a>
                            <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse"
                                data-bs-target="#quarto-sidebar-section-3" aria-expanded="true"
                                aria-label="Toggle section">
                                <i class="bi bi-chevron-right ms-2"></i>
                            </a>
                        </div>
                        <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">
                            <li class="sidebar-item">
                                <div class="sidebar-item-container">
                                    <a href="./10_Intro_DS.html" class="sidebar-item-text sidebar-link">
                                        <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span
                                                class="chapter-title">Introducción a la ciencia de
                                                datos</span></span></a>
                                </div>
                            </li>
                            <li class="sidebar-item">
                                <div class="sidebar-item-container">
                                    <a href="./11_Clasificacion.html" class="sidebar-item-text sidebar-link">
                                        <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span
                                                class="chapter-title">Modelos de clasificación</span></span></a>
                                </div>
                            </li>
                            <li class="sidebar-item">
                                <div class="sidebar-item-container">
                                    <a href="./12_Regresion.html" class="sidebar-item-text sidebar-link">
                                        <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span
                                                class="chapter-title">Modelos de regresión</span></span></a>
                                </div>
                            </li>
                        </ul>
                    </li>
                </ul>
            </div>
        </nav>
        <div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass">
        </div>
        <!-- margin-sidebar -->
        <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
            <nav id="TOC" role="doc-toc" class="toc-active">
                <h2 id="toc-title">Tabla de contenidos</h2>

                <ul>
                    <li><a href="#objetivo" id="toc-objetivo" class="nav-link active"
                            data-scroll-target="#objetivo">Objetivo</a></li>
                    <li><a href="#consejos-generales-sobre-matplotlib" id="toc-consejos-generales-sobre-matplotlib" class="nav-link"
                            data-scroll-target="#consejos-generales-sobre-matplotlib"><span class="header-section-number"> 8.1 </span> Consejos generales sobre Matplotlib </a></li>				
					<li><a href="#dos-interfaces-por-el-precio-de-una" id="toc-dos-interfaces-por-el-precio-de-una" class="nav-link"
                            data-scroll-target="#dos-interfaces-por-el-precio-de-una"><span class="header-section-number"> 8.2 </span> Dos interfaces por el precio de una </a>
                    </li>
					<li><a href="#gráficos-de-líneas-simples" id="toc-gráficos-de-líneas-simples" class="nav-link"
                            data-scroll-target="#gráficos-de-líneas-simples"><span class="header-section-number"> 8.3 </span> Gráficos de líneas simples </a>
                    </li>
					
					<li><a href="#diagramas-de-dispersión-simples" id="toc-diagramas-de-dispersión-simples" class="nav-link"
                            data-scroll-target="#diagramas-de-dispersión-simples"><span class="header-section-number"> 8.4 </span> Diagramas de dispersión simples </a>
                    </li>
					
					<li><a href="#visualizando-errores" id="toc-visualizando-errores" class="nav-link"
                            data-scroll-target="#visualizando-errores"><span class="header-section-number"> 8.5 </span> Visualizando errores</a>
                    </li>
					
					<li><a href="#gráficas-de-densidad-y-contorno" id="toc-gráficas-de-densidad-y-contorno" class="nav-link"
                            data-scroll-target="#gráficas-de-densidad-y-contorno"><span class="header-section-number"> 8.6 </span> Gráficas de densidad y contorno </a>
                    </li>
					
                    <li><a href="#histogramas-binnings-y-densidad" id="toc-histogramas-binnings-y-densidad" class="nav-link"
                            data-scroll-target="#histogramas-binnings-y-densidad"><span class="header-section-number"> 8.7 </span> Histogramas, binnings y densidad </a>
                    </li>
					
                    <li><a href="#personalización-de-leyendas" id="toc-personalización-de-leyendas" class="nav-link"
                            data-scroll-target="#personalización-de-leyendas"><span class="header-section-number"> 8.8 </span> Personalización de leyendas </a>
                    </li>
					
					<li><a href="#varias-subgráficas" id="toc-varias-subgráficas" class="nav-link"
                            data-scroll-target="#varias-subgráficas"><span class="header-section-number"> 8.9 </span> Varias subgráficas </a>
                    </li>
					
					<li><a href="#texto-y-anotaciones" id="toc-texto-y-anotaciones" class="nav-link"
                            data-scroll-target="#texto-y-anotaciones"><span class="header-section-number"> 8.10 </span> Texto y anotaciones </a>
                    </li>
					
					<li><a href="#personalización-de-ticks" id="toc-personalización-de-ticks" class="nav-link"
                            data-scroll-target="#personalización-de-ticks"><span class="header-section-number"> 8.11 </span> Personalización de ticks </a>
                    </li>
					
					<li><a href="#personalización-de-matplotlib" id="toc-personalización-de-matplotlib" class="nav-link"
                            data-scroll-target="#personalización-de-matplotlib"><span class="header-section-number"> 8.12 </span> Personalización de Matplotlib </a>
                    </li>
					
					<li><a href="#visualización-con-seaborn" id="toc-visualización-con-seaborn" class="nav-link"
                            data-scroll-target="#visualización-con-seaborn"><span class="header-section-number"> 8.13 </span> Visualización con Seaborn </a>
                    </li>
										
                    <li><a href="#practice-exercises" id="toc-practice-exercises" class="nav-link"
                            data-scroll-target="#practice-exercises"><span class="header-section-number">8.14</span>
                            Ejercicios prácticos</a></li>
                </ul>
            </nav>
        </div>
        <!-- main -->
        <main class="content" id="quarto-document-content">

            <header id="title-block-header" class="quarto-title-block default">
                <div class="quarto-title">
                    <h1 class="title"><span class="chapter-number">8</span>&nbsp; <span
                            class="chapter-title">Visualización de datos con Matplotlib y Seaborn</span></h1>
                </div>
                <div class="quarto-title-meta"> </div>
            </header>

            <section id="objetivo" class="level1">
                <h1 class="anchored" data-anchor-id="objetivo">Objetivo</h1>
                <p>
El objetivo de esta clase es enseñar a los estudiantes a crear visualizaciones de datos utilizando matplotlib y seaborn en Python, permitiéndoles representar gráficamente la información para explorar y analizar patrones y relaciones en los datos de manera efectiva.</p>
            </section>

<section id="consejos-generales-sobre-matplotlib" class="level2">
<h2 class="anchored" data-anchor-id="consejos-generales-sobre-matplotlib">8.1 Consejos generales sobre Matplotlib</h2>
<p>Antes de profundizar en los detalles de la creación de visualizaciones con Matplotlib, hay algunas cosas útiles que debe saber sobre el uso del paquete.</p>
<section id="importación-de-matplotlib" class="level3">
<h3 class="anchored" data-anchor-id="importación-de-matplotlib">8.1.1 Importación de Matplotlib</h3>
<p>Así como usamos la abreviatura <code>np</code> para NumPy y la abreviatura <code>pd</code> para Pandas, usaremos algunas abreviaturas de uso común para las importaciones de Matplotlib:</p>
<div id="41e4e2b3" class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib <span class="im">as</span> mpl</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib_inline.backend_inline <span class="im">import</span> set_matplotlib_formats</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>set_matplotlib_formats(<span class="st">'pdf'</span>, <span class="st">'svg'</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>matplotlib inline</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>La interfaz <code>plt</code> es la que utilizaremos con más frecuencia, como veremos a lo largo de este capítulo.</p>
</section>
<section id="estilos-de-configuración" class="level3">
<h3 class="anchored" data-anchor-id="estilos-de-configuración">8.1.2 Estilos de configuración</h3>
<p>Utilizaremos la directiva <code>plt.style</code> para elegir estilos estéticos apropiados para nuestras figuras. Aquí configuraremos el estilo <em>clásico</em>, que garantiza que los gráficos que creamos utilicen el estilo clásico de Matplotlib:</p>
<div id="c28e221c" class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>plt.style.use(<span class="st">'classic'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>A lo largo de esta sección, ajustaremos este estilo según sea necesario.</p>
<div id="88ddc83e" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">100</span>)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>plt.plot(x, np.sin(x), <span class="st">'-'</span>)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>plt.plot(x, np.cos(x), <span class="st">'--'</span>)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>plt.show()<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>En el ejemplo anterior, el comando <code>plt.show()</code> desencadena una serie de eventos que busca los objetos de figura activos y muestra las gráficas pendientes como imagen. Como por ejemplo en las siguientes dos celdas.</p>
<div id="8dbdce49-0db8-46d5-aec2-4e5ae0398233" class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>plt.plot(x, np.sin(x), <span class="st">'-'</span>)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>plt.plot(x, np.cos(x), <span class="st">'--'</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="63ae0e5e-63de-4352-9414-8fe9e1973713" class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">100</span>)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>plt.plot(x, np.cos(x), <span class="st">'-'</span>)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>plt.plot(x, np.cosh(x), <span class="st">'--'</span>)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>plt.show()<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="guardar-figuras-en-archivo" class="level3">
<h3 class="anchored" data-anchor-id="guardar-figuras-en-archivo">8.1.3 Guardar figuras en archivo</h3>
<p>Una característica interesante de Matplotlib es la capacidad de guardar figuras en una amplia variedad de formatos. Se puede guardar una figura utilizando el comando <code>savefig()</code>. Por ejemplo, para guardar la figura anterior como un archivo PNG o SVG, puede ejecutar esto:</p>
<div id="c8fd9635" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>fig.savefig(<span class="st">'my_figure.png'</span>)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>fig.savefig(<span class="st">'my_figure.svg'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Para confirmar que contiene lo que creemos que contiene, usemos el objeto <code>Image</code> de IPython para mostrar el contenido de este archivo:</p>
<div id="4ce8cbab" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> Image</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>Image(<span class="st">'my_figure.png'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>En <code>savefig()</code>, el formato de archivo se infiere de la extensión del nombre de archivo dado. Dependiendo de los <em>backends</em> que tenga instalados, hay muchos formatos de archivos diferentes disponibles. La lista de tipos de archivos compatibles con su sistema se puede encontrar utilizando el siguiente método del objeto figura:</p>
<div id="9adea09e" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>fig.canvas.get_supported_filetypes()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Tenga en cuenta que al guardar su figura, no es necesario utilizar <code>plt.show()</code>.</p>
</section>
</section>
<section id="dos-interfaces-por-el-precio-de-una" class="level2">
<h2 class="anchored" data-anchor-id="dos-interfaces-por-el-precio-de-una">8.2 Dos interfaces por el precio de una</h2>
<p>Una característica de Matplotlib que puede resultar confusa es su interfaz dual: una interfaz basada en estados, al estilo de MATLAB, y una interfaz orientada a objetos más potente. Destacaremos rápidamente las diferencias entre ambas.</p>
<section id="interfaz-estilo-matlab" class="level3">
<h3 class="anchored" data-anchor-id="interfaz-estilo-matlab">8.2.1 Interfaz estilo MATLAB</h3>
<p>Matplotlib se escribió originalmente como una alternativa de Python para los usuarios de MATLAB y gran parte de su sintaxis refleja ese hecho. Las herramientas de estilo MATLAB están contenidas en la interfaz pyplot (<code>plt</code>). Por ejemplo, el siguiente código probablemente resultará bastante familiar para los usuarios de MATLAB:</p>
<div id="c7228c80" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>plt.figure()  <span class="co"># crear una figura de trama</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Crea el primero de dos paneles y establece el eje actual.</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">1</span>) <span class="co"># (filas, columnas, número de panel)</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>plt.plot(x, np.sin(x))</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Crea el segundo panel y establece el eje actual.</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">2</span>)</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>plt.plot(x, np.cos(x))</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Es importante tener en cuenta que esta interfaz es <em>con estado</em>: realiza un seguimiento de la figura y los ejes ‘actuales’, que es donde se aplican todos los comandos <code>plt</code>. Puede obtener una referencia a estos utilizando las rutinas <code>plt.gcf()</code> (obtener la figura actual) y <code>plt.gca()</code> (obtener los ejes actuales).</p>
<p>Si bien esta interfaz con estado es rápida y conveniente para gráficos simples, es fácil tener problemas. Por ejemplo, una vez creado el segundo panel, ¿cómo podemos volver atrás y agregar algo al primero? Esto es posible dentro de la interfaz de estilo MATLAB, pero es un poco complicado. Afortunadamente, existe una manera más <em>pythonica</em>.</p>
</section>
<section id="interfaz-orientada-a-objetos" class="level3">
<h3 class="anchored" data-anchor-id="interfaz-orientada-a-objetos">8.2.2 Interfaz orientada a objetos</h3>
<p>La interfaz orientada a objetos está disponible para estas situaciones más complicadas y para cuando quieras tener más control sobre tu figura. En lugar de depender de alguna noción de una figura o ejes ‘activos’, en la interfaz orientada a objetos las funciones de trazado son <em>métodos</em> de objetos explícitos <code>figure</code> y <code>axis</code>. Para recrear el gráfico anterior utilizando este estilo de trazado, puedes hacer lo siguiente:</p>
<div id="325d9c18" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Primero crea una cuadrícula de gráficas</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="co"># ax será una matriz de dos objetos Axes</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">2</span>)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Llamar al método plot() en el objeto apropiado</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].plot(x, np.sin(x))</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].plot(x, np.cos(x))</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Para gráficas más simples, la elección del estilo a utilizar es en gran medida una cuestión de preferencia, pero el enfoque orientado a objetos puede volverse una necesidad a medida que las gráficas se vuelven más complicadas. A lo largo de este capítulo, alternaremos entre las interfaces de estilo MATLAB y las orientadas a objetos, dependiendo de lo que sea más conveniente. En la mayoría de los casos, la diferencia es tan pequeña como cambiar <code>plt.plot()</code> a <code>ax.plot()</code>, pero hay algunos problemas que destacaremos a medida que surjan en las siguientes secciones.</p>
</section>
</section>
<section id="gráficos-de-líneas-simples" class="level2">
<h2 class="anchored" data-anchor-id="gráficos-de-líneas-simples">8.3 Gráficos de líneas simples</h2>
<p>Quizás el más simple de todos los gráficos es la visualización de una única función <span class="math inline">\(y = f(x)\)</span>. Aquí daremos un primer vistazo a la creación de un gráfico sencillo de este tipo. Comenzaremos configurando el <em>notebook</em> para graficar. Primero, examinemos los estilos de gráficos que tiene disponible Matplotlib:</p>
<div id="4bec5616-cadf-4ef5-9a95-1845299a3e8b" class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>mpl.style.available</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="6e5b39e6" class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>matplotlib inline</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>plt.style.use(<span class="st">'ggplot'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Para todos los gráficos de Matplotlib, comenzamos creando una figura y un eje. En su forma más simple, una figura y ejes se pueden crear de la siguiente manera:</p>
<div id="149c7a88" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> plt.axes()</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>En Matplotlib, la <em>figura</em> (una instancia de la clase <code>plt.Figure</code>) puede considerarse como un contenedor único que contiene todos los objetos que representan ejes, gráficos, texto y etiquetas. Los <em>ejes</em> (una instancia de la clase <code>plt.Axes</code>) son lo que vemos arriba: un cuadro delimitador con marcas y etiquetas, que eventualmente contendrá los elementos del gráfico que componen nuestra visualización. A lo largo de este <em>Notebook</em>, utilizaremos comúnmente el nombre de variable ‘fig’ para referirnos a una instancia de figura, y ‘ax’ para referirnos a una instancia de ejes o un grupo de instancias de ejes.</p>
<p>Una vez que hemos creado los ejes, podemos utilizar la función <code>ax.plot</code> para representar gráficamente algunos datos. Empecemos con una sinusoide simple:</p>
<div id="7b024828" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> plt.axes()</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">1000</span>)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>ax.plot(x, np.sin(x))<span class="op">;</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Si queremos crear una sola figura con varias líneas, simplemente podemos llamar a la función <code>plot</code> varias veces:</p>
<div id="b431d656" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>plt.plot(x, np.sin(x))</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>plt.plot(x, np.cos(x))<span class="op">;</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>¡Eso es todo lo que hay que saber para trazar funciones simples en Matplotlib! Ahora profundizaremos en algunos detalles más sobre cómo controlar la apariencia de los ejes y las líneas.</p>
<section id="ajuste-de-colores-y-estilos-de-línea" class="level3">
<h3 class="anchored" data-anchor-id="ajuste-de-colores-y-estilos-de-línea">8.3.1 Ajuste de colores y estilos de línea</h3>
<p>El primer ajuste que quizás desees realizar en un gráfico es controlar los colores y estilos de línea. La función <code>plt.plot()</code> toma argumentos adicionales que pueden usarse para especificarlos. Para ajustar el color, puede utilizar la palabra clave <code>color</code>, que acepta un argumento de cadena que representa prácticamente cualquier color imaginable. El color se puede especificar de varias maneras:</p>
<div id="8b5a18f0" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>plt.plot(x, np.sin(x <span class="op">-</span> <span class="dv">0</span>), color<span class="op">=</span><span class="st">'blue'</span>)        <span class="co"># especificar color por nombre</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>plt.plot(x, np.sin(x <span class="op">-</span> <span class="dv">1</span>), color<span class="op">=</span><span class="st">'g'</span>)           <span class="co"># código de color corto (rgbcmyk)</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>plt.plot(x, np.sin(x <span class="op">-</span> <span class="dv">2</span>), color<span class="op">=</span><span class="st">'0.35'</span>)        <span class="co"># Escala de grises entre 0 y 1</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>plt.plot(x, np.sin(x <span class="op">-</span> <span class="dv">3</span>), color<span class="op">=</span><span class="st">'#E15759'</span>)    <span class="co"># Código hexadecimal (RRGGBB de 00 a FF)</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>plt.plot(x, np.sin(x <span class="op">-</span> <span class="dv">4</span>), color<span class="op">=</span>(<span class="fl">1.0</span>,<span class="fl">0.5</span>,<span class="fl">0.3</span>)) <span class="co"># Tupla RGB, valores 0 a 1</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>plt.plot(x, np.sin(x <span class="op">-</span> <span class="dv">5</span>), color<span class="op">=</span><span class="st">'cyan'</span>)<span class="op">;</span> <span class="co"># Se admiten todos los nombres de colores HTML</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>plt.legend([<span class="st">'Línea 1'</span>, <span class="st">'Línea 2'</span>,<span class="st">'Línea 3'</span>,<span class="st">'Línea 4'</span>, <span class="st">'Línea 5'</span>,<span class="st">'Línea 6'</span>])</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Para una lista de los nombres de colores disponibles consulte la <a href="https://matplotlib.org/stable/gallery/color/named_colors.html">documentación</a>.</p>
<p>Si no se especifica ningún color, Matplotlib recorrerá automáticamente un conjunto de colores predeterminados para varias líneas.</p>
<p>De manera similar, el estilo de línea se puede ajustar utilizando la palabra clave <code>linestyle</code>:</p>
<div id="a6f984c4" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>plt.plot(x, x <span class="op">+</span> <span class="dv">0</span>, linestyle<span class="op">=</span><span class="st">'solid'</span>)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>plt.plot(x, x <span class="op">+</span> <span class="dv">1</span>, linestyle<span class="op">=</span><span class="st">'dashed'</span>)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>plt.plot(x, x <span class="op">+</span> <span class="dv">2</span>, linestyle<span class="op">=</span><span class="st">'dashdot'</span>)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>plt.plot(x, x <span class="op">+</span> <span class="dv">3</span>, linestyle<span class="op">=</span><span class="st">'dotted'</span>)<span class="op">;</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Para abreviar, puedes utilizar los siguientes códigos:</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>plt.plot(x, x <span class="op">+</span> <span class="dv">4</span>, linestyle<span class="op">=</span><span class="st">'-'</span>)  <span class="co"># sólido</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>plt.plot(x, x <span class="op">+</span> <span class="dv">5</span>, linestyle<span class="op">=</span><span class="st">'--'</span>) <span class="co"># discontinuo</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>plt.plot(x, x <span class="op">+</span> <span class="dv">6</span>, linestyle<span class="op">=</span><span class="st">'-.'</span>) <span class="co"># raya y punto</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>plt.plot(x, x <span class="op">+</span> <span class="dv">7</span>, linestyle<span class="op">=</span><span class="st">':'</span>)<span class="op">;</span>  <span class="co"># punteado</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Si desea ser extremadamente conciso, estos códigos <code>linestyle</code> y <code>color</code> se pueden combinar en un solo argumento que no sea una palabra clave para la función <code>plt.plot()</code>:</p>
<div id="90137fa1" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>plt.plot(x, x <span class="op">+</span> <span class="dv">0</span>, <span class="st">'-g'</span>)  <span class="co"># verde sólido</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>plt.plot(x, x <span class="op">+</span> <span class="dv">1</span>, <span class="st">'--c'</span>) <span class="co"># cian discontinuo</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>plt.plot(x, x <span class="op">+</span> <span class="dv">2</span>, <span class="st">'-.k'</span>) <span class="co"># raya negra</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>plt.plot(x, x <span class="op">+</span> <span class="dv">3</span>, <span class="st">':r'</span>)<span class="op">;</span>  <span class="co"># punteado rojo</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Estos códigos de color de un solo carácter reflejan las abreviaturas estándar de los sistemas de color RGB (rojo/verde/azul) y CMYK (cian/magenta/amarillo/negro), comúnmente utilizados para gráficos en color digitales.</p>
<p>Hay muchos otros argumentos de palabras clave que se pueden usar para ajustar la apariencia del gráfico; para obtener más detalles, sugiero revisar la <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html">documentación</a> de la función <code>plt.plot()</code>.</p>
</section>
<section id="ajuste-de-límites-de-los-ejes" class="level3">
<h3 class="anchored" data-anchor-id="ajuste-de-límites-de-los-ejes">8.3.2 Ajuste de límites de los ejes</h3>
<p>Matplotlib hace un buen trabajo al elegir los límites de ejes predeterminados para su gráfico, pero a veces es bueno tener un control más preciso. La forma más básica de ajustar los límites de los ejes es utilizar los métodos <code>plt.xlim()</code> y <code>plt.ylim()</code>:</p>
<div id="d6d196be" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>plt.plot(x, np.sin(x))</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>plt.xlim(<span class="op">-</span><span class="dv">1</span>, <span class="dv">11</span>)</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>plt.ylim(<span class="op">-</span><span class="fl">1.5</span>, <span class="fl">1.5</span>)</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Si por alguna razón desea que alguno de los ejes se muestre al revés, puede simplemente invertir el orden de los argumentos:</p>
<div id="ba31d2c8" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>plt.plot(x, np.sin(x))</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>plt.xlim(<span class="dv">10</span>, <span class="dv">0</span>)</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>plt.ylim(<span class="fl">1.2</span>, <span class="op">-</span><span class="fl">1.2</span>)</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Un método relacionado útil es <code>plt.axis()</code> (note aquí la posible confusión entre <em>axes</em> con una <em>e</em> y <em>axis</em> con una <em>i</em>). El método <code>plt.axis()</code> le permite establecer los límites <code>x</code> y <code>y</code> con una sola llamada, pasando una lista que especifica <code>[xmin, xmax, ymin, ymax]</code>:</p>
<div id="6bda8654" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>plt.plot(x, np.sin(x))</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>plt.axis([<span class="op">-</span><span class="dv">1</span>, <span class="dv">11</span>, <span class="op">-</span><span class="fl">1.5</span>, <span class="fl">1.5</span>])</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>El método <code>plt.axis()</code> va incluso más allá de esto, permitiéndole hacer cosas como ajustar automáticamente los límites alrededor del gráfico actual:</p>
<div id="f666b759" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>plt.plot(x, np.sin(x))</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>plt.axis(<span class="st">'tight'</span>)</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Permite especificaciones de nivel aún más alto, como garantizar una relación de aspecto igual para que en la pantalla, una unidad en «x» sea igual a una unidad en «y»:</p>
<div id="449e9593" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>plt.plot(x, np.sin(x))</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>plt.axis(<span class="st">'equal'</span>)</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Para obtener más información sobre los límites de los ejes y otras capacidades del método <code>plt.axis</code>, consulte su <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.axis.html">documentación</a>.</p>
</section>
<section id="etiquetas" class="level3">
<h3 class="anchored" data-anchor-id="etiquetas">8.3.4 Etiquetas</h3>
<p>Como última parte de esta sección, veremos brevemente el etiquetado de los gráficos: títulos, etiquetas de ejes y leyendas simples.</p>
<p>Los títulos y las etiquetas de los ejes son las etiquetas más simples; existen métodos que se pueden usar para configurarlas rápidamente:</p>
<div id="bed9e162" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>plt.plot(x, np.sin(x))</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Curva seno'</span>)</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'x'</span>)</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'sen(x)'</span>)</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>La posición, el tamaño y el estilo de estas etiquetas se pueden ajustar utilizando argumentos opcionales para la función. Para obtener más información, consulte la documentación de Matplotlib .</p>
<p>Cuando se muestran varias líneas dentro de un solo eje, puede ser útil crear una leyenda de gráfico que etiquete cada tipo de línea. Nuevamente, Matplotlib tiene una forma incorporada de crear rápidamente dicha leyenda. Esto se hace a través del método (lo adivinaste) <code>plt.legend()</code>. Si bien existen varias formas válidas de utilizar esto, me resulta más fácil especificar la etiqueta de cada línea utilizando la palabra clave <code>label</code> de la función plot:</p>
<div id="c985f43d" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>plt.plot(x, np.sin(x), <span class="st">'-g'</span>, label<span class="op">=</span><span class="st">'sin(x)'</span>)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>plt.plot(x, np.cos(x), <span class="st">':b'</span>, label<span class="op">=</span><span class="st">'cos(x)'</span>)</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>plt.axis(<span class="st">'equal'</span>)</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Como puede ver, la función <code>plt.legend()</code> realiza un seguimiento del estilo y el color de la línea y los combina con la etiqueta correcta. Puede encontrar más información sobre cómo especificar y formatear leyendas de gráficos en la documentación <code>plt.legend</code>.</p>
<p>Adicionalmente, Matplotlib permite establecer etiquetas y leyendas usando intérprete de LateX:</p>
<div id="185e1fda-8835-45fd-9383-d096a1f41678" class="cell">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>plt.plot(x, np.sin(x), <span class="st">'--g'</span>, label<span class="op">=</span><span class="vs">r'$\sin(x)$'</span>)</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>plt.plot(x, np.cos(x), <span class="st">'-.b'</span>, label<span class="op">=</span><span class="vs">r'$\cos(x)$'</span>)</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>plt.axis(<span class="st">'equal'</span>)</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>plt.xticks(fontsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>plt.yticks(fontsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>plt.legend(fontsize<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="problemas-con-matplotlib" class="level3">
<h3 class="anchored" data-anchor-id="problemas-con-matplotlib">8.3.5Problemas con Matplotlib</h3>
<p>Si bien la mayoría de las funciones <code>plt</code> se traducen directamente a métodos <code>ax</code> (como <code>plt.plot()</code> → <code>ax.plot()</code>, <code>plt.legend()</code> → <code>ax.legend()</code>, etc.), este no es el caso de todos los comandos. En particular, se modifican ligeramente las funciones para establecer límites, etiquetas y títulos. Para realizar la transición entre funciones de estilo MATLAB y métodos orientados a objetos, realice los siguientes cambios:</p>
<ul>
<li><code>plt.xlabel()</code> → <code>ax.set_xlabel()</code></li>
<li><code>plt.ylabel()</code> → <code>ax.set_ylabel()</code></li>
<li><code>plt.xlim()</code> → <code>ax.set_xlim()</code></li>
<li><code>plt.ylim()</code> → <code>ax.set_ylim()</code></li>
<li><code>plt.title()</code> → <code>ax.set_title()</code></li>
</ul>
<p>En la interfaz orientada a objetos para trazar gráficos, en lugar de llamar a estas funciones individualmente, a menudo es más conveniente utilizar el método <code>ax.set()</code> para configurar todas estas propiedades a la vez:</p>
<div id="ab3199e1" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> plt.axes()</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>ax.plot(x, np.sin(x))</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>ax.<span class="bu">set</span>(xlim<span class="op">=</span>(<span class="dv">0</span>, <span class="dv">10</span>), ylim<span class="op">=</span>(<span class="op">-</span><span class="dv">2</span>, <span class="dv">2</span>),</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>       xlabel<span class="op">=</span><span class="st">'$x$'</span>, ylabel<span class="op">=</span><span class="vs">r'$\sin(x)$'</span>,</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>       title<span class="op">=</span><span class="st">'Gráfica simple'</span>)</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="diagramas-de-dispersión-simples" class="level2">
<h2 class="anchored" data-anchor-id="diagramas-de-dispersión-simples">8.4 Diagramas de dispersión simples</h2>
<p>Otro tipo de gráfico comúnmente utilizado es el gráfico de dispersión simple, un primo cercano del gráfico lineal. En lugar de unir los puntos mediante segmentos de línea, aquí los puntos se representan individualmente con un punto, un círculo u otra forma.</p>
<section id="diagramas-de-dispersión-con-plt.plot" class="level3">
<h3 class="anchored" data-anchor-id="diagramas-de-dispersión-con-plt.plot">8.4.1 Diagramas de dispersión con <code>plt.plot</code></h3>
<p>En la sección anterior, analizamos <code>plt.plot</code>/<code>ax.plot</code> para producir gráficos lineales. Resulta que esta misma función también puede producir gráficos de dispersión:</p>
<div id="854a8232" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">30</span>)</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> np.sin(x)</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>plt.plot(x, y, <span class="st">'ok'</span>)</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>El tercer argumento en la llamada de función es un carácter que representa el tipo de símbolo utilizado para el gráfico. Así como se pueden especificar opciones como <code>'-'</code>, <code>'--'</code> para controlar el estilo de línea, el estilo de marcador tiene su propio conjunto de códigos de cadena cortos. La lista completa de símbolos disponibles se puede ver en la documentación de <code>plt.plot</code>, o en la documentación en línea de Matplotlib. La mayoría de las posibilidades son bastante intuitivas, y aquí mostraremos algunas de las más comunes:</p>
<div id="9ecc223e" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>rng <span class="op">=</span> np.random.RandomState(<span class="dv">0</span>)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">12</span>,<span class="dv">6</span>))</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> marker <span class="kw">in</span> [<span class="st">'o'</span>, <span class="st">'.'</span>, <span class="st">','</span>, <span class="st">'x'</span>, <span class="st">'+'</span>, <span class="st">'v'</span>, <span class="st">'^'</span>, <span class="st">'&lt;'</span>, <span class="st">'&gt;'</span>, <span class="st">'s'</span>, <span class="st">'d'</span>]:</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>    plt.plot(rng.rand(<span class="dv">5</span>), rng.rand(<span class="dv">5</span>), marker,</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>             label<span class="op">=</span><span class="ss">f'marker=</span><span class="sc">{</span>marker<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>plt.legend(loc<span class="op">=</span><span class="st">'center left'</span>, bbox_to_anchor<span class="op">=</span>(<span class="dv">1</span>, <span class="fl">0.5</span>),numpoints<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>plt.xlim(<span class="dv">0</span>, <span class="fl">1.1</span>)</span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Para obtener aún más posibilidades, estos códigos de caracteres se pueden utilizar junto con códigos de línea y color para trazar puntos junto con una línea que los conecta:</p>
<div id="f7caa30f" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>plt.plot(x, y, <span class="st">'-ok'</span>)</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Los argumentos de palabras clave adicionales a <code>plt.plot</code> especifican una amplia gama de propiedades de las líneas y marcadores:</p>
<div id="53e3af1b" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>plt.plot(x, y, <span class="st">'-p'</span>, color<span class="op">=</span><span class="st">'gray'</span>,</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>         markersize<span class="op">=</span><span class="dv">12</span>, linewidth<span class="op">=</span><span class="dv">4</span>,</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>         markerfacecolor<span class="op">=</span><span class="st">'cyan'</span>,</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>         markeredgecolor<span class="op">=</span><span class="st">'gray'</span>,</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>         markeredgewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>plt.ylim(<span class="op">-</span><span class="fl">1.2</span>, <span class="fl">1.2</span>)</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Este tipo de flexibilidad en la función <code>plt.plot</code> permite una amplia variedad de posibles opciones de visualización. Para obtener una descripción completa de las opciones disponibles, consulte la documentación de <code>plt.plot</code>.</p>
</section>
<section id="diagramas-de-dispersión-con-plt.scatter" class="level3">
<h3 class="anchored" data-anchor-id="diagramas-de-dispersión-con-plt.scatter">8.4.2 Diagramas de dispersión con <code>plt.scatter</code></h3>
<p>Un segundo método más potente para crear gráficos de dispersión es la función <code>plt.scatter</code>, que se puede utilizar de forma muy similar a la función <code>plt.plot</code>:</p>
<div id="5a0627e8" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>plt.scatter(x, y, marker<span class="op">=</span><span class="st">'o'</span>)</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>La principal diferencia entre <code>plt.scatter</code> y <code>plt.plot</code> es que se puede utilizar para crear gráficos de dispersión donde las propiedades de cada punto individual (tamaño, color de la cara, color del borde, etc.) se pueden controlar individualmente o asignar a los datos.</p>
<p>Demostremos esto creando un gráfico de dispersión aleatorio con puntos de muchos colores y tamaños. Para ver mejor los resultados superpuestos, también usaremos la palabra clave <code>alpha</code> para ajustar el nivel de transparencia:</p>
<div id="5efd1dc1" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>rng <span class="op">=</span> np.random.RandomState(<span class="dv">0</span>)</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> rng.randn(<span class="dv">100</span>)</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> rng.randn(<span class="dv">100</span>)</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> rng.rand(<span class="dv">100</span>)</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>sizes <span class="op">=</span> <span class="dv">1000</span> <span class="op">*</span> rng.rand(<span class="dv">100</span>)</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">12</span>,<span class="dv">12</span>))</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>plt.scatter(x, y, c<span class="op">=</span>colors, s<span class="op">=</span>sizes, alpha<span class="op">=</span><span class="fl">0.5</span>,</span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>            cmap<span class="op">=</span><span class="st">'inferno'</span>)</span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>plt.colorbar()</span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Tenga en cuenta que el argumento de color se asigna automáticamente a una escala de color (mostrada aquí por el comando <code>colorbar()</code>) y que el argumento de tamaño se da en píxeles. De esta manera, el color y el tamaño de los puntos se pueden utilizar para transmitir información en la visualización, con el fin de visualizar datos multidimensionales.</p>
<p>Por ejemplo, podríamos utilizar los datos de Iris de Scikit-Learn, donde cada muestra es uno de los tres tipos de flores a las que se les ha medido cuidadosamente el tamaño de sus pétalos y sépalos:</p>
<div id="62dee087" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.datasets <span class="im">import</span> load_iris</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>iris <span class="op">=</span> load_iris()</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>features <span class="op">=</span> iris.data.T</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>plt.scatter(features[<span class="dv">0</span>], features[<span class="dv">1</span>], alpha<span class="op">=</span><span class="fl">0.6</span>,</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>            s<span class="op">=</span><span class="dv">200</span><span class="op">*</span>features[<span class="dv">2</span>], c<span class="op">=</span>iris.target, cmap<span class="op">=</span><span class="st">'magma'</span>)</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>plt.xlabel(iris.feature_names[<span class="dv">0</span>])</span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>plt.ylabel(iris.feature_names[<span class="dv">1</span>])</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Podemos ver que este diagrama de dispersión nos ha dado la capacidad de explorar simultáneamente cuatro dimensiones diferentes de los datos: La ubicación <span class="math inline">\((x, y)\)</span> de cada punto corresponde a la longitud y el ancho del sépalo, el tamaño del punto está relacionado con el largo del pétalo y el color está relacionado con la especie particular de flor. Los gráficos de dispersión multicolores y de múltiples características como éste pueden ser útiles tanto para la exploración como para la presentación de datos.</p>
</section>
<section id="plot-versus-scatter-una-nota-sobre-la-eficiencia" class="level3">
<h3 class="anchored" data-anchor-id="plot-versus-scatter-una-nota-sobre-la-eficiencia">8.4.3 <code>plot</code> versus <code>scatter</code>: una nota sobre la eficiencia</h3>
<p>Además de las diferentes funciones disponibles en <code>plt.plot</code> y <code>plt.scatter</code>, ¿por qué elegiría utilizar uno en lugar del otro? Si bien no es tan importante para pequeñas cantidades de datos, a medida que los conjuntos de datos se hacen más grandes que unos pocos miles de puntos, <code>plt.plot</code> puede ser notablemente más eficiente que <code>plt.scatter</code>. La razón es que <code>plt.scatter</code> tiene la capacidad de renderizar un tamaño y/o color diferente para cada punto, por lo que el renderizador debe hacer el trabajo adicional de construir cada punto individualmente. En <code>plt.plot</code>, por otro lado, los puntos son siempre esencialmente clones unos de otros, por lo que el trabajo de determinar la apariencia de los puntos se realiza solo una vez para todo el conjunto de datos. Para conjuntos de datos grandes, la diferencia entre estos dos puede generar un rendimiento muy diferente y, por este motivo, se debería preferir <code>plt.plot</code> sobre <code>plt.scatter</code> para conjuntos de datos grandes.</p>
</section>
</section>
<section id="visualizando-errores" class="level2">
<h2 class="anchored" data-anchor-id="visualizando-errores">8.5 Visualizando errores</h2>
<p>En cualquier medición científica, la contabilización precisa de los errores es casi tan importante, si no más, que la información precisa del número en sí. Por ejemplo, imaginemos que tenemos algunas observaciones astrofísicas para estimar la Constante de Hubble, la medida local de la tasa de expansión del Universo.</p>
<p>Sé que la literatura actual sugiere un valor de alrededor de 71 (km/s)/Mpc, y mido un valor de 74 (km/s)/Mpc con mi método. ¿Son consistentes los valores? La única respuesta correcta, dada esta información, es esta: no hay forma de saberlo.</p>
<p>Supongamos que amplío esta información con las incertidumbres reportadas: la literatura actual sugiere un valor de alrededor de 71 <span class="math inline">\(\pm\)</span> 2.5 (km/s)/Mpc, y mi método ha medido un valor de 74 <span class="math inline">\(\pm\)</span> 5 (km/s)/Mpc. Ahora bien, ¿son consistentes los valores? Esa es una pregunta que puede responderse cuantitativamente.</p>
<p>En la visualización de datos y resultados, mostrar estos errores de manera efectiva puede hacer que un gráfico transmita información mucho más completa.</p>
<p>Se puede crear una barra de error básica con una sola llamada a la función Matplotlib:</p>
<div id="a879b0f9" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">50</span>)</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>dy <span class="op">=</span> <span class="fl">0.1</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> np.sin(x) <span class="op">+</span> dy <span class="op">*</span> np.random.randn(<span class="dv">50</span>)</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>plt.errorbar(x, y, yerr<span class="op">=</span>dy, fmt<span class="op">=</span><span class="st">'.k'</span>)</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Aquí, <code>fmt</code> es un código de formato que controla la apariencia de líneas y puntos, y tiene la misma sintaxis que la abreviatura utilizada en <code>plt.plot</code>.</p>
<p>Además de estas opciones básicas, la función <code>errorbar</code> tiene muchas opciones para ajustar las salidas. Usando estas opciones adicionales puedes personalizar fácilmente la estética de tu gráfico con barras de error.</p>
<div id="a591ff5e" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>plt.errorbar(x, y, yerr<span class="op">=</span>dy, fmt<span class="op">=</span><span class="st">'o'</span>, color<span class="op">=</span><span class="st">'red'</span>,</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>             ecolor<span class="op">=</span><span class="st">'darkgray'</span>, elinewidth<span class="op">=</span><span class="dv">3</span>, capsize<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Además de estas opciones, también puede especificar barras de error horizontales (<code>xerr</code>), barras de error unilaterales y muchas otras variantes. Para obtener más información sobre las opciones disponibles, consulte la documentación de <code>plt.errorbar</code>.</p>
</section>
<section id="gráficas-de-densidad-y-contorno" class="level2">
<h2 class="anchored" data-anchor-id="gráficas-de-densidad-y-contorno">8.6 Gráficas de densidad y contorno</h2>
<p>A veces es útil mostrar datos tridimensionales en dos dimensiones utilizando contornos o regiones codificadas por colores. Hay tres funciones de Matplotlib que pueden ser útiles para esta tarea: <code>plt.contour</code> para gráficos de contorno, <code>plt.contourf</code> para gráficos de contorno rellenos y <code>plt.imshow</code> para mostrar imágenes.</p>
<p>Comenzaremos demostrando un gráfico de contorno usando una función <span class="math inline">\(z = f(x, y)\)</span>, usando la siguiente opción particular para <span class="math inline">\(f\)</span>:</p>
<div id="6387de06-4847-41a9-a862-d307d870e675" class="cell">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f(x, y):</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.sin(x) <span class="op">**</span> <span class="dv">10</span> <span class="op">+</span> np.cos(<span class="dv">10</span> <span class="op">+</span> y <span class="op">*</span> x) <span class="op">*</span> np.cos(x)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Se puede crear un gráfico de contorno con la función <code>plt.contour</code>. Toma tres argumentos: una cuadrícula de valores <em>x</em>, una cuadrícula de valores <em>y</em> y una cuadrícula de valores <em>z</em>. Los valores <em>x</em> e <em>y</em> representan posiciones en el gráfico, y los valores <em>z</em> estarán representados por los niveles de contorno. Quizás la forma más sencilla de preparar dichos datos es utilizar la función <code>np.meshgrid</code>, que construye cuadrículas bidimensionales a partir de matrices unidimensionales:</p>
<div id="0a40127a" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">5</span>, <span class="dv">50</span>)</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">5</span>, <span class="dv">40</span>)</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>X, Y <span class="op">=</span> np.meshgrid(x, y)</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>Z <span class="op">=</span> f(X, Y)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Ahora veamos esto con un gráfico de contorno de solo líneas estándar:</p>
<div id="f00235a8" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>plt.contour(X, Y, Z, colors<span class="op">=</span><span class="st">'black'</span>)</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Tenga en cuenta que, de forma predeterminada, cuando se utiliza un solo color, los valores negativos se representan mediante líneas discontinuas y los valores positivos, mediante líneas continuas. Alternativamente, las líneas pueden codificarse por colores especificando un mapa de colores con el argumento <code>cmap</code>. Aquí también especificaremos que queremos que se dibujen más líneas: 20 intervalos igualmente espaciados dentro del rango de datos:</p>
<div id="24e370ed" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>plt.contour(X, Y, Z, <span class="dv">20</span>, cmap<span class="op">=</span><span class="st">'RdGy'</span>)</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Aquí elegimos el mapa de colores «RdGy» (abreviatura de <em>Rojo-Gris</em>), que es una buena opción para datos centrados. Matplotlib tiene una amplia gama de mapas de colores disponibles, que puedes explorar fácilmente en IPython completando una tabulación en el módulo <code>plt.cm</code>:</p>
<pre><code>plt.cm.&lt;TAB&gt;</code></pre>
<p>Nuestra gráfica se ve mejor, pero los espacios entre las líneas pueden distraer un poco. Podemos cambiar esto cambiando a un gráfico de contorno relleno usando la función <code>plt.contourf()</code> (observe la <code>f</code> al final), que utiliza en gran medida la misma sintaxis que <code>plt.contour()</code>.</p>
<p>Además, agregaremos un comando <code>plt.colorbar()</code>, que crea automáticamente un eje adicional con información de color etiquetada para el gráfico:</p>
<div id="728c8088" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>plt.contourf(X, Y, Z, <span class="dv">20</span>, cmap<span class="op">=</span><span class="st">'RdGy'</span>)</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>plt.colorbar()</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>La barra de colores deja claro que las regiones negras son ‘picos’, mientras que las regiones rojas son ‘valles’.</p>
<p>Un problema potencial con este gráfico es que es un poco irregular, es decir, los pasos de color son discretos en lugar de continuos, lo que no siempre es lo deseado. Esto se podría remediar estableciendo el número de contornos en un número muy alto, pero el resultado es un gráfico bastante ineficiente: Matplotlib debe representar un nuevo polígono para cada paso del nivel. Una mejor manera de manejar esto es usar la función <code>plt.imshow()</code>, que interpreta una cuadrícula bidimensional de datos como una imagen.</p>
<p>El siguiente código lo muestra:</p>
<div id="a8f2a71c" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>plt.imshow(Z, extent<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">5</span>, <span class="dv">0</span>, <span class="dv">5</span>], origin<span class="op">=</span><span class="st">'lower'</span>,cmap<span class="op">=</span><span class="st">'RdGy'</span>)</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>plt.colorbar()</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>plt.axis()</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Sin embargo, existen algunos problemas potenciales con <code>imshow()</code>:</p>
<ul>
<li><code>plt.imshow()</code> no acepta una cuadrícula <em>x</em> e <em>y</em>, por lo que debe especificar manualmente la <em>extensión</em> [<em>xmin</em>, <em>xmax</em>, <em>ymin</em>, <em>ymax</em>] de la imagen en el gráfico.</li>
<li><code>plt.imshow()</code> sigue de manera predeterminada la definición de matriz de imágenes estándar, donde el origen está en la esquina superior izquierda, no en la esquina inferior izquierda como en la mayoría de los gráficos de contorno. Esto se debe cambiar cuando se muestran datos en cuadrícula.</li>
</ul>
<p>Por último, a veces puede resultar útil combinar gráficos de contorno y gráficos de imágenes. Por ejemplo, aquí utilizaremos una imagen de fondo parcialmente transparente (con la transparencia establecida a través del parámetro <code>alpha</code>) y superpondremos los contornos con etiquetas en los contornos mismos (utilizando la función <code>plt.clabel()</code>):</p>
<div id="365bb66d" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>contours <span class="op">=</span> plt.contour(X, Y, Z, <span class="dv">3</span>, colors<span class="op">=</span><span class="st">'black'</span>)</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>plt.clabel(contours, inline<span class="op">=</span><span class="va">True</span>, fontsize<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>plt.imshow(Z, extent<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">5</span>, <span class="dv">0</span>, <span class="dv">5</span>], origin<span class="op">=</span><span class="st">'lower'</span>,</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>           cmap<span class="op">=</span><span class="st">'RdGy'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>plt.colorbar()</span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>La combinación de estas tres funciones (<code>plt.contour</code>, <code>plt.contourf</code> y <code>plt.imshow</code>) ofrece posibilidades casi ilimitadas para mostrar este tipo de datos tridimensionales dentro de un gráfico bidimensional.</p>
</section>
<section id="histogramas-binnings-y-densidad" class="level2">
<h2 class="anchored" data-anchor-id="histogramas-binnings-y-densidad">8.7 Histogramas, binnings y densidad</h2>
<p>Un histograma simple puede ser un gran primer paso para comprender un conjunto de datos.</p>
<div id="4d128f64-4555-4e68-99a2-be1f52a8c1af" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> np.random.randn(<span class="dv">1000</span>)</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>plt.hist(data)</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>La función <code>hist()</code> tiene muchas opciones para ajustar tanto el cálculo como la visualización; He aquí un ejemplo de un histograma más personalizado:</p>
<div id="0edfc1c4" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>plt.hist(data, bins<span class="op">=</span><span class="dv">30</span>, density<span class="op">=</span><span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.5</span>,</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>         histtype<span class="op">=</span><span class="st">'stepfilled'</span>, color<span class="op">=</span><span class="st">'steelblue'</span>,</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>         edgecolor<span class="op">=</span><span class="st">'none'</span>)</span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>La cadena de documentación <code>plt.hist</code> tiene más información sobre otras opciones de personalización disponibles.</p>
<div id="5e21a6f1" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>x1 <span class="op">=</span> np.random.normal(<span class="dv">0</span>, <span class="fl">0.8</span>, <span class="dv">1000</span>)</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>x2 <span class="op">=</span> np.random.normal(<span class="op">-</span><span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">1000</span>)</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>x3 <span class="op">=</span> np.random.normal(<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">1000</span>)</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>kwargs <span class="op">=</span> <span class="bu">dict</span>(histtype<span class="op">=</span><span class="st">'stepfilled'</span>, alpha<span class="op">=</span><span class="fl">0.3</span>, density<span class="op">=</span><span class="va">False</span>, bins<span class="op">=</span><span class="dv">40</span>)</span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>plt.hist(x1, <span class="op">**</span>kwargs)</span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a>plt.hist(x2, <span class="op">**</span>kwargs)</span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>plt.hist(x3, <span class="op">**</span>kwargs)</span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="histogramas-y-binnings-bidimensionales" class="level3">
<h3 class="anchored" data-anchor-id="histogramas-y-binnings-bidimensionales">8.7.1 Histogramas y binnings bidimensionales</h3>
<p>Así como creamos histogramas en una dimensión dividiendo la línea numérica en contenedores, también podemos crear histogramas en dos dimensiones dividiendo puntos entre contenedores bidimensionales. Echaremos un vistazo breve a varias formas de hacer esto aquí. Comenzaremos definiendo algunos datos: una matriz extraída de una distribución gaussiana multivariada:</p>
<div id="bfe03566" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>mean <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">0</span>]</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>cov <span class="op">=</span> [[<span class="dv">1</span>, <span class="dv">1</span>], [<span class="dv">1</span>, <span class="dv">2</span>]]</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>x, y <span class="op">=</span> np.random.multivariate_normal(mean, cov, <span class="dv">10000</span>).T</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="plt.hist2d-histograma-bidimensional" class="level4">
<h4 class="anchored" data-anchor-id="plt.hist2d-histograma-bidimensional"><code>plt.hist2d</code>: Histograma bidimensional</h4>
<p>Una forma sencilla de trazar un histograma bidimensional es utilizar la función <code>plt.hist2d</code> de Matplotlib:</p>
<div id="4f4e6de8" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>plt.hist2d(x, y, bins<span class="op">=</span><span class="dv">30</span>, cmap<span class="op">=</span><span class="st">'Blues'</span>)</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>cb <span class="op">=</span> plt.colorbar()</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>cb.set_label(<span class="st">'Frecuencia'</span>)</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Al igual que con <code>plt.hist</code>, <code>plt.hist2d</code> tiene una serie de opciones adicionales para ajustar el gráfico y el binning, que están muy bien delineadas en la cadena de documentación de la función.</p>
</section>
<section id="plt.hexbin-agrupamientos-hexagonales" class="level4">
<h4 class="anchored" data-anchor-id="plt.hexbin-agrupamientos-hexagonales"><code>plt.hexbin</code>: Agrupamientos hexagonales</h4>
<p>El histograma bidimensional crea una teselación de cuadrados a lo largo de los ejes. Otra forma natural para tal teselación es el hexágono regular. Para este propósito, Matplotlib proporciona la rutina <code>plt.hexbin</code>, que representará un conjunto de datos bidimensionales agrupados dentro de una cuadrícula de hexágonos:</p>
<div id="d2f97948" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>plt.hexbin(x, y, gridsize<span class="op">=</span><span class="dv">30</span>, cmap<span class="op">=</span><span class="st">'Blues'</span>)</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>cb <span class="op">=</span> plt.colorbar(label<span class="op">=</span><span class="st">'Frecuencia'</span>)</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><code>plt.hexbin</code> tiene varias opciones interesantes, incluida la capacidad de especificar pesos para cada punto y cambiar la salida en cada contenedor a cualquier agregado NumPy (media de pesos, desviación estándar de pesos, etc.).</p>
</section>
</section>
</section>
<section id="personalización-de-leyendas" class="level2">
<h2 class="anchored" data-anchor-id="personalización-de-leyendas">8.8 Personalización de leyendas</h2>
<p>Las leyendas de la gráfica dan significado a una visualización, asignando significado a los diversos elementos de la trama.</p>
<p>Anteriormente vimos cómo crear una leyenda simple; aquí veremos cómo personalizar la ubicación y la estética de la leyenda en Matplotlib.</p>
<p>La leyenda más simple se puede crear con el comando <code>plt.legend()</code>, que crea automáticamente una leyenda para cualquier elemento gráfico etiquetado:</p>
<div id="119ce7da" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">1000</span>)</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>ax.plot(x, np.sin(x), <span class="st">'-b'</span>, label<span class="op">=</span><span class="st">'Seno'</span>)</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>ax.plot(x, np.cos(x), <span class="st">'--r'</span>, label<span class="op">=</span><span class="st">'Coseno'</span>)</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>ax.axis(<span class="st">'equal'</span>)</span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>leg <span class="op">=</span> ax.legend()</span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Pero hay muchas formas en las que podríamos personalizar dicha leyenda. Por ejemplo, podemos especificar la ubicación y desactivar el marco:</p>
<div id="cada82a3" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>ax.legend(loc<span class="op">=</span><span class="st">'upper left'</span>, frameon<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>fig</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Podemos usar el comando <code>ncol</code> para especificar el número de columnas en la leyenda:</p>
<div id="0c86d5f5" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>ax.legend(frameon<span class="op">=</span><span class="va">False</span>, loc<span class="op">=</span><span class="st">'lower center'</span>, ncol<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>fig</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Podemos utilizar un cuadro redondeado (<code>fancybox</code>) o agregar una sombra, cambiar la transparencia (valor alfa) del marco o cambiar el relleno alrededor del texto:</p>
<div id="6be60b4c" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>ax.legend(fancybox<span class="op">=</span><span class="va">True</span>, framealpha<span class="op">=</span><span class="dv">1</span>, shadow<span class="op">=</span><span class="va">True</span>, borderpad<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>fig</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Para obtener más información sobre las opciones de leyenda disponibles, consulte la cadena de documentación <code>plt.legend</code>.</p>
<section id="elección-de-elementos-para-la-leyenda" class="level3">
<h3 class="anchored" data-anchor-id="elección-de-elementos-para-la-leyenda">8.8.1 Elección de elementos para la leyenda</h3>
<p>Como ya hemos visto, la leyenda incluye todos los elementos etiquetados por defecto. Si esto no es lo deseado, podemos ajustar qué elementos y etiquetas aparecen en la leyenda utilizando los objetos devueltos por los comandos de trazado. El comando <code>plt.plot()</code> puede crear varias líneas a la vez y devuelve una lista de instancias de líneas creadas. Al pasar cualquiera de estos a <code>plt.legend()</code> le indicaremos cuál identificar, junto con las etiquetas que nos gustaría especificar:</p>
<div id="64621ba9" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb55"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> np.sin(x[:, np.newaxis] <span class="op">+</span> np.pi <span class="op">*</span> np.arange(<span class="dv">0</span>, <span class="dv">2</span>, <span class="fl">0.5</span>))</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>lines <span class="op">=</span> plt.plot(x, y)</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>plt.legend(lines[:<span class="dv">2</span>], [<span class="st">'1°'</span>, <span class="st">'2°'</span>])</span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Generalmente, en la práctica encuentro que es más claro utilizar el primer método, aplicando etiquetas a los elementos del gráfico que desea mostrar en la leyenda:</p>
<div id="67bcb61d" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>plt.plot(x, y[:, <span class="dv">0</span>], label<span class="op">=</span><span class="st">'1°'</span>)</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>plt.plot(x, y[:, <span class="dv">1</span>], label<span class="op">=</span><span class="st">'2°'</span>)</span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>plt.plot(x, y[:, <span class="dv">2</span>:])</span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>plt.legend(framealpha<span class="op">=</span><span class="dv">1</span>, frameon<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Tenga en cuenta que, de forma predeterminada, la leyenda ignora todos los elementos sin un atributo <code>label</code> establecido y aquellas etiquetas que inician con <code>_</code></p>
</section>
<section id="leyenda-del-tamaño-de-los-puntos" class="level3">
<h3 class="anchored" data-anchor-id="leyenda-del-tamaño-de-los-puntos">8.8.2 Leyenda del tamaño de los puntos</h3>
<p>A veces, los valores predeterminados de la leyenda no son suficientes para la visualización dada. Por ejemplo, quizás esté utilizando el tamaño de los puntos para marcar ciertas características de los datos y desee crear una leyenda que refleje esto. A continuación se muestra un ejemplo en el que utilizaremos el tamaño de los puntos para indicar las poblaciones de las ciudades de California. Nos gustaría una leyenda que especifique la escala de los tamaños de los puntos, y lograremos esto trazando algunos datos etiquetados sin entradas:</p>
<div id="068f038d" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb57"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>    cities <span class="op">=</span> pd.read_csv(<span class="st">'california_cities.csv'</span>)</span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span>:</span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">!</span>curl <span class="op">-</span>O https:<span class="op">//</span>raw.githubusercontent.com<span class="op">/</span>jakevdp<span class="op">/</span>PythonDataScienceHandbook<span class="op">/</span>master<span class="op">/</span>notebooks_v1<span class="op">/</span>data<span class="op">/</span>california_cities.csv </span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>    cities <span class="op">=</span> pd.read_csv(<span class="st">'california_cities.csv'</span>)</span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Extraer los datos que nos interesan</span></span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a>lat, lon <span class="op">=</span> cities[<span class="st">'latd'</span>], cities[<span class="st">'longd'</span>]</span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true" tabindex="-1"></a>population, area <span class="op">=</span> cities[<span class="st">'population_total'</span>], cities[<span class="st">'area_total_km2'</span>]</span>
<span id="cb57-11"><a href="#cb57-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-12"><a href="#cb57-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Distribuye los puntos, usando tamaño y color pero sin etiqueta</span></span>
<span id="cb57-13"><a href="#cb57-13" aria-hidden="true" tabindex="-1"></a>plt.scatter(lon, lat, label<span class="op">=</span><span class="va">None</span>,</span>
<span id="cb57-14"><a href="#cb57-14" aria-hidden="true" tabindex="-1"></a>            c<span class="op">=</span>np.log10(population), cmap<span class="op">=</span><span class="st">'viridis'</span>,</span>
<span id="cb57-15"><a href="#cb57-15" aria-hidden="true" tabindex="-1"></a>            s<span class="op">=</span>area, linewidth<span class="op">=</span><span class="dv">0</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb57-16"><a href="#cb57-16" aria-hidden="true" tabindex="-1"></a>plt.axis(<span class="st">'equal'</span>)</span>
<span id="cb57-17"><a href="#cb57-17" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'longitude'</span>)</span>
<span id="cb57-18"><a href="#cb57-18" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'latitude'</span>)</span>
<span id="cb57-19"><a href="#cb57-19" aria-hidden="true" tabindex="-1"></a>plt.colorbar(label<span class="op">=</span><span class="st">'log$_</span><span class="sc">{10}</span><span class="st">$(population)'</span>)</span>
<span id="cb57-20"><a href="#cb57-20" aria-hidden="true" tabindex="-1"></a>plt.clim(<span class="dv">3</span>, <span class="dv">7</span>)</span>
<span id="cb57-21"><a href="#cb57-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-22"><a href="#cb57-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Aquí creamos una leyenda:</span></span>
<span id="cb57-23"><a href="#cb57-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Trazaremos listas vacías con el tamaño y la etiqueta deseados</span></span>
<span id="cb57-24"><a href="#cb57-24" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> area <span class="kw">in</span> [<span class="dv">100</span>, <span class="dv">300</span>, <span class="dv">500</span>]:</span>
<span id="cb57-25"><a href="#cb57-25" aria-hidden="true" tabindex="-1"></a>    plt.scatter([], [], c<span class="op">=</span><span class="st">'k'</span>, alpha<span class="op">=</span><span class="fl">0.3</span>, s<span class="op">=</span>area,</span>
<span id="cb57-26"><a href="#cb57-26" aria-hidden="true" tabindex="-1"></a>                label<span class="op">=</span><span class="bu">str</span>(area) <span class="op">+</span> <span class="st">' km$^2$'</span>)</span>
<span id="cb57-27"><a href="#cb57-27" aria-hidden="true" tabindex="-1"></a>plt.legend(scatterpoints<span class="op">=</span><span class="dv">1</span>, frameon<span class="op">=</span><span class="va">False</span>, labelspacing<span class="op">=</span><span class="dv">1</span>, title<span class="op">=</span><span class="st">'Área de la ciudad'</span>)</span>
<span id="cb57-28"><a href="#cb57-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-29"><a href="#cb57-29" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Ciudades de California: Área y Población'</span>)</span>
<span id="cb57-30"><a href="#cb57-30" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>La leyenda siempre hará referencia a algún objeto que esté en el gráfico, por lo que si queremos mostrar una forma particular, necesitaremos trazarla. En este caso, los objetos que queremos (círculos grises) no están en el gráfico, por lo que los falsificamos trazando listas vacías. Tenga en cuenta también que la leyenda solo enumera los elementos de la trama que tienen una etiqueta especificada.</p>
<p>Al trazar listas vacías, creamos objetos de trazado etiquetados que son recogidos por la leyenda, y ahora nuestra leyenda nos brinda información útil. Esta estrategia puede ser útil para crear visualizaciones más sofisticadas.</p>
</section>
<section id="leyendas-múltiples" class="level3">
<h3 class="anchored" data-anchor-id="leyendas-múltiples">8.8.3 Leyendas múltiples</h3>
<p>A veces, al diseñar un gráfico, es posible que desees agregar varias leyendas a los mismos ejes. Desafortunadamente, Matplotlib no lo hace fácil: a través de la interfaz estándar de «leyenda», solo es posible crear una única leyenda para todo el gráfico. Si intenta crear una segunda leyenda usando <code>plt.legend()</code> o <code>ax.legend()</code>, simplemente anulará la primera. Podemos solucionar esto creando un nuevo artista de leyendas desde cero y luego usando el método de nivel inferior <code>ax.add_artist()</code> para agregar manualmente el segundo artista a la gráfica:</p>
<div id="d6e6461a" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb58"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>lines <span class="op">=</span> []</span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>styles <span class="op">=</span> [<span class="st">'-'</span>, <span class="st">'--'</span>, <span class="st">'-.'</span>, <span class="st">':'</span>]</span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">1000</span>)</span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">4</span>):</span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a>    lines <span class="op">+=</span> ax.plot(x, np.sin(x <span class="op">-</span> i <span class="op">*</span> np.pi <span class="op">/</span> <span class="dv">2</span>),</span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a>                     styles[i], color<span class="op">=</span><span class="st">'black'</span>)</span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a>ax.axis(<span class="st">'equal'</span>)</span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Especifica las líneas y etiquetas de la primera leyenda.</span></span>
<span id="cb58-13"><a href="#cb58-13" aria-hidden="true" tabindex="-1"></a>ax.legend(lines[:<span class="dv">2</span>], [<span class="st">'line A'</span>, <span class="st">'line B'</span>],</span>
<span id="cb58-14"><a href="#cb58-14" aria-hidden="true" tabindex="-1"></a>          loc<span class="op">=</span><span class="st">'upper right'</span>, frameon<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb58-15"><a href="#cb58-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-16"><a href="#cb58-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Crea la segunda leyenda y agrega el artista manualmente.</span></span>
<span id="cb58-17"><a href="#cb58-17" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib.legend <span class="im">import</span> Legend</span>
<span id="cb58-18"><a href="#cb58-18" aria-hidden="true" tabindex="-1"></a>leg <span class="op">=</span> Legend(ax, lines[<span class="dv">2</span>:], [<span class="st">'line C'</span>, <span class="st">'line D'</span>],</span>
<span id="cb58-19"><a href="#cb58-19" aria-hidden="true" tabindex="-1"></a>             loc<span class="op">=</span><span class="st">'lower right'</span>, frameon<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb58-20"><a href="#cb58-20" aria-hidden="true" tabindex="-1"></a>ax.add_artist(leg)</span>
<span id="cb58-21"><a href="#cb58-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-22"><a href="#cb58-22" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Este es un vistazo a los objetos de artista de bajo nivel que componen cualquier gráfico de Matplotlib. Si examina el código fuente de <code>ax.legend()</code> (usando <code>ax.legend??</code>) verá que la función simplemente consiste en cierta lógica para crear un artista <code>Legend</code> adecuado, que luego se guarda en el atributo <code>legend_</code> y se agrega a la figura cuando se dibuja la trama.</p>
</section>
</section>
<section id="varias-subgráficas" class="level2">
<h2 class="anchored" data-anchor-id="varias-subgráficas">8.9 Varias subgráficas</h2>
<p>A veces es útil comparar diferentes vistas de datos una al lado de la otra. Para este fin, Matplotlib tiene el concepto de <em>subgráficas</em>: grupos de ejes más pequeños que pueden existir juntos dentro de una sola figura. Estas subgráficas pueden ser inserciones, cuadrículas de gráficas u otros diseños más complicados. En esta sección exploraremos cuatro rutinas para crearlas en Matplotlib.</p>
<section id="plt.axes" class="level3">
<h3 class="anchored" data-anchor-id="plt.axes">8.9.1 <code>plt.axes</code></h3>
<p>El método más básico para crear ejes es utilizar la función <code>plt.axes</code>. Como hemos visto anteriormente, de forma predeterminada esto crea un objeto de ejes estándar que llena toda la figura. <code>plt.axes</code> también toma un argumento opcional que es una lista de cuatro números en el sistema de coordenadas de la figura. Estos números representan <code>[izquierda, abajo, ancho, alto]</code> en el sistema de coordenadas de la figura, que va desde 0 en la parte inferior izquierda de la figura hasta 1 en la parte superior derecha de la figura.</p>
<p>Por ejemplo, podríamos crear un eje insertado en la esquina superior derecha de otro eje estableciendo la posición <em>x</em> e <em>y</em> en 0.65 (es decir, comenzando en el 65 % del ancho y el 65 % de la altura de la figura) y las extensiones <em>x</em> e <em>y</em> en 0.2 (es decir, el tamaño de los ejes es el 20 % del ancho y el 20 % de la altura de la figura):</p>
<div id="3ba27d01" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>ax1 <span class="op">=</span> plt.axes()  <span class="co"># ejes estándar</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>ax2 <span class="op">=</span> plt.axes([<span class="fl">0.65</span>, <span class="fl">0.65</span>, <span class="fl">0.2</span>, <span class="fl">0.2</span>])</span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>El equivalente de este comando dentro de la interfaz orientada a objetos es <code>fig.add_axes()</code>. Usémoslo para crear dos ejes apilados verticalmente:</p>
<div id="2426dea2" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>ax1 <span class="op">=</span> fig.add_axes([<span class="fl">0.1</span>, <span class="fl">0.5</span>, <span class="fl">0.8</span>, <span class="fl">0.4</span>],</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>                   xticklabels<span class="op">=</span>[], ylim<span class="op">=</span>(<span class="op">-</span><span class="fl">1.2</span>, <span class="fl">1.2</span>))</span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>ax2 <span class="op">=</span> fig.add_axes([<span class="fl">0.1</span>, <span class="fl">0.1</span>, <span class="fl">0.8</span>, <span class="fl">0.4</span>],</span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a>                   ylim<span class="op">=</span>(<span class="op">-</span><span class="fl">1.2</span>, <span class="fl">1.2</span>))</span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">10</span>)</span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a>ax1.plot(np.sin(x))</span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true" tabindex="-1"></a>ax2.plot(np.cos(x))</span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="plt.subplot" class="level3">
<h3 class="anchored" data-anchor-id="plt.subplot">8.9.2 <code>plt.subplot</code></h3>
<p>Las columnas o filas alineadas de subgráficas son una necesidad bastante común, por lo que Matplotlib tiene varias rutinas convenientes que facilitan su creación. El nivel más bajo de estos es <code>plt.subplot()</code>, que crea una única subgráfica dentro de una cuadrícula. Como puede ver, este comando toma tres argumentos enteros: el número de filas, el número de columnas y el índice del gráfico que se creará en este esquema, que va desde la esquina superior izquierda hasta la esquina inferior derecha:</p>
<div id="21989a3d" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">7</span>):</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>    plt.subplot(<span class="dv">2</span>, <span class="dv">3</span>, i)</span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>    plt.text(<span class="fl">0.5</span>, <span class="fl">0.5</span>, <span class="bu">str</span>((<span class="dv">2</span>, <span class="dv">3</span>, i)),</span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>             fontsize<span class="op">=</span><span class="dv">18</span>, ha<span class="op">=</span><span class="st">'center'</span>)</span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>El comando <code>plt.subplots_adjust</code> se puede utilizar para ajustar el espaciado entre estos gráficos. El siguiente código utiliza el comando orientado a objetos equivalente, <code>fig.add_subplot()</code>:</p>
<div id="08fab294" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb62"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>fig.subplots_adjust(hspace<span class="op">=</span><span class="fl">0.4</span>, wspace<span class="op">=</span><span class="fl">0.4</span>)</span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">7</span>):</span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>    ax <span class="op">=</span> fig.add_subplot(<span class="dv">2</span>, <span class="dv">3</span>, i)</span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>    ax.text(<span class="fl">0.5</span>, <span class="fl">0.5</span>, <span class="bu">str</span>((<span class="dv">2</span>, <span class="dv">3</span>, i)),</span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a>           fontsize<span class="op">=</span><span class="dv">18</span>, ha<span class="op">=</span><span class="st">'center'</span>)</span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Hemos utilizado los argumentos <code>hspace</code> y <code>wspace</code> de <code>plt.subplots_adjust</code>, que especifican el espaciado a lo largo de la altura y el ancho de la figura, en unidades del tamaño de la subgráfica (en este caso, el espacio es el 40% de la altura y el ancho de la subgráfica).</p>
</section>
<section id="plt.subplots" class="level3">
<h3 class="anchored" data-anchor-id="plt.subplots">8.9.3 <code>plt.subplots</code></h3>
<p>El enfoque que acabamos de describir puede resultar bastante tedioso al crear una cuadrícula grande de subgráficas, especialmente si desea ocultar las etiquetas de los ejes x e y en las gráficas internas. Para este propósito, <code>plt.subplots()</code> es la herramienta más fácil de usar (observe la <code>s</code> al final de <code>subplots</code>). En lugar de crear un solo subplot, esta función crea una cuadrícula completa de subplots en una sola línea y los devuelve en una matriz NumPy. Los argumentos son el número de filas y el número de columnas, junto con las palabras clave opcionales <code>sharex</code> y <code>sharey</code>, que le permiten especificar las relaciones entre diferentes ejes.</p>
<p>Aquí crearemos una cuadrícula de <span class="math inline">\(2 \times 3\)</span> subgráficas, donde todos los ejes en la misma fila comparten su escala de eje y, y todos los ejes en la misma columna comparten su escala de eje x:</p>
<div id="b5f3aaa7" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb63"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">3</span>, sharex<span class="op">=</span><span class="st">'col'</span>, sharey<span class="op">=</span><span class="st">'row'</span>)</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Tenga en cuenta que al especificar <code>sharex</code> y <code>sharey</code>, eliminamos automáticamente las etiquetas internas de la cuadrícula para que el gráfico sea más limpio. La cuadrícula de instancias de ejes resultante se devuelve dentro de una matriz NumPy, lo que permite una especificación conveniente de los ejes deseados utilizando la notación de indexación de matriz estándar:</p>
<div id="aec23739" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb64"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Los ejes están en una matriz bidimensional, indexados por [fila, columna]</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>):</span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>):</span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>        ax[i, j].text(<span class="fl">0.5</span>, <span class="fl">0.5</span>, <span class="bu">str</span>((i, j)),</span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>                      fontsize<span class="op">=</span><span class="dv">18</span>, ha<span class="op">=</span><span class="st">'center'</span>)</span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a>fig</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>En comparación con <code>plt.subplot()</code>, <code>plt.subplots()</code> es más consistente con la indexación convencional basada en 0 de Python.</p>
</section>
<section id="plt.gridspec" class="level3">
<h3 class="anchored" data-anchor-id="plt.gridspec">8.9.4 <code>plt.GridSpec</code></h3>
<p>Para ir más allá de una cuadrícula regular a subgráficas que abarcan múltiples filas y columnas, <code>plt.GridSpec()</code> es la mejor herramienta. El objeto <code>plt.GridSpec()</code> no crea un gráfico por sí mismo; es simplemente una interfaz conveniente que es reconocida por el comando <code>plt.subplot()</code>. Por ejemplo, una especificación de cuadrícula para una cuadrícula de dos filas y tres columnas con un espacio de ancho y alto especificado se ve así:</p>
<div id="f807d303" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb65"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>grid <span class="op">=</span> plt.GridSpec(<span class="dv">2</span>, <span class="dv">3</span>, wspace<span class="op">=</span><span class="fl">0.4</span>, hspace<span class="op">=</span><span class="fl">0.3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>A partir de esto, podemos especificar las ubicaciones y extensiones de las subgráficas utilizando la sintaxis de corte habitual de Python:</p>
<div id="314e3897" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb66"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>plt.subplot(grid[<span class="dv">0</span>, <span class="dv">0</span>])</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>plt.subplot(grid[<span class="dv">0</span>, <span class="dv">1</span>:])</span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a>plt.subplot(grid[<span class="dv">1</span>, :<span class="dv">2</span>])</span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a>plt.subplot(grid[<span class="dv">1</span>, <span class="dv">2</span>])</span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Este tipo de alineación de cuadrícula flexible tiene una amplia gama de usos.</p>
<div id="6c5b0681" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb67"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Crear algunos datos distribuidos normalmente</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>mean <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">0</span>]</span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>cov <span class="op">=</span> [[<span class="dv">1</span>, <span class="dv">1</span>], [<span class="dv">1</span>, <span class="dv">2</span>]]</span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>x, y <span class="op">=</span> np.random.multivariate_normal(mean, cov, <span class="dv">3000</span>).T</span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Configurar los ejes con gridspec</span></span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">6</span>))</span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a>grid <span class="op">=</span> plt.GridSpec(<span class="dv">4</span>, <span class="dv">4</span>, hspace<span class="op">=</span><span class="fl">0.3</span>, wspace<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true" tabindex="-1"></a>main_ax <span class="op">=</span> fig.add_subplot(grid[:<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>:])</span>
<span id="cb67-10"><a href="#cb67-10" aria-hidden="true" tabindex="-1"></a>y_hist <span class="op">=</span> fig.add_subplot(grid[:<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>], xticklabels<span class="op">=</span>[], sharey<span class="op">=</span>main_ax)</span>
<span id="cb67-11"><a href="#cb67-11" aria-hidden="true" tabindex="-1"></a>x_hist <span class="op">=</span> fig.add_subplot(grid[<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>:], yticklabels<span class="op">=</span>[], sharex<span class="op">=</span>main_ax)</span>
<span id="cb67-12"><a href="#cb67-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-13"><a href="#cb67-13" aria-hidden="true" tabindex="-1"></a><span class="co"># puntos de dispersión en los ejes principales</span></span>
<span id="cb67-14"><a href="#cb67-14" aria-hidden="true" tabindex="-1"></a>main_ax.plot(x, y, <span class="st">'ok'</span>, markersize<span class="op">=</span><span class="dv">3</span>, alpha<span class="op">=</span><span class="fl">0.2</span>)</span>
<span id="cb67-15"><a href="#cb67-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-16"><a href="#cb67-16" aria-hidden="true" tabindex="-1"></a><span class="co"># histograma en los ejes adjuntos</span></span>
<span id="cb67-17"><a href="#cb67-17" aria-hidden="true" tabindex="-1"></a>x_hist.hist(x, <span class="dv">40</span>, histtype<span class="op">=</span><span class="st">'stepfilled'</span>,</span>
<span id="cb67-18"><a href="#cb67-18" aria-hidden="true" tabindex="-1"></a>            orientation<span class="op">=</span><span class="st">'vertical'</span>, color<span class="op">=</span><span class="st">'gray'</span>)</span>
<span id="cb67-19"><a href="#cb67-19" aria-hidden="true" tabindex="-1"></a>x_hist.invert_yaxis()</span>
<span id="cb67-20"><a href="#cb67-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-21"><a href="#cb67-21" aria-hidden="true" tabindex="-1"></a>y_hist.hist(y, <span class="dv">40</span>, histtype<span class="op">=</span><span class="st">'stepfilled'</span>,</span>
<span id="cb67-22"><a href="#cb67-22" aria-hidden="true" tabindex="-1"></a>            orientation<span class="op">=</span><span class="st">'horizontal'</span>, color<span class="op">=</span><span class="st">'gray'</span>)</span>
<span id="cb67-23"><a href="#cb67-23" aria-hidden="true" tabindex="-1"></a>y_hist.invert_xaxis()</span>
<span id="cb67-24"><a href="#cb67-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-25"><a href="#cb67-25" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="texto-y-anotaciones" class="level2">
<h2 class="anchored" data-anchor-id="texto-y-anotaciones">8.10 Texto y anotaciones</h2>
<p>Crear una buena visualización implica guiar al lector para que la figura cuente una historia. En algunos casos, esta historia se puede contar de una manera totalmente visual, sin necesidad de texto añadido, pero en otros son necesarias pequeñas señales textuales y etiquetas. Quizás los tipos de anotaciones más básicos que utilizará sean las etiquetas de ejes y los títulos, pero las opciones van más allá de esto.</p>
<section id="ejemplo-efecto-de-los-días-festivos-en-los-nacimientos-en-estados-unidos" class="level3">
<h3 class="anchored" data-anchor-id="ejemplo-efecto-de-los-días-festivos-en-los-nacimientos-en-estados-unidos">8.10.1 Ejemplo: Efecto de los días festivos en los nacimientos en Estados Unidos</h3>
<div id="50e19e01" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb68"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>    births <span class="op">=</span> pd.read_csv(<span class="st">'births.csv'</span>)</span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span>:</span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">!</span>curl <span class="op">-</span>O https:<span class="op">//</span>raw.githubusercontent.com<span class="op">/</span>jakevdp<span class="op">/</span>data<span class="op">-</span>CDCbirths<span class="op">/</span>master<span class="op">/</span>births.csv</span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a>    births <span class="op">=</span> pd.read_csv(<span class="st">'births.csv'</span>)</span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a>quartiles <span class="op">=</span> np.percentile(births[<span class="st">'births'</span>], [<span class="dv">25</span>, <span class="dv">50</span>, <span class="dv">75</span>])</span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a>mu, sig <span class="op">=</span> quartiles[<span class="dv">1</span>], <span class="fl">0.74</span> <span class="op">*</span> (quartiles[<span class="dv">2</span>] <span class="op">-</span> quartiles[<span class="dv">0</span>])</span>
<span id="cb68-9"><a href="#cb68-9" aria-hidden="true" tabindex="-1"></a>births <span class="op">=</span> births.query(<span class="st">'(births &gt; @mu - 5 * @sig) &amp; (births &lt; @mu + 5 * @sig)'</span>)</span>
<span id="cb68-10"><a href="#cb68-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-11"><a href="#cb68-11" aria-hidden="true" tabindex="-1"></a>births[<span class="st">'day'</span>] <span class="op">=</span> births[<span class="st">'day'</span>].astype(<span class="bu">int</span>)</span>
<span id="cb68-12"><a href="#cb68-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-13"><a href="#cb68-13" aria-hidden="true" tabindex="-1"></a>births.index <span class="op">=</span> pd.to_datetime(<span class="dv">10000</span> <span class="op">*</span> births.year <span class="op">+</span></span>
<span id="cb68-14"><a href="#cb68-14" aria-hidden="true" tabindex="-1"></a>                              <span class="dv">100</span> <span class="op">*</span> births.month <span class="op">+</span></span>
<span id="cb68-15"><a href="#cb68-15" aria-hidden="true" tabindex="-1"></a>                              births.day, <span class="bu">format</span><span class="op">=</span><span class="st">'%Y%m</span><span class="sc">%d</span><span class="st">'</span>)</span>
<span id="cb68-16"><a href="#cb68-16" aria-hidden="true" tabindex="-1"></a>births_by_date <span class="op">=</span> births.pivot_table(<span class="st">'births'</span>,</span>
<span id="cb68-17"><a href="#cb68-17" aria-hidden="true" tabindex="-1"></a>                                    [births.index.month, births.index.day])</span>
<span id="cb68-18"><a href="#cb68-18" aria-hidden="true" tabindex="-1"></a>births_by_date.index <span class="op">=</span> [pd.Timestamp(<span class="dv">2012</span>, month, day) <span class="cf">for</span> (month, day) <span class="kw">in</span> births_by_date.index]</span>
<span id="cb68-19"><a href="#cb68-19" aria-hidden="true" tabindex="-1"></a>births_by_date</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="4c22d7df" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb69"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">4</span>))</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>births_by_date.plot(ax<span class="op">=</span>ax)</span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Cuando comunicamos datos como estos, a menudo es útil anotar ciertas características de la gráfica para llamar la atención del lector. Esto se puede hacer manualmente con el comando <code>plt.text</code>/<code>ax.text</code>, que colocará el texto en un valor x/y particular:</p>
<div id="569cf2db" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb70"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">4</span>))</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>births_by_date.plot(ax<span class="op">=</span>ax)</span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Añadir etiquetas al gráfico</span></span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true" tabindex="-1"></a>style <span class="op">=</span> <span class="bu">dict</span>(size<span class="op">=</span><span class="dv">10</span>, color<span class="op">=</span><span class="st">'gray'</span>)</span>
<span id="cb70-6"><a href="#cb70-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-7"><a href="#cb70-7" aria-hidden="true" tabindex="-1"></a>ax.text(<span class="st">'2012-1-1'</span>, <span class="dv">3950</span>, <span class="st">"New Year's Day"</span>, <span class="op">**</span>style)</span>
<span id="cb70-8"><a href="#cb70-8" aria-hidden="true" tabindex="-1"></a>ax.text(<span class="st">'2012-7-4'</span>, <span class="dv">4250</span>, <span class="st">'Independence Day'</span>, ha<span class="op">=</span><span class="st">'center'</span>, <span class="op">**</span>style)</span>
<span id="cb70-9"><a href="#cb70-9" aria-hidden="true" tabindex="-1"></a>ax.text(<span class="st">'2012-9-4'</span>, <span class="dv">4850</span>, <span class="st">'Labor Day'</span>, ha<span class="op">=</span><span class="st">'center'</span>, <span class="op">**</span>style)</span>
<span id="cb70-10"><a href="#cb70-10" aria-hidden="true" tabindex="-1"></a>ax.text(<span class="st">'2012-10-31'</span>, <span class="dv">4600</span>, <span class="st">'Halloween'</span>, ha<span class="op">=</span><span class="st">'right'</span>, <span class="op">**</span>style)</span>
<span id="cb70-11"><a href="#cb70-11" aria-hidden="true" tabindex="-1"></a>ax.text(<span class="st">'2012-11-25'</span>, <span class="dv">4450</span>, <span class="st">'Thanksgiving'</span>, ha<span class="op">=</span><span class="st">'center'</span>, <span class="op">**</span>style)</span>
<span id="cb70-12"><a href="#cb70-12" aria-hidden="true" tabindex="-1"></a>ax.text(<span class="st">'2012-12-25'</span>, <span class="dv">3850</span>, <span class="st">'Christmas '</span>, ha<span class="op">=</span><span class="st">'right'</span>, <span class="op">**</span>style)</span>
<span id="cb70-13"><a href="#cb70-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-14"><a href="#cb70-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Etiquetar los ejes</span></span>
<span id="cb70-15"><a href="#cb70-15" aria-hidden="true" tabindex="-1"></a>ax.<span class="bu">set</span>(title<span class="op">=</span><span class="st">'USA births by day of year (1969-1988)'</span>,</span>
<span id="cb70-16"><a href="#cb70-16" aria-hidden="true" tabindex="-1"></a>       ylabel<span class="op">=</span><span class="st">'average daily births'</span>)</span>
<span id="cb70-17"><a href="#cb70-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-18"><a href="#cb70-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Formatear el eje x con etiquetas de meses centradas</span></span>
<span id="cb70-19"><a href="#cb70-19" aria-hidden="true" tabindex="-1"></a>ax.xaxis.set_major_locator(mpl.dates.MonthLocator())</span>
<span id="cb70-20"><a href="#cb70-20" aria-hidden="true" tabindex="-1"></a>ax.xaxis.set_minor_locator(mpl.dates.MonthLocator(bymonthday<span class="op">=</span><span class="dv">15</span>))</span>
<span id="cb70-21"><a href="#cb70-21" aria-hidden="true" tabindex="-1"></a>ax.xaxis.set_major_formatter(plt.NullFormatter())</span>
<span id="cb70-22"><a href="#cb70-22" aria-hidden="true" tabindex="-1"></a>ax.xaxis.set_minor_formatter(mpl.dates.DateFormatter(<span class="st">'%h'</span>))</span>
<span id="cb70-23"><a href="#cb70-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-24"><a href="#cb70-24" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>El método <code>ax.text</code> toma una posición x, una posición y, una cadena y luego palabras clave opcionales que especifican el color, el tamaño, el estilo, la alineación y otras propiedades del texto. Aquí usamos <code>ha='right'</code> y <code>ha='center'</code>, donde <code>ha</code> es la abreviatura de <em>alineación horizontal</em>. Consulte la cadena de documentación de <code>plt.text()</code> y de <code>mpl.text.Text()</code> para obtener más información sobre las opciones disponibles.</p>
</section>
<section id="transformaciones-y-posición-del-texto" class="level3">
<h3 class="anchored" data-anchor-id="transformaciones-y-posición-del-texto">8.10.2 Transformaciones y posición del texto</h3>
<p>En el ejemplo anterior, hemos anclado nuestras anotaciones de texto a ubicaciones de datos. A veces es preferible anclar el texto a una posición en los ejes o la figura, independientemente de los datos. En Matplotlib, esto se hace modificando la <em>transformación</em>.</p>
<p>Cualquier marco de visualización de gráficos necesita algún esquema para traducir entre sistemas de coordenadas. Por ejemplo, un punto de datos en <span class="math inline">\((x, y) = (1, 1)\)</span> necesita estar representado de alguna manera en una ubicación determinada en la figura, que a su vez necesita estar representada en píxeles en la pantalla. Matemáticamente, estas transformaciones de coordenadas son relativamente sencillas y Matplotlib tiene un conjunto de herramientas bien desarrollado que utiliza internamente para realizarlas (estas herramientas se pueden explorar en el submódulo <code>matplotlib.transforms</code>).</p>
<p>El usuario medio rara vez necesita preocuparse por los detalles de estas transformaciones, pero es un conocimiento útil para considerar la ubicación del texto en una figura. Hay tres transformaciones predefinidas que pueden resultar útiles en esta situación:</p>
<ul>
<li><code>ax.transData</code>: Transformación asociada a las coordenadas de los datos</li>
<li><code>ax.transAxes</code>: Transformación asociada a los ejes (en unidades de dimensiones de los ejes)</li>
<li><code>fig.transFigure</code>: Transformación asociada a la figura (en unidades de dimensiones de la figura)</li>
</ul>
<p>Veamos aquí un ejemplo de cómo dibujar texto en varias ubicaciones utilizando estas transformaciones:</p>
<div id="73ad7c73" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb71"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(facecolor<span class="op">=</span><span class="st">'lightgray'</span>)</span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>ax.axis([<span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">0</span>, <span class="dv">10</span>])</span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a><span class="co"># transform=ax.transData es el valor predeterminado, pero lo especificaremos de todos modos</span></span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a>ax.text(<span class="dv">1</span>, <span class="dv">5</span>, <span class="st">'. Data: (1, 5)'</span>, transform<span class="op">=</span>ax.transData) <span class="co"># Coordenadas absolutas</span></span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a>ax.text(<span class="fl">0.5</span>, <span class="fl">0.1</span>, <span class="st">'. Axes: (0.5, 0.1)'</span>, transform<span class="op">=</span>ax.transAxes) <span class="co"># Porcentajes del eje</span></span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true" tabindex="-1"></a>ax.text(<span class="fl">0.5</span>, <span class="fl">0.5</span>, <span class="st">'. Figure: (0.5, 0.5)'</span>, transform<span class="op">=</span>fig.transFigure) <span class="co"># Porcentajes de la figura</span></span>
<span id="cb71-8"><a href="#cb71-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-9"><a href="#cb71-9" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Tenga en cuenta que, de forma predeterminada, el texto se alinea arriba y a la izquierda de las coordenadas especificadas: aquí, el ‘.’ al comienzo de cada cadena marcará aproximadamente la ubicación de las coordenadas dadas.</p>
<p>Las coordenadas <code>transData</code> proporcionan las coordenadas de datos habituales asociadas con las etiquetas de los ejes x e y. Las coordenadas ‘transAxes’ dan la ubicación desde la esquina inferior izquierda de los ejes (aquí el cuadro blanco), como una fracción del tamaño de los ejes. Las coordenadas ‘transFigure’ son similares, pero especifican la posición desde la parte inferior izquierda de la figura (aquí el cuadro gris), como una fracción del tamaño de la figura.</p>
<p>Observe ahora que si cambiamos los límites de los ejes, solo se verán afectadas las coordenadas <code>transData</code>, mientras que las demás permanecerán estacionarias:</p>
<div id="bb2454c7" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb72"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>ax.set_xlim(<span class="dv">0</span>, <span class="dv">2</span>)</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>ax.set_ylim(<span class="op">-</span><span class="dv">6</span>, <span class="dv">6</span>)</span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a>fig</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Este comportamiento se puede ver más claramente al cambiar los límites de los ejes de forma interactiva: si está ejecutando este código en un cuaderno, puede hacer que esto suceda cambiando <code>%matplotlib inline</code> a <code>%matplotlib notebook</code> y usando el menú de cada gráfico para interactuar con el gráfico.</p>
</section>
<section id="flechas-y-anotaciones" class="level3">
<h3 class="anchored" data-anchor-id="flechas-y-anotaciones">8.10.3 Flechas y anotaciones</h3>
<p>Dibujar flechas en Matplotlib suele ser mucho más difícil de lo que uno imagina. Si bien hay una función <code>plt.arrow()</code> disponible, no recomendaría usarla: las flechas que crea son objetos SVG que estarán sujetos a la relación de aspecto variable de sus gráficos, y el resultado rara vez es el que el usuario pretendía. En su lugar, sugeriría utilizar la función <code>plt.annotate()</code>. Esta función crea un texto y una flecha, y las flechas se pueden especificar de forma muy flexible.</p>
<p>Aquí usaremos <code>annotate</code> con varias de sus opciones:</p>
<div id="20ced240" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb73"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a>plt.style.use(<span class="st">'classic'</span>)</span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">20</span>, <span class="dv">1000</span>)</span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a>ax.plot(x, np.cos(x))</span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a>ax.axis(<span class="st">'equal'</span>)</span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-9"><a href="#cb73-9" aria-hidden="true" tabindex="-1"></a>ax.annotate(<span class="st">'local maximum'</span>, xy<span class="op">=</span>(<span class="dv">2</span> <span class="op">*</span> np.pi, <span class="dv">1</span>), xytext<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">4</span>),</span>
<span id="cb73-10"><a href="#cb73-10" aria-hidden="true" tabindex="-1"></a>            arrowprops<span class="op">=</span><span class="bu">dict</span>(facecolor<span class="op">=</span><span class="st">'black'</span>, shrink<span class="op">=</span><span class="fl">0.05</span>))</span>
<span id="cb73-11"><a href="#cb73-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-12"><a href="#cb73-12" aria-hidden="true" tabindex="-1"></a>ax.annotate(<span class="st">'local minimum'</span>, xy<span class="op">=</span>(np.pi, <span class="op">-</span><span class="dv">1</span>), xytext<span class="op">=</span>(<span class="dv">2</span><span class="op">*</span>np.pi, <span class="op">-</span><span class="dv">2</span>),</span>
<span id="cb73-13"><a href="#cb73-13" aria-hidden="true" tabindex="-1"></a>            arrowprops<span class="op">=</span><span class="bu">dict</span>(arrowstyle<span class="op">=</span><span class="st">'-&gt;'</span>, facecolor<span class="op">=</span><span class="st">'red'</span>,</span>
<span id="cb73-14"><a href="#cb73-14" aria-hidden="true" tabindex="-1"></a>                            connectionstyle<span class="op">=</span><span class="st">'angle3,angleA=45,angleB=-90'</span>))</span>
<span id="cb73-15"><a href="#cb73-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-16"><a href="#cb73-16" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>El estilo de la flecha se controla a través del diccionario <code>arrowprops</code>, que tiene numerosas opciones disponibles. Estas opciones están bastante bien documentadas en la documentación en línea de Matplotlib, por lo que en lugar de repetirlas aquí probablemente sea más útil mostrar rápidamente algunas de las posibilidades. Demostremos varias de las posibles opciones utilizando el gráfico de tasa de natalidad de antes:</p>
<div id="8d0041e6" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb74"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">4</span>))</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>births_by_date.plot(ax<span class="op">=</span>ax)</span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Añadir etiquetas al gráfico</span></span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a>ax.annotate(<span class="st">"New Year's Day"</span>, xy<span class="op">=</span>(<span class="st">'2012-1-1'</span>, <span class="dv">4100</span>),  xycoords<span class="op">=</span><span class="st">'data'</span>,</span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a>            xytext<span class="op">=</span>(<span class="dv">50</span>, <span class="op">-</span><span class="dv">30</span>), textcoords<span class="op">=</span><span class="st">'offset points'</span>,</span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true" tabindex="-1"></a>            arrowprops<span class="op">=</span><span class="bu">dict</span>(arrowstyle<span class="op">=</span><span class="st">'-&gt;'</span>,</span>
<span id="cb74-8"><a href="#cb74-8" aria-hidden="true" tabindex="-1"></a>                            connectionstyle<span class="op">=</span><span class="st">'arc3,rad=-0.2'</span>))</span>
<span id="cb74-9"><a href="#cb74-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-10"><a href="#cb74-10" aria-hidden="true" tabindex="-1"></a>ax.annotate(<span class="st">'Independence Day'</span>, xy<span class="op">=</span>(<span class="st">'2012-7-4'</span>, <span class="dv">4250</span>),  xycoords<span class="op">=</span><span class="st">'data'</span>,</span>
<span id="cb74-11"><a href="#cb74-11" aria-hidden="true" tabindex="-1"></a>            bbox<span class="op">=</span><span class="bu">dict</span>(boxstyle<span class="op">=</span><span class="st">'round'</span>, fc<span class="op">=</span><span class="st">'none'</span>, ec<span class="op">=</span><span class="st">'gray'</span>),</span>
<span id="cb74-12"><a href="#cb74-12" aria-hidden="true" tabindex="-1"></a>            xytext<span class="op">=</span>(<span class="dv">10</span>, <span class="op">-</span><span class="dv">40</span>), textcoords<span class="op">=</span><span class="st">'offset points'</span>, ha<span class="op">=</span><span class="st">'center'</span>,</span>
<span id="cb74-13"><a href="#cb74-13" aria-hidden="true" tabindex="-1"></a>            arrowprops<span class="op">=</span><span class="bu">dict</span>(arrowstyle<span class="op">=</span><span class="st">'-&gt;'</span>))</span>
<span id="cb74-14"><a href="#cb74-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-15"><a href="#cb74-15" aria-hidden="true" tabindex="-1"></a>ax.annotate(<span class="st">'Labor Day'</span>, xy<span class="op">=</span>(<span class="st">'2012-9-4'</span>, <span class="dv">4850</span>), xycoords<span class="op">=</span><span class="st">'data'</span>, ha<span class="op">=</span><span class="st">'center'</span>,</span>
<span id="cb74-16"><a href="#cb74-16" aria-hidden="true" tabindex="-1"></a>            xytext<span class="op">=</span>(<span class="dv">0</span>, <span class="op">-</span><span class="dv">20</span>), textcoords<span class="op">=</span><span class="st">'offset points'</span>)</span>
<span id="cb74-17"><a href="#cb74-17" aria-hidden="true" tabindex="-1"></a>ax.annotate(<span class="st">''</span>, xy<span class="op">=</span>(<span class="st">'2012-9-1'</span>, <span class="dv">4850</span>), xytext<span class="op">=</span>(<span class="st">'2012-9-7'</span>, <span class="dv">4850</span>),</span>
<span id="cb74-18"><a href="#cb74-18" aria-hidden="true" tabindex="-1"></a>            xycoords<span class="op">=</span><span class="st">'data'</span>, textcoords<span class="op">=</span><span class="st">'data'</span>,</span>
<span id="cb74-19"><a href="#cb74-19" aria-hidden="true" tabindex="-1"></a>            arrowprops<span class="op">=</span>{<span class="st">'arrowstyle'</span>: <span class="st">'|-|,widthA=0.2,widthB=0.2'</span>, })</span>
<span id="cb74-20"><a href="#cb74-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-21"><a href="#cb74-21" aria-hidden="true" tabindex="-1"></a>ax.annotate(<span class="st">'Halloween'</span>, xy<span class="op">=</span>(<span class="st">'2012-10-31'</span>, <span class="dv">4600</span>),  xycoords<span class="op">=</span><span class="st">'data'</span>,</span>
<span id="cb74-22"><a href="#cb74-22" aria-hidden="true" tabindex="-1"></a>            xytext<span class="op">=</span>(<span class="op">-</span><span class="dv">80</span>, <span class="op">-</span><span class="dv">40</span>), textcoords<span class="op">=</span><span class="st">'offset points'</span>,</span>
<span id="cb74-23"><a href="#cb74-23" aria-hidden="true" tabindex="-1"></a>            arrowprops<span class="op">=</span><span class="bu">dict</span>(arrowstyle<span class="op">=</span><span class="st">'fancy'</span>,</span>
<span id="cb74-24"><a href="#cb74-24" aria-hidden="true" tabindex="-1"></a>                            fc<span class="op">=</span><span class="st">'0.6'</span>, ec<span class="op">=</span><span class="st">'none'</span>,</span>
<span id="cb74-25"><a href="#cb74-25" aria-hidden="true" tabindex="-1"></a>                            connectionstyle<span class="op">=</span><span class="st">'angle3,angleA=0,angleB=-90'</span>))</span>
<span id="cb74-26"><a href="#cb74-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-27"><a href="#cb74-27" aria-hidden="true" tabindex="-1"></a>ax.annotate(<span class="st">'Thanksgiving'</span>, xy<span class="op">=</span>(<span class="st">'2012-11-25'</span>, <span class="dv">4500</span>),  xycoords<span class="op">=</span><span class="st">'data'</span>,</span>
<span id="cb74-28"><a href="#cb74-28" aria-hidden="true" tabindex="-1"></a>            xytext<span class="op">=</span>(<span class="op">-</span><span class="dv">120</span>, <span class="op">-</span><span class="dv">60</span>), textcoords<span class="op">=</span><span class="st">'offset points'</span>,</span>
<span id="cb74-29"><a href="#cb74-29" aria-hidden="true" tabindex="-1"></a>            bbox<span class="op">=</span><span class="bu">dict</span>(boxstyle<span class="op">=</span><span class="st">'round4,pad=.5'</span>, fc<span class="op">=</span><span class="st">'0.9'</span>),</span>
<span id="cb74-30"><a href="#cb74-30" aria-hidden="true" tabindex="-1"></a>            arrowprops<span class="op">=</span><span class="bu">dict</span>(arrowstyle<span class="op">=</span><span class="st">'-&gt;'</span>,</span>
<span id="cb74-31"><a href="#cb74-31" aria-hidden="true" tabindex="-1"></a>                            connectionstyle<span class="op">=</span><span class="st">'angle,angleA=0,angleB=80,rad=20'</span>))</span>
<span id="cb74-32"><a href="#cb74-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-33"><a href="#cb74-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-34"><a href="#cb74-34" aria-hidden="true" tabindex="-1"></a>ax.annotate(<span class="st">'Christmas'</span>, xy<span class="op">=</span>(<span class="st">'2012-12-25'</span>, <span class="dv">3850</span>),  xycoords<span class="op">=</span><span class="st">'data'</span>,</span>
<span id="cb74-35"><a href="#cb74-35" aria-hidden="true" tabindex="-1"></a>             xytext<span class="op">=</span>(<span class="op">-</span><span class="dv">30</span>, <span class="dv">0</span>), textcoords<span class="op">=</span><span class="st">'offset points'</span>,</span>
<span id="cb74-36"><a href="#cb74-36" aria-hidden="true" tabindex="-1"></a>             size<span class="op">=</span><span class="dv">13</span>, ha<span class="op">=</span><span class="st">'right'</span>, va<span class="op">=</span><span class="st">'center'</span>,</span>
<span id="cb74-37"><a href="#cb74-37" aria-hidden="true" tabindex="-1"></a>             bbox<span class="op">=</span><span class="bu">dict</span>(boxstyle<span class="op">=</span><span class="st">'round'</span>, alpha<span class="op">=</span><span class="fl">0.1</span>),</span>
<span id="cb74-38"><a href="#cb74-38" aria-hidden="true" tabindex="-1"></a>             arrowprops<span class="op">=</span><span class="bu">dict</span>(arrowstyle<span class="op">=</span><span class="st">'wedge,tail_width=0.5'</span>, alpha<span class="op">=</span><span class="fl">0.1</span>))<span class="op">;</span></span>
<span id="cb74-39"><a href="#cb74-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-40"><a href="#cb74-40" aria-hidden="true" tabindex="-1"></a><span class="co"># Etiquetar los ejes</span></span>
<span id="cb74-41"><a href="#cb74-41" aria-hidden="true" tabindex="-1"></a>ax.<span class="bu">set</span>(title<span class="op">=</span><span class="st">'USA births by day of year (1969-1988)'</span>,</span>
<span id="cb74-42"><a href="#cb74-42" aria-hidden="true" tabindex="-1"></a>       ylabel<span class="op">=</span><span class="st">'average daily births'</span>)</span>
<span id="cb74-43"><a href="#cb74-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-44"><a href="#cb74-44" aria-hidden="true" tabindex="-1"></a><span class="co"># Formatear el eje x con etiquetas de meses centradas</span></span>
<span id="cb74-45"><a href="#cb74-45" aria-hidden="true" tabindex="-1"></a>ax.xaxis.set_major_locator(mpl.dates.MonthLocator())</span>
<span id="cb74-46"><a href="#cb74-46" aria-hidden="true" tabindex="-1"></a>ax.xaxis.set_minor_locator(mpl.dates.MonthLocator(bymonthday<span class="op">=</span><span class="dv">15</span>))</span>
<span id="cb74-47"><a href="#cb74-47" aria-hidden="true" tabindex="-1"></a>ax.xaxis.set_major_formatter(plt.NullFormatter())</span>
<span id="cb74-48"><a href="#cb74-48" aria-hidden="true" tabindex="-1"></a>ax.xaxis.set_minor_formatter(mpl.dates.DateFormatter(<span class="st">'%h'</span>))<span class="op">;</span></span>
<span id="cb74-49"><a href="#cb74-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-50"><a href="#cb74-50" aria-hidden="true" tabindex="-1"></a>ax.set_ylim(<span class="dv">3600</span>, <span class="dv">5400</span>)</span>
<span id="cb74-51"><a href="#cb74-51" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Notarás que las especificaciones de las flechas y los cuadros de texto son muy detalladas: esto te da el poder de crear casi cualquier estilo de flecha que desees. Lamentablemente, esto también significa que este tipo de características a menudo deben ajustarse manualmente, un proceso que puede consumir mucho tiempo cuando se producen gráficos con calidad de publicación. Por último, quiero señalar que la combinación de estilos anterior no es de ninguna manera la mejor práctica para presentar datos, sino que se incluye como una demostración de algunas de las opciones disponibles.</p>
</section>
</section>
<section id="personalización-de-ticks" class="level2">
<h2 class="anchored" data-anchor-id="personalización-de-ticks">8.11 Personalización de ticks</h2>
<p>Los localizadores y formateadores de marcas predeterminados de Matplotlib están diseñados para ser generalmente suficientes en muchas situaciones comunes, pero de ninguna manera son óptimos para todos los gráficos. En esta sección se brindarán varios ejemplos de cómo ajustar las ubicaciones y el formato de las marcas para el tipo de gráfico en particular que le interesa.</p>
<section id="marcas-mayores-y-menores" class="level3">
<h3 class="anchored" data-anchor-id="marcas-mayores-y-menores">8.11.1 Marcas mayores y menores</h3>
<p>Dentro de cada eje, existe el concepto de una marca de graduación <em>principal</em> y una marca de graduación <em>secundaria</em>. Como lo implican los nombres, las marcas de graduación principales suelen ser más grandes o más pronunciadas, mientras que las marcas de graduación secundarias suelen ser más pequeñas. De forma predeterminada, Matplotlib rara vez utiliza marcas de graduación secundarias, pero un lugar donde se pueden ver es dentro de los gráficos logarítmicos:</p>
<div id="81aef614" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb75"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a>plt.style.use(<span class="st">'bmh'</span>)</span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> plt.axes(xscale<span class="op">=</span><span class="st">'log'</span>, yscale<span class="op">=</span><span class="st">'log'</span>)</span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a>ax.grid()</span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Vemos aquí que cada marca principal muestra una marca grande y una etiqueta, mientras que cada marca secundaria muestra una marca más pequeña sin etiqueta.</p>
<p>Estas propiedades de las marcas de verificación (ubicaciones y etiquetas) se pueden personalizar configurando los objetos <code>formateador</code> y <code>localizador</code> de cada eje. Examinémoslos para el eje x del gráfico que se acaba de mostrar:</p>
<div id="8c1b42a5" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb76"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(ax.xaxis.get_major_locator())</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(ax.xaxis.get_minor_locator())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="a1334f60" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb77"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(ax.xaxis.get_major_formatter())</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(ax.xaxis.get_minor_formatter())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="ocultar-marcas-o-etiquetas" class="level3">
<h3 class="anchored" data-anchor-id="ocultar-marcas-o-etiquetas">8.11.2 Ocultar marcas o etiquetas</h3>
<p>Quizás la operación de formato de marca o etiqueta más común es el acto de ocultar marcas o etiquetas. Esto se puede hacer usando <code>plt.NullLocator()</code> y <code>plt.NullFormatter()</code>, como se muestra aquí:</p>
<div id="8a0a8e6d-983d-400f-b87c-b6948eeb0f9a" class="cell">
<div class="sourceCode cell-code" id="cb78"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> plt.axes()</span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a>ax.plot(np.random.rand(<span class="dv">50</span>))</span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="1baee443" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb79"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> plt.axes()</span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>ax.plot(np.random.rand(<span class="dv">50</span>))</span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a>ax.yaxis.set_major_locator(plt.NullLocator())</span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a>ax.xaxis.set_major_formatter(plt.NullFormatter())</span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-7"><a href="#cb79-7" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Tenga en cuenta que hemos eliminado las etiquetas (pero conservamos las marcas/líneas de cuadrícula) del eje x, y eliminamos las marcas (y, por lo tanto, también las etiquetas) del eje y. No tener ninguna marca de verificación puede ser útil en muchas situaciones; por ejemplo, cuando desea mostrar una cuadrícula de imágenes. Por ejemplo, considere la siguiente figura, que incluye imágenes de diferentes caras, un ejemplo que se utiliza a menudo en problemas de aprendizaje automático supervisado.</p>
<div id="0eb922b3-e162-4546-9bee-e3d1f5d8accd" class="cell">
<div class="sourceCode cell-code" id="cb80"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">5</span>, <span class="dv">5</span>, figsize<span class="op">=</span>(<span class="dv">5</span>, <span class="dv">5</span>))</span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a>fig.subplots_adjust(hspace<span class="op">=</span><span class="dv">0</span>, wspace<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Obtenga algunos datos faciales de scikit-learn</span></span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.datasets <span class="im">import</span> fetch_olivetti_faces</span>
<span id="cb80-6"><a href="#cb80-6" aria-hidden="true" tabindex="-1"></a>faces <span class="op">=</span> fetch_olivetti_faces().images</span>
<span id="cb80-7"><a href="#cb80-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-8"><a href="#cb80-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">5</span>):</span>
<span id="cb80-9"><a href="#cb80-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">5</span>):</span>
<span id="cb80-10"><a href="#cb80-10" aria-hidden="true" tabindex="-1"></a>        ax[i, j].imshow(faces[<span class="dv">10</span> <span class="op">*</span> i <span class="op">+</span> j], cmap<span class="op">=</span><span class="st">'bone'</span>)</span>
<span id="cb80-11"><a href="#cb80-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-12"><a href="#cb80-12" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="f70bdf63" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb81"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">5</span>, <span class="dv">5</span>, figsize<span class="op">=</span>(<span class="dv">5</span>, <span class="dv">5</span>))</span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>fig.subplots_adjust(hspace<span class="op">=</span><span class="dv">0</span>, wspace<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Obtenga algunos datos faciales de scikit-learn</span></span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.datasets <span class="im">import</span> fetch_olivetti_faces</span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a>faces <span class="op">=</span> fetch_olivetti_faces().images</span>
<span id="cb81-7"><a href="#cb81-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-8"><a href="#cb81-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">5</span>):</span>
<span id="cb81-9"><a href="#cb81-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">5</span>):</span>
<span id="cb81-10"><a href="#cb81-10" aria-hidden="true" tabindex="-1"></a>        ax[i, j].xaxis.set_major_locator(plt.NullLocator())</span>
<span id="cb81-11"><a href="#cb81-11" aria-hidden="true" tabindex="-1"></a>        ax[i, j].yaxis.set_major_locator(plt.NullLocator())</span>
<span id="cb81-12"><a href="#cb81-12" aria-hidden="true" tabindex="-1"></a>        ax[i, j].imshow(faces[<span class="dv">10</span> <span class="op">*</span> i <span class="op">+</span> j], cmap<span class="op">=</span><span class="st">'bone'</span>)</span>
<span id="cb81-13"><a href="#cb81-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-14"><a href="#cb81-14" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Tenga en cuenta que cada imagen tiene sus propios ejes y hemos establecido los localizadores en nulo porque los valores de las marcas (número de píxel en este caso) no transmiten información relevante para esta visualización en particular.</p>
</section>
<section id="reducir-o-aumentar-el-número-de-ticks" class="level3">
<h3 class="anchored" data-anchor-id="reducir-o-aumentar-el-número-de-ticks">8.11.3 Reducir o aumentar el número de ticks</h3>
<p>Un problema común con las configuraciones predeterminadas es que las subgráficas más pequeñas pueden terminar con etiquetas abarrotadas. Podemos ver esto en la cuadrícula de la gráficaa que se muestra aquí:</p>
<div id="b3a3474a" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb82"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">4</span>, <span class="dv">4</span>, sharex<span class="op">=</span><span class="va">True</span>, sharey<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>En particular, en el caso de las marcas x, los números casi se superponen y hacen que sea bastante difícil descifrarlas. Podemos solucionar esto con <code>plt.MaxNLocator()</code>, que nos permite especificar el número máximo de ticks que se mostrarán. Dado este número máximo, Matplotlib utilizará lógica interna para elegir las ubicaciones de las marcas particulares:</p>
<div id="6926df77" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb83"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Para cada eje, establezca el localizador principal x e y</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> axi <span class="kw">in</span> ax.flat:</span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a>    axi.xaxis.set_major_locator(plt.MaxNLocator(<span class="dv">3</span>))</span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a>    axi.yaxis.set_major_locator(plt.MaxNLocator(<span class="dv">3</span>))</span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a>fig</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Esto hace que todo sea mucho más claro.</p>
</section>
<section id="formatos-de-ticks-elegantes" class="level3">
<h3 class="anchored" data-anchor-id="formatos-de-ticks-elegantes">8.11.4 Formatos de ticks elegantes</h3>
<p>El formato de marcas predeterminado de Matplotlib puede dejar mucho que desear: funciona bien como un valor predeterminado amplio, pero a veces desearía hacer algo más. Considere esta gráfica de un seno y un coseno:</p>
<div id="ec9c3d0a" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb84"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Graficar una curva de seno y coseno</span></span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">3</span> <span class="op">*</span> np.pi, <span class="dv">1000</span>)</span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a>ax.plot(x, np.sin(x), lw<span class="op">=</span><span class="dv">3</span>, label<span class="op">=</span><span class="st">'Sine'</span>)</span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a>ax.plot(x, np.cos(x), lw<span class="op">=</span><span class="dv">3</span>, label<span class="op">=</span><span class="st">'Cosine'</span>)</span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-7"><a href="#cb84-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Configurar cuadrícula, leyenda y límites</span></span>
<span id="cb84-8"><a href="#cb84-8" aria-hidden="true" tabindex="-1"></a>ax.grid(<span class="va">True</span>)</span>
<span id="cb84-9"><a href="#cb84-9" aria-hidden="true" tabindex="-1"></a>ax.legend(frameon<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb84-10"><a href="#cb84-10" aria-hidden="true" tabindex="-1"></a>ax.axis(<span class="st">'equal'</span>)</span>
<span id="cb84-11"><a href="#cb84-11" aria-hidden="true" tabindex="-1"></a>ax.set_xlim(<span class="dv">0</span>, <span class="dv">3</span> <span class="op">*</span> np.pi)</span>
<span id="cb84-12"><a href="#cb84-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-13"><a href="#cb84-13" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Hay un par de cambios que nos gustaría hacer. Primero, es más natural que estos datos espacien las marcas y las líneas de la cuadrícula en múltiplos de <span class="math inline">\(\pi\)</span>. Podemos hacer esto estableciendo un <code>MultipleLocator</code>, que ubica las marcas en un múltiplo del número que proporciones. Por si acaso, agregaremos marcas mayores y menores en múltiplos de <span class="math inline">\(\pi/4\)</span>:</p>
<div id="15b23405" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb85"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a>ax.xaxis.set_major_locator(plt.MultipleLocator(np.pi <span class="op">/</span> <span class="dv">2</span>))</span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a>ax.xaxis.set_minor_locator(plt.MultipleLocator(np.pi <span class="op">/</span> <span class="dv">4</span>))</span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a>fig</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Pero ahora estas etiquetas de verificación parecen un poco tontas: podemos ver que son múltiplos de <span class="math inline">\(\pi\)</span>, pero la representación decimal no lo transmite inmediatamente. Para solucionar esto, podemos cambiar el formateador de ticks. No hay un formateador incorporado para lo que queremos hacer, por lo que en su lugar usaremos <code>plt.FuncFormatter</code>, que acepta una función definida por el usuario que brinda un control detallado sobre las salidas de ticks:</p>
<div id="87f58a8d" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb86"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> format_func(value, tick_number):</span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Encuentra el número de múltiplos de pi/2</span></span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a>    N <span class="op">=</span> <span class="bu">int</span>(np.<span class="bu">round</span>(<span class="dv">2</span> <span class="op">*</span> value <span class="op">/</span> np.pi))</span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> N <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">'0'</span></span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> N <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb86-7"><a href="#cb86-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="vs">r'$\pi/2$'</span></span>
<span id="cb86-8"><a href="#cb86-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> N <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb86-9"><a href="#cb86-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="vs">r'$\pi$'</span></span>
<span id="cb86-10"><a href="#cb86-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> N <span class="op">%</span> <span class="dv">2</span> <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb86-11"><a href="#cb86-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="vs">r'$</span><span class="sc">{0}</span><span class="vs">\pi/2$'</span>.<span class="bu">format</span>(N)</span>
<span id="cb86-12"><a href="#cb86-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb86-13"><a href="#cb86-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="vs">r'$</span><span class="sc">{0}</span><span class="vs">\pi$'</span>.<span class="bu">format</span>(N <span class="op">//</span> <span class="dv">2</span>)</span>
<span id="cb86-14"><a href="#cb86-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-15"><a href="#cb86-15" aria-hidden="true" tabindex="-1"></a>ax.xaxis.set_major_formatter(plt.FuncFormatter(format_func))</span>
<span id="cb86-16"><a href="#cb86-16" aria-hidden="true" tabindex="-1"></a>fig</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>¡Esto es mucho mejor! Observe que hemos hecho uso del soporte LaTeX de Matplotlib, especificado al encerrar la cadena entre signos de dólar. Esto es muy conveniente para la visualización de símbolos y fórmulas matemáticas: en este caso, <code>'$\pi$'</code> se representa como el carácter griego <span class="math inline">\(\pi\)</span>.</p>
<p><code>plt.FuncFormatter()</code> ofrece un control extremadamente detallado sobre la apariencia de las marcas de su gráfico y resulta muy útil al preparar gráficos para su presentación o publicación.</p>
</section>
</section>
<section id="personalización-de-matplotlib" class="level2">
<h2 class="anchored" data-anchor-id="personalización-de-matplotlib">8.12 Personalización de Matplotlib</h2>
<section id="personalización-de-la-gráfica-a-mano" class="level3">
<h3 class="anchored" data-anchor-id="personalización-de-la-gráfica-a-mano">8.12.1 Personalización de la gráfica a mano</h3>
<p>Empecemos por una gráfica de un histograma, con las configuraciones por defecto de Matplotlib.</p>
<div id="48182667" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb87"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.random.randn(<span class="dv">1000</span>)</span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a>plt.hist(x)</span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Podemos ajustar esto a mano para que sea una gráfica mucho más agradable a la vista:</p>
<div id="f66e30c6" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb88"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="co"># utiliza un fondo gris</span></span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> plt.axes(facecolor<span class="op">=</span><span class="st">'#F0F0F0'</span>)</span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a>ax.set_axisbelow(<span class="va">True</span>)</span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Dibujar líneas de cuadrícula blancas sólidas</span></span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true" tabindex="-1"></a>plt.grid(color<span class="op">=</span><span class="st">'w'</span>, linestyle<span class="op">=</span><span class="st">'solid'</span>)</span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-8"><a href="#cb88-8" aria-hidden="true" tabindex="-1"></a><span class="co"># ocultar las espinas del eje</span></span>
<span id="cb88-9"><a href="#cb88-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> spine <span class="kw">in</span> ax.spines.values():</span>
<span id="cb88-10"><a href="#cb88-10" aria-hidden="true" tabindex="-1"></a>    spine.set_visible(<span class="va">False</span>)</span>
<span id="cb88-11"><a href="#cb88-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb88-12"><a href="#cb88-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Ocultar los ticks superiores y derechos</span></span>
<span id="cb88-13"><a href="#cb88-13" aria-hidden="true" tabindex="-1"></a>ax.xaxis.tick_bottom()</span>
<span id="cb88-14"><a href="#cb88-14" aria-hidden="true" tabindex="-1"></a>ax.yaxis.tick_left()</span>
<span id="cb88-15"><a href="#cb88-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-16"><a href="#cb88-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Aclarar las marcas y las etiquetas</span></span>
<span id="cb88-17"><a href="#cb88-17" aria-hidden="true" tabindex="-1"></a>ax.tick_params(colors<span class="op">=</span><span class="st">'gray'</span>, direction<span class="op">=</span><span class="st">'out'</span>)</span>
<span id="cb88-18"><a href="#cb88-18" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> tick <span class="kw">in</span> ax.get_xticklabels():</span>
<span id="cb88-19"><a href="#cb88-19" aria-hidden="true" tabindex="-1"></a>    tick.set_color(<span class="st">'gray'</span>)</span>
<span id="cb88-20"><a href="#cb88-20" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> tick <span class="kw">in</span> ax.get_yticklabels():</span>
<span id="cb88-21"><a href="#cb88-21" aria-hidden="true" tabindex="-1"></a>    tick.set_color(<span class="st">'gray'</span>)</span>
<span id="cb88-22"><a href="#cb88-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb88-23"><a href="#cb88-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Controlar el color de la cara y del borde del histograma</span></span>
<span id="cb88-24"><a href="#cb88-24" aria-hidden="true" tabindex="-1"></a>ax.hist(x, edgecolor<span class="op">=</span><span class="st">'#E15759'</span>, color<span class="op">=</span><span class="st">'#FF9D9A'</span>)<span class="op">;</span></span>
<span id="cb88-25"><a href="#cb88-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-26"><a href="#cb88-26" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="cambiar-los-valores-predeterminados-rcparams" class="level3">
<h3 class="anchored" data-anchor-id="cambiar-los-valores-predeterminados-rcparams">8.12.2 Cambiar los valores predeterminados: <code>rcParams</code></h3>
<p>Cada vez que se carga Matplotlib, define una configuración de tiempo de ejecución (rc) que contiene los estilos predeterminados para cada elemento del gráfico que cree. Esta configuración se puede ajustar en cualquier momento utilizando la rutina de conveniencia <code>plt.rc</code>. Veamos cómo se ve modificar los parámetros rc para que nuestro gráfico predeterminado se vea similar a lo que hicimos antes.</p>
<p>Comenzaremos guardando una copia del diccionario <code>rcParams</code> actual, para que podamos restablecer fácilmente estos cambios en la sesión actual:</p>
<div id="8ae704bd" class="cell">
<div class="sourceCode cell-code" id="cb89"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a>IPython_default <span class="op">=</span> plt.rcParams.copy()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Ahora podemos usar la función <code>plt.rc</code> para cambiar algunas de estas configuraciones:</p>
<div id="4200cc33" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb90"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib <span class="im">import</span> cycler</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> cycler(<span class="st">'color'</span>,</span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a>                [<span class="st">'#FF9D9A'</span>, <span class="st">'#A0CBE8'</span>, <span class="st">'#8CD17D'</span>,</span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a>                 <span class="st">'#FFBE7D'</span>, <span class="st">'#D4A6C8'</span>, <span class="st">'#9C755F'</span>])</span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true" tabindex="-1"></a>plt.rc(<span class="st">'axes'</span>, facecolor<span class="op">=</span><span class="st">'#F0F0F0'</span>, edgecolor<span class="op">=</span><span class="st">'none'</span>,</span>
<span id="cb90-6"><a href="#cb90-6" aria-hidden="true" tabindex="-1"></a>       axisbelow<span class="op">=</span><span class="va">True</span>, grid<span class="op">=</span><span class="va">True</span>, prop_cycle<span class="op">=</span>colors)</span>
<span id="cb90-7"><a href="#cb90-7" aria-hidden="true" tabindex="-1"></a>plt.rc(<span class="st">'grid'</span>, color<span class="op">=</span><span class="st">'w'</span>, linestyle<span class="op">=</span><span class="st">'solid'</span>)</span>
<span id="cb90-8"><a href="#cb90-8" aria-hidden="true" tabindex="-1"></a>plt.rc(<span class="st">'xtick'</span>, direction<span class="op">=</span><span class="st">'out'</span>, color<span class="op">=</span><span class="st">'gray'</span>)</span>
<span id="cb90-9"><a href="#cb90-9" aria-hidden="true" tabindex="-1"></a>plt.rc(<span class="st">'ytick'</span>, direction<span class="op">=</span><span class="st">'out'</span>, color<span class="op">=</span><span class="st">'gray'</span>)</span>
<span id="cb90-10"><a href="#cb90-10" aria-hidden="true" tabindex="-1"></a>plt.rc(<span class="st">'patch'</span>, edgecolor<span class="op">=</span><span class="st">'#E15759'</span>, facecolor<span class="op">=</span><span class="st">'#FF9D9A'</span>)</span>
<span id="cb90-11"><a href="#cb90-11" aria-hidden="true" tabindex="-1"></a>plt.rc(<span class="st">'lines'</span>, linewidth<span class="op">=</span><span class="dv">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Con estos ajustes definidos, ahora podemos crear un gráfico y ver nuestros ajustes en acción:</p>
<div id="aa7084dc" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb91"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a>plt.hist(x)</span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Veamos cómo se ven los gráficos de líneas simples con estos parámetros rc:</p>
<div id="d0eddd72" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb92"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">4</span>):</span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a>    plt.plot(np.random.rand(<span class="dv">10</span>))</span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="hojas-de-estilo" class="level3">
<h3 class="anchored" data-anchor-id="hojas-de-estilo">8.12.3 Hojas de estilo</h3>
<p>Matplotlib cuenta con un módulo <code>style</code> muy práctico, que incluye varias hojas de estilo predeterminadas nuevas, así como la capacidad de crear y empaquetar sus propios estilos. Estas hojas de estilo tienen un formato similar al de los archivos <em>.matplotlibrc</em> mencionados anteriormente, pero deben tener una extensión <em>.mplstyle</em>.</p>
<p>Incluso si no creas tu propio estilo, las hojas de estilo incluidas por defecto son extremadamente útiles. Los estilos disponibles se enumeran en <code>plt.style.available</code>; aquí enumeraré solo los primeros cinco para abreviar:</p>
<div id="7df8ce2e" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb93"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a>plt.style.available[:<span class="dv">5</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>La forma básica de cambiar a una hoja de estilo es llamar</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a>plt.style.use(<span class="st">'stylename'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>¡Pero ten en cuenta que esto cambiará el estilo para el resto de la sesión! Alternativamente, puede utilizar el administrador de contexto de estilo, que establece un estilo temporalmente:</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> plt.style.context(<span class="st">'stylename'</span>):</span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a>    make_a_plot()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Vamos a crear una función que creará dos tipos básicos de gráficos:</p>
<div id="6c5ffe12" class="cell">
<div class="sourceCode cell-code" id="cb96"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> hist_and_lines():</span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a>    np.random.seed(<span class="dv">0</span>)</span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a>    fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">11</span>, <span class="dv">4</span>))</span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">0</span>].hist(np.random.randn(<span class="dv">1000</span>))</span>
<span id="cb96-5"><a href="#cb96-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>):</span>
<span id="cb96-6"><a href="#cb96-6" aria-hidden="true" tabindex="-1"></a>        ax[<span class="dv">1</span>].plot(np.random.rand(<span class="dv">10</span>))</span>
<span id="cb96-7"><a href="#cb96-7" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">1</span>].legend([<span class="st">'a'</span>, <span class="st">'b'</span>, <span class="st">'c'</span>], loc<span class="op">=</span><span class="st">'lower left'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Usaremos esto para explorar cómo se ven estos gráficos usando los distintos estilos incorporados.</p>
<section id="estilo-predeterminado" class="level4">
<h4 class="anchored" data-anchor-id="estilo-predeterminado">Estilo predeterminado</h4>
<p>El estilo predeterminado es el que hemos estado viendo hasta ahora a lo largo del libro; comenzaremos con eso. Primero, restablezcamos nuestra configuración de tiempo de ejecución a la configuración predeterminada del notebook:</p>
<div id="13437680" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb97"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="co"># restablecer rcParams</span></span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a>plt.rcParams.update(IPython_default)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Ahora veamos cómo se ve:</p>
<div id="07c9c39e" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb98"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a>hist_and_lines()</span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="estilo-fivethiryeight" class="level4">
<h4 class="anchored" data-anchor-id="estilo-fivethiryeight">Estilo FiveThiryEight</h4>
<p>El estilo ‘fivethirtyeight’ imita los gráficos que se encuentran en el popular <a href="https://fivethirtyeight.com">FiveThirtyEight website</a>. Como se puede ver aquí, se caracteriza por colores llamativos, líneas gruesas y ejes transparentes:</p>
<div id="a3176011" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb99"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> plt.style.context(<span class="st">'fivethirtyeight'</span>):</span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a>    hist_and_lines()</span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a>    plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="estilo-ggplots" class="level4">
<h4 class="anchored" data-anchor-id="estilo-ggplots">Estilo ggplots</h4>
<p>El paquete <code>ggplot</code> en el lenguaje R es una herramienta de visualización muy popular. El estilo <code>ggplot</code> de Matplotlib imita los estilos predeterminados de ese paquete:</p>
<div id="d239222e" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb100"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> plt.style.context(<span class="st">'ggplot'</span>):</span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a>    hist_and_lines()</span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true" tabindex="-1"></a>    plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="estilo-métodos-bayesianos-para-hackers" class="level4">
<h4 class="anchored" data-anchor-id="estilo-métodos-bayesianos-para-hackers">Estilo Métodos bayesianos para hackers</h4>
<p>Hay un libro en línea muy lindo y breve llamado <a href="http://camdavidsonpilon.github.io/Probabilistic-Programming-and-Bayesian-Methods-for-Hackers/"><em>Probabilistic Programming and Bayesian Methods for Hackers</em></a>; presenta figuras creadas con Matplotlib y utiliza un lindo conjunto de parámetros rc para crear un estilo consistente y visualmente atractivo en todo el libro. Este estilo se reproduce en la hoja de estilos <code>bmh</code>:</p>
<div id="666f87fb" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb101"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> plt.style.context(<span class="st">'bmh'</span>):</span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a>    hist_and_lines()</span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a>    plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="fondo-oscuro" class="level4">
<h4 class="anchored" data-anchor-id="fondo-oscuro">Fondo oscuro</h4>
<p>Para las figuras utilizadas en presentaciones, a menudo es útil tener un fondo oscuro en lugar de claro. El estilo <code>dark_background</code> proporciona esto:</p>
<div id="ecfa4db6" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb102"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> plt.style.context(<span class="st">'dark_background'</span>):</span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a>    hist_and_lines()</span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a>    plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="escala-de-grises" class="level4">
<h4 class="anchored" data-anchor-id="escala-de-grises">Escala de grises</h4>
<p>A veces es posible que te encuentres preparando figuras para una publicación impresa que no acepta figuras en color. Para ello, el estilo «escala de grises», que se muestra aquí, puede ser muy útil:</p>
<div id="8eb8ce45" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb103"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> plt.style.context(<span class="st">'grayscale'</span>):</span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a>    hist_and_lines()</span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a>    plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Con todas estas opciones integradas para varios estilos de gráficos, Matplotlib se vuelve mucho más útil tanto para la visualización interactiva como para la creación de figuras para publicación. A lo largo de este libro, generalmente utilizaré una o más de estas convenciones de estilo al crear gráficos.</p>
</section>
</section>
</section>
<section id="visualización-con-seaborn" class="level2">
<h2 class="anchored" data-anchor-id="visualización-con-seaborn">8.13 Visualización con Seaborn</h2>
<p>Matplotlib ha demostrado ser una herramienta de visualización increíblemente útil y popular, pero incluso los usuarios más ávidos admitirán que a menudo deja mucho que desear. Una respuesta a estos problemas es <a href="http://seaborn.pydata.org/">Seaborn</a>. Seaborn proporciona una API sobre Matplotlib que ofrece opciones sensatas para el estilo de gráfico y los valores predeterminados de color, define funciones simples de alto nivel para tipos de gráficos estadísticos comunes y se integra con la funcionalidad proporcionada por los ‘DataFrame’ de Pandas.</p>
<section id="seaborn-contra-matplotlib" class="level3">
<h3 class="anchored" data-anchor-id="seaborn-contra-matplotlib">8.13.1 Seaborn contra Matplotlib</h3>
<p>A continuación se muestra un ejemplo de un gráfico de caminata aleatoria simple en Matplotlib, utilizando su formato de gráfico y colores clásicos.</p>
<div id="a27115ec" class="cell">
<div class="sourceCode cell-code" id="cb104"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a>plt.style.use(<span class="st">'classic'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Ahora creamos algunos datos de caminata aleatoria:</p>
<div id="1fb6d191" class="cell">
<div class="sourceCode cell-code" id="cb105"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Crear algunos datos</span></span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a>rng <span class="op">=</span> np.random.RandomState(<span class="dv">0</span>)</span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">500</span>)</span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> np.cumsum(rng.randn(<span class="dv">500</span>, <span class="dv">6</span>), <span class="dv">0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Y haz un gráfico sencillo:</p>
<div id="9717ab7f" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb106"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Grafique los datos con los valores predeterminados de Matplotlib</span></span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a>plt.plot(x, y)</span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a>plt.legend(<span class="st">'ABCDEF'</span>, ncol<span class="op">=</span><span class="dv">2</span>, loc<span class="op">=</span><span class="st">'upper left'</span>)</span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Aunque el resultado contiene toda la información que nos gustaría transmitir, lo hace de una manera que no es del todo agradable estéticamente, e incluso parece un poco anticuado en el contexto de la visualización de datos del siglo XXI.</p>
<p>Ahora veamos cómo funciona con Seaborn. Como veremos, Seaborn tiene muchas de sus propias rutinas de gráficos de alto nivel, pero también puede sobrescribir los parámetros predeterminados de Matplotlib y, a su vez, lograr que incluso los scripts simples de Matplotlib produzcan resultados muy superiores. Podemos establecer el estilo llamando al método <code>set()</code> de Seaborn. Por convención, Seaborn se importa como <code>sns</code>:</p>
<div id="e1a39004" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb107"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a>sns.<span class="bu">set</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Ahora volvamos a ejecutar las mismas líneas que antes:</p>
<div id="3e9ea926" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb108"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="co"># ¡El mismo código de graficación que arriba!</span></span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a>plt.plot(x, y)</span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true" tabindex="-1"></a>plt.legend(<span class="st">'ABCDEF'</span>, ncol<span class="op">=</span><span class="dv">2</span>, loc<span class="op">=</span><span class="st">'upper left'</span>)</span>
<span id="cb108-4"><a href="#cb108-4" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="explorando-las-gráficas-de-seaborn" class="level3">
<h3 class="anchored" data-anchor-id="explorando-las-gráficas-de-seaborn">8.13.2 Explorando las gráficas de Seaborn</h3>
<p>La idea principal de Seaborn es que proporciona comandos de alto nivel para crear una variedad de tipos de gráficos útiles para la exploración de datos estadísticos e incluso algunos ajustes de modelos estadísticos.</p>
<p>Echemos un vistazo a algunos de los conjuntos de datos y tipos de gráficos disponibles en Seaborn. Tenga en cuenta que todo lo siguiente <em>podría</em> realizarse utilizando comandos Matplotlib sin formato (esto es, de hecho, lo que hace Seaborn en segundo plano), pero la API de Seaborn es mucho más conveniente.</p>
<section id="histogramas-kde-y-densidades" class="level4">
<h4 class="anchored" data-anchor-id="histogramas-kde-y-densidades">Histogramas, KDE y densidades</h4>
<p>A menudo, en la visualización de datos estadísticos, lo único que se desea es trazar histogramas y distribuciones conjuntas de variables. Hemos visto que esto es relativamente sencillo en Matplotlib:</p>
<div id="8559bf7e" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb109"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> np.random.multivariate_normal([<span class="dv">0</span>, <span class="dv">0</span>], [[<span class="dv">5</span>, <span class="dv">2</span>], [<span class="dv">2</span>, <span class="dv">2</span>]], size<span class="op">=</span><span class="dv">2000</span>)</span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> pd.DataFrame(data, columns<span class="op">=</span>[<span class="st">'x'</span>, <span class="st">'y'</span>])</span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> <span class="st">'xy'</span>:</span>
<span id="cb109-5"><a href="#cb109-5" aria-hidden="true" tabindex="-1"></a>    plt.hist(data[col], density<span class="op">=</span><span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb109-6"><a href="#cb109-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-7"><a href="#cb109-7" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>En lugar de un histograma, podemos obtener una estimación suave de la distribución utilizando una estimación de densidad de kernel, que Seaborn hace con <code>sns.kdeplot</code>:</p>
<div id="a0bbdacf" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb110"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> <span class="st">'xy'</span>:</span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a>    sns.kdeplot(data[col], fill<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Los histogramas y KDE se pueden combinar usando <code>displot</code>:</p>
<div id="2d925bd9" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb111"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a>sns.displot(data[<span class="st">'x'</span>], kde<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a>sns.displot(data[<span class="st">'y'</span>], kde<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Si pasamos el conjunto de datos bidimensionales completo a <code>kdeplot</code>, obtendremos una visualización bidimensional de los datos:</p>
<div id="3cfd3037" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb112"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a>sns.kdeplot(data,x<span class="op">=</span><span class="st">'x'</span>,y<span class="op">=</span><span class="st">'y'</span>)</span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Podemos ver la distribución conjunta y las distribuciones marginales juntas usando <code>sns.jointplot</code>. Para este gráfico, estableceremos el estilo en un fondo blanco:</p>
<div id="517f3ceb" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb113"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> sns.axes_style(<span class="st">'white'</span>):</span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a>    sns.jointplot(data, x<span class="op">=</span><span class="st">'x'</span>, y<span class="op">=</span><span class="st">'y'</span>, kind<span class="op">=</span><span class="st">'kde'</span>)</span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Hay otros parámetros que se pueden pasar a <code>jointplot</code>; por ejemplo, podemos utilizar un histograma de base hexagonal en su lugar:</p>
<div id="5cf42be6" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb114"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> sns.axes_style(<span class="st">'white'</span>):</span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a>    sns.jointplot(data, x<span class="op">=</span><span class="st">'x'</span>, y<span class="op">=</span><span class="st">'y'</span>, kind<span class="op">=</span><span class="st">'hex'</span>)</span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="gráficas-de-pares" class="level4">
<h4 class="anchored" data-anchor-id="gráficas-de-pares">Gráficas de pares</h4>
<p>Cuando se generalizan gráficos conjuntos a conjuntos de datos de dimensiones mayores, se obtienen <em>gráficos de pares</em>. Esto resulta muy útil para explorar correlaciones entre datos multidimensionales, cuando se desea representar gráficamente todos los pares de valores entre sí.</p>
<p>Demostraremos esto con el conocido conjunto de datos Iris, que enumera las medidas de pétalos y sépalos de tres especies de iris:</p>
<div id="080f6cdd" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb115"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a>iris <span class="op">=</span> sns.load_dataset(<span class="st">'iris'</span>)</span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a>iris.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Visualizar las relaciones multidimensionales entre las muestras es tan fácil como llamar a <code>sns.pairplot</code>:</p>
<div id="d33be1a9" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb116"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a>sns.pairplot(iris, hue<span class="op">=</span><span class="st">'species'</span>, height<span class="op">=</span><span class="fl">2.5</span>)</span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="histogramas-facetados" class="level4">
<h4 class="anchored" data-anchor-id="histogramas-facetados">Histogramas facetados</h4>
<p>A veces, la mejor forma de visualizar los datos es mediante histogramas de subconjuntos. ‘FacetGrid’ de Seaborn hace que esto sea extremadamente sencillo. Echemos un vistazo a algunos datos que muestran la cantidad que el personal del restaurante recibe en propinas en función de varios datos indicadores:</p>
<div id="1e14f0ef" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb117"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a>tips <span class="op">=</span> sns.load_dataset(<span class="st">'tips'</span>)</span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a>tips.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="81b8d970" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb118"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a>tips[<span class="st">'tip_pct'</span>] <span class="op">=</span> <span class="dv">100</span> <span class="op">*</span> tips[<span class="st">'tip'</span>] <span class="op">/</span> tips[<span class="st">'total_bill'</span>]</span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true" tabindex="-1"></a>grid <span class="op">=</span> sns.FacetGrid(tips, row<span class="op">=</span><span class="st">'sex'</span>, col<span class="op">=</span><span class="st">'time'</span>, margin_titles<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb118-4"><a href="#cb118-4" aria-hidden="true" tabindex="-1"></a>grid.<span class="bu">map</span>(plt.hist, <span class="st">'tip_pct'</span>, bins<span class="op">=</span>np.linspace(<span class="dv">0</span>, <span class="dv">40</span>, <span class="dv">15</span>))</span>
<span id="cb118-5"><a href="#cb118-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-6"><a href="#cb118-6" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="distribuciones-conjuntas" class="level4">
<h4 class="anchored" data-anchor-id="distribuciones-conjuntas">Distribuciones conjuntas</h4>
<p>De manera similar al diagrama de pares que vimos anteriormente, podemos usar <code>sns.jointplot</code> para mostrar la distribución conjunta entre diferentes conjuntos de datos, junto con las distribuciones marginales asociadas:</p>
<div id="8bf87e85" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb119"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> sns.axes_style(<span class="st">'white'</span>):</span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a>    sns.jointplot(tips, x<span class="op">=</span><span class="st">'total_bill'</span>, y<span class="op">=</span><span class="st">'tip'</span>, kind<span class="op">=</span><span class="st">'hex'</span>)</span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true" tabindex="-1"></a>    plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>El gráfico conjunto puede incluso realizar algunas estimaciones y regresiones automáticas de la densidad del kernel:</p>
<div id="d2c8cf77" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb120"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a>sns.jointplot(tips, x<span class="op">=</span><span class="st">'total_bill'</span>, y<span class="op">=</span><span class="st">'tip'</span>, kind<span class="op">=</span><span class="st">'reg'</span>)</span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="gráficos-de-barras" class="level4">
<h4 class="anchored" data-anchor-id="gráficos-de-barras">Gráficos de barras</h4>
<p>Las series temporales se pueden representar gráficamente utilizando <code>sns.factorplot</code>.</p>
<div id="97951cc0" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb121"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a>planets <span class="op">=</span> sns.load_dataset(<span class="st">'planets'</span>)</span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a>planets.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="49fddfac" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb122"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> sns.axes_style(<span class="st">'white'</span>):</span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a>    g <span class="op">=</span> sns.catplot(planets, x <span class="op">=</span><span class="st">'year'</span>, aspect<span class="op">=</span><span class="dv">2</span>,</span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true" tabindex="-1"></a>                       kind<span class="op">=</span><span class="st">'count'</span>, color<span class="op">=</span><span class="st">'steelblue'</span>)</span>
<span id="cb122-4"><a href="#cb122-4" aria-hidden="true" tabindex="-1"></a>    g.set_xticklabels(step<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb122-5"><a href="#cb122-5" aria-hidden="true" tabindex="-1"></a>    plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Podemos aprender más observando el <em>método</em> de descubrimiento de cada uno de estos planetas:</p>
<div id="36f4e3d2" class="cell" data-jupyter="{&quot;outputs_hidden&quot;:false}">
<div class="sourceCode cell-code" id="cb123"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> sns.axes_style(<span class="st">'white'</span>):</span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a>    g <span class="op">=</span> sns.catplot(planets, x<span class="op">=</span><span class="st">'year'</span>, aspect<span class="op">=</span><span class="fl">4.0</span>, kind<span class="op">=</span><span class="st">'count'</span>,</span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a>                       hue<span class="op">=</span><span class="st">'method'</span>, order<span class="op">=</span><span class="bu">range</span>(<span class="dv">2001</span>, <span class="dv">2015</span>))</span>
<span id="cb123-4"><a href="#cb123-4" aria-hidden="true" tabindex="-1"></a>    g.set_ylabels(<span class="st">'Number of Planets Discovered'</span>)</span>
<span id="cb123-5"><a href="#cb123-5" aria-hidden="true" tabindex="-1"></a>    plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
</section>

<!-- 7.9 -->

<section id="practice-exercises" class="level2" data-number="8.14">
                <h2 data-number="8.14" class="anchored" data-anchor-id="practice-exercises"><span
                        class="header-section-number">8.14</span> Ejercicios prácticos </h2>
<ol type="1">
<li>Cree un nuevo Notebook.</li>
<li>Guarde el archivo como <strong>Ejercicios_practicos_clase_8.ipynb</strong>.</li>
<li>Asigne un título <strong>H1</strong> con su nombre.</li>
</ol>
<section id="practice-exercise-1" class="level3" data-number="7.9.1">
                    <h3 data-number="7.9.1" class="anchored" data-anchor-id="practice-exercise-1"><span
                            class="header-section-number">8.14.1 </span> Ejercicio práctico 1 </h3>
<p>El archivo <a href="https://aquinteroz.github.io/Programacion/Datasets/titanic.csv">titanic.csv</a> contiene información sobre los pasajeros del Titanic. Crear un dataframe con Pandas y a partir de él generar los siguientes diagramas.</p>
<ol>
<li>Diagrama de sectores con los fallecidos y supervivientes.</li>
<li>Histograma con las edades.</li>
<li>Diagrama de barras con el número de personas en cada clase.</li>
<li>Diagrama de barras con el número de personas fallecidas y supervivientes en cada clase, discriminados por sexo.</li>
</ol>

</section>
<section id="practice-exercise-2" class="level3" data-number="7.9.2">
                    <h3 data-number="7.9.2" class="anchored" data-anchor-id="practice-exercise-2"><span
                            class="header-section-number">8.14.2 </span> Ejercicio práctico 2 </h3>
<p>El archivo <a href="https://aquinteroz.github.io/Programacion/Datasets/bancos.csv">bancos.csv</a> contiene las cotizaciones de los principales bancos de España, en el mes de abril de 2021. Contiene las columnas: Empresa (nombre de la empresa), Apertura (precio de la acción a la apertura de bolsa), Máximo (precio máximo de la acción durante la jornada), Mínimo (precio mínimo de la acción durante la jornada), Cierre (precio de la acción al cierre de bolsa), Volumen (volumen al cierre de bolsa). Construir una función reciba el archivo bancos.csv y cree un diagrama de líneas con las series temporales de las cotizaciones de cierre de cada banco, usando el mismo eje y colores diferentes por cada banco.</p>
</section>
</section>

        </main> <!-- /main -->
        <script id="quarto-html-after-body" type="application/javascript">
            window.document.addEventListener("DOMContentLoaded", function (event) {
                const toggleBodyColorMode = (bsSheetEl) => {
                    const mode = bsSheetEl.getAttribute("data-mode");
                    const bodyEl = window.document.querySelector("body");
                    if (mode === "dark") {
                        bodyEl.classList.add("quarto-dark");
                        bodyEl.classList.remove("quarto-light");
                    } else {
                        bodyEl.classList.add("quarto-light");
                        bodyEl.classList.remove("quarto-dark");
                    }
                }
                const toggleBodyColorPrimary = () => {
                    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
                    if (bsSheetEl) {
                        toggleBodyColorMode(bsSheetEl);
                    }
                }
                toggleBodyColorPrimary();
                const icon = "";
                const anchorJS = new window.AnchorJS();
                anchorJS.options = {
                    placement: 'right',
                    icon: icon
                };
                anchorJS.add('.anchored');
                const isCodeAnnotation = (el) => {
                    for (const clz of el.classList) {
                        if (clz.startsWith('code-annotation-')) {
                            return true;
                        }
                    }
                    return false;
                }
                const clipboard = new window.ClipboardJS('.code-copy-button', {
                    text: function (trigger) {
                        const codeEl = trigger.previousElementSibling.cloneNode(true);
                        for (const childEl of codeEl.children) {
                            if (isCodeAnnotation(childEl)) {
                                childEl.remove();
                            }
                        }
                        return codeEl.innerText;
                    }
                });
                clipboard.on('success', function (e) {
                    // button target
                    const button = e.trigger;
                    // don't keep focus
                    button.blur();
                    // flash "checked"
                    button.classList.add('code-copy-button-checked');
                    var currentTitle = button.getAttribute("title");
                    button.setAttribute("title", "Copied!");
                    let tooltip;
                    if (window.bootstrap) {
                        button.setAttribute("data-bs-toggle", "tooltip");
                        button.setAttribute("data-bs-placement", "left");
                        button.setAttribute("data-bs-title", "Copied!");
                        tooltip = new bootstrap.Tooltip(button,
                            {
                                trigger: "manual",
                                customClass: "code-copy-button-tooltip",
                                offset: [0, -8]
                            });
                        tooltip.show();
                    }
                    setTimeout(function () {
                        if (tooltip) {
                            tooltip.hide();
                            button.removeAttribute("data-bs-title");
                            button.removeAttribute("data-bs-toggle");
                            button.removeAttribute("data-bs-placement");
                        }
                        button.setAttribute("title", currentTitle);
                        button.classList.remove('code-copy-button-checked');
                    }, 1000);
                    // clear code selection
                    e.clearSelection();
                });
                function tippyHover(el, contentFn) {
                    const config = {
                        allowHTML: true,
                        content: contentFn,
                        maxWidth: 500,
                        delay: 100,
                        arrow: false,
                        appendTo: function (el) {
                            return el.parentElement;
                        },
                        interactive: true,
                        interactiveBorder: 10,
                        theme: 'quarto',
                        placement: 'bottom-start'
                    };
                    window.tippy(el, config);
                }
                const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
                for (var i = 0; i < noterefs.length; i++) {
                    const ref = noterefs[i];
                    tippyHover(ref, function () {
                        // use id or data attribute instead here
                        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
                        try { href = new URL(href).hash; } catch { }
                        const id = href.replace(/^#\/?/, "");
                        const note = window.document.getElementById(id);
                        return note.innerHTML;
                    });
                }
                let selectedAnnoteEl;
                const selectorForAnnotation = (cell, annotation) => {
                    let cellAttr = 'data-code-cell="' + cell + '"';
                    let lineAttr = 'data-code-annotation="' + annotation + '"';
                    const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
                    return selector;
                }
                const selectCodeLines = (annoteEl) => {
                    const doc = window.document;
                    const targetCell = annoteEl.getAttribute("data-target-cell");
                    const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
                    const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
                    const lines = annoteSpan.getAttribute("data-code-lines").split(",");
                    const lineIds = lines.map((line) => {
                        return targetCell + "-" + line;
                    })
                    let top = null;
                    let height = null;
                    let parent = null;
                    if (lineIds.length > 0) {
                        //compute the position of the single el (top and bottom and make a div)
                        const el = window.document.getElementById(lineIds[0]);
                        top = el.offsetTop;
                        height = el.offsetHeight;
                        parent = el.parentElement.parentElement;
                        if (lineIds.length > 1) {
                            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
                            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
                            height = bottom - top;
                        }
                        if (top !== null && height !== null && parent !== null) {
                            // cook up a div (if necessary) and position it 
                            let div = window.document.getElementById("code-annotation-line-highlight");
                            if (div === null) {
                                div = window.document.createElement("div");
                                div.setAttribute("id", "code-annotation-line-highlight");
                                div.style.position = 'absolute';
                                parent.appendChild(div);
                            }
                            div.style.top = top - 2 + "px";
                            div.style.height = height + 4 + "px";
                            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
                            if (gutterDiv === null) {
                                gutterDiv = window.document.createElement("div");
                                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                                gutterDiv.style.position = 'absolute';
                                const codeCell = window.document.getElementById(targetCell);
                                const gutter = codeCell.querySelector('.code-annotation-gutter');
                                gutter.appendChild(gutterDiv);
                            }
                            gutterDiv.style.top = top - 2 + "px";
                            gutterDiv.style.height = height + 4 + "px";
                        }
                        selectedAnnoteEl = annoteEl;
                    }
                };
                const unselectCodeLines = () => {
                    const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
                    elementsIds.forEach((elId) => {
                        const div = window.document.getElementById(elId);
                        if (div) {
                            div.remove();
                        }
                    });
                    selectedAnnoteEl = undefined;
                };
                // Attach click handler to the DT
                const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
                for (const annoteDlNode of annoteDls) {
                    annoteDlNode.addEventListener('click', (event) => {
                        const clickedEl = event.target;
                        if (clickedEl !== selectedAnnoteEl) {
                            unselectCodeLines();
                            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
                            if (activeEl) {
                                activeEl.classList.remove('code-annotation-active');
                            }
                            selectCodeLines(clickedEl);
                            clickedEl.classList.add('code-annotation-active');
                        } else {
                            // Unselect the line
                            unselectCodeLines();
                            clickedEl.classList.remove('code-annotation-active');
                        }
                    });
                }
                const findCites = (el) => {
                    const parentEl = el.parentElement;
                    if (parentEl) {
                        const cites = parentEl.dataset.cites;
                        if (cites) {
                            return {
                                el,
                                cites: cites.split(' ')
                            };
                        } else {
                            return findCites(el.parentElement)
                        }
                    } else {
                        return undefined;
                    }
                };
                var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
                for (var i = 0; i < bibliorefs.length; i++) {
                    const ref = bibliorefs[i];
                    const citeInfo = findCites(ref);
                    if (citeInfo) {
                        tippyHover(citeInfo.el, function () {
                            var popup = window.document.createElement('div');
                            citeInfo.cites.forEach(function (cite) {
                                var citeDiv = window.document.createElement('div');
                                citeDiv.classList.add('hanging-indent');
                                citeDiv.classList.add('csl-entry');
                                var biblioDiv = window.document.getElementById('ref-' + cite);
                                if (biblioDiv) {
                                    citeDiv.innerHTML = biblioDiv.innerHTML;
                                }
                                popup.appendChild(citeDiv);
                            });
                            return popup.innerHTML;
                        });
                    }
                }
            });
        </script>
        <nav class="page-navigation">
            <div class="nav-page nav-page-previous">
                <a href="./06_Numpy.html" class="pagination-link">
                    <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span
                            class="chapter-number">6</span>&nbsp; <span class="chapter-title">Introducción a NumPy
                                </span></span>
                </a>
            </div>
            <div class="nav-page nav-page-next">
                <a href="./08_Matplotlib.html" class="pagination-link">
                    <span class="nav-page-text"><span class="chapter-number">8</span>&nbsp; <span
                            class="chapter-title">Visualización de datos con Matplotlib y Seaborn</span></span> <i class="bi bi-arrow-right-short"></i>
                </a>
            </div>
        </nav>
    </div>
    <!-- /content -->



</body>

</html>